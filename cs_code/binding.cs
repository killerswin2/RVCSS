using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Numerics;

namespace RV
{
    /// <summary>
    /// Class <c>GameValue</c> handles rv engine types and functions used by the engine.
    /// </summary>
	public class GameValue
    {
        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValue();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValueFloat(float value);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValueInt(int value);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValueBool(bool value);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValueString(string value);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValueArray(IntPtr pointer, int length);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValueArrayEmpty();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValueVector2(Vector2 vector);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr CreateGameValueVector3(Vector3 vector);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern void DeleteGameValue(IntPtr gameValuePointer);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr GetDataString(IntPtr gameValuePointer);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern int GetDataInt(IntPtr gameValuePointer);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern float GetDataFloat(IntPtr gameValuePointer);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern bool GetDataBool(IntPtr gameValuePointer);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr GetDataVector2(IntPtr gameValuePointer);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr GetDataVector3(IntPtr gameValuePointer);


        // "Static functions here";

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr acctime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr action(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr actionids(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr actionkeys(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr actionkeysex(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr actionkeysimages(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr actionkeysnames(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr actionkeysnamesarray(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr actionname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr actionparams(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr activateaddons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr activatedaddons();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr activatekey(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr activetitleeffectparams(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr add3denconnection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr add3deneventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr add3denlayer(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addaction(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addbackpack(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addbackpackcargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addbackpackcargoglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addbackpackglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addbinocularitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addcamshake(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addcuratoraddons(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addcuratorcameraarea(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addcuratoreditableobjects(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addcuratoreditingarea(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addcuratorpoints(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addeditorobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addforce(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addforcegeneratorrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addgoggles(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addgroupicon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addhandgunitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addheadgear(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr additem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr additemcargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr additemcargoglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr additempool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr additemtobackpack(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr additemtouniform(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr additemtovest(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addlivestats(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmagazine(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmagazineammocargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmagazinecargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmagazinecargoglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmagazineglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmagazinepool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmagazines(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmagazineturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmenu(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmenuitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmissioneventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmpeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addmusiceventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addonfiles(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addownedmine(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addplayerscores(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addprimaryweaponitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addpublicvariableeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addrating(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addresources(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addscore(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addscoreside(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addsecondaryweaponitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addswitchableunit(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addteammember(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addtoremainscollector(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addtorque(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr adduniform(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr adduseractioneventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addvehicle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addvest(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addwaypoint(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweapon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweaponcargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweaponcargoglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweaponglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweaponitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweaponpool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweaponturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweaponwithattachmentscargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr addweaponwithattachmentscargoglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr admin(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr agent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr agents();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr agltoasl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr aimedattarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr aimpos(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr airdensitycurvertd();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr airdensityrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr airplanethrottle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr airportside(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr aisfinishheal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr alive(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr all3denentities();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allactivetitleeffects();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr alladdonsinfo();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allairports();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allcontrols(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allcurators();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allcutlayers();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr alldead();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr alldeadmen();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr alldiaryrecords(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr alldiarysubjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr alldisplays();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allenv3dsoundsources();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allgroups();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr alllods(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allmapmarkers();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allmines();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allmissionobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allobjects(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allow3dmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowcrewinimmobile(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowcuratorlogicignoreareas(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowdamage(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowdammage(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowedservice(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowfileoperations(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowfleeing(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowgetin(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowservice(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allowsprint(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allplayers();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allsimpleobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allsites();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allturrets(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allunits();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allunitsuav();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allusers();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr allvariables(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ambienttemperature();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ammo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ammoonpylon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr and(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animate(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animatebay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animatedoor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animatepylon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animatesource(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animationnames(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animationphase(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animationsourcephase(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr animationstate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr apertureparams();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr append(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr apply(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr armorypoints();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr arrayintersect(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr asin(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr asltoagl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr asltoatl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assert(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignascargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignascargoindex(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignascommander(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignasdriver(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignasgunner(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignasturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assigncurator(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedcommander(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assigneddriver(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedgroup(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedgunner(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assigneditems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedtarget(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedteam(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedvehicle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedvehiclerole(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignedvehicles(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assignteam(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr assigntoairport(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr atan(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr atan2(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr atg(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr atltoasl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr attachedobject(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr attachedobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr attachedto(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr attachobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr attachto(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr attackenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr awake(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr backpack(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr backpackcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr backpackcontainer(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr backpackitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr backpackmagazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr backpacks(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr backpackspacefor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr behaviour(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr benchmark();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr bezierinterpolation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr binocular(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr binocularitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr binocularmagazine(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr blufor();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr boundingbox(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr boundingboxreal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr boundingcenter(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr brakesdisabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr breakout(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr breakto(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr breakwith(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr briefingname();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr buildingexit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr buildingpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr buldozer_enableroaddiag(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr buldozer_isenabledroaddiag();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr buldozer_loadnewroads(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr buldozer_reloadopermap();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr buttonaction(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr buttonsetaction(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cadetmode();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr calculatepath(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr calculateplayervisibilitybyfriendly(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr call(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr callextension(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camcommand(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camcommit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camcommitprepared(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camcommitted(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camconstuctionsetparams(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camcreate(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camdestroy(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cameraeffect(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cameraeffectenablehud(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camerainterest(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cameraon();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cameraview();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campaignconfigfile();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreload(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreloaded(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparebank(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparedir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparedive(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparefocus(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparefov(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparefovrange(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparepos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparerelpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr campreparetarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsetbank(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsetdir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsetdive(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsetfocus(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsetfov(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsetfovrange(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsetpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsetrelpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camsettarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camtarget(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr camusenvg(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canadd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canadditemtobackpack(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canadditemtouniform(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canadditemtovest(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cancelsimpletaskdestination(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr candeployweapon(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canfire(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canmove(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canslingload(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canstand(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cansuspend();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cantriggerdynamicsimulation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canunloadincombat(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr canvehiclecargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr captive(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr captivenum(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cbchecked(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cbsetchecked(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ceil(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr channelenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cheatsenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr checkaifeature(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr checkvisibility(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr civilian();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr classname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clear3denattribute(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clear3deninventory(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearallitemsfrombackpack(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearbackpackcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearbackpackcargoglobal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearforcesrtd();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cleargroupicons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearitemcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearitemcargoglobal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearitempool();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearmagazinecargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearmagazinecargoglobal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearmagazinepool();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearoverlay(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearradio();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearweaponcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearweaponcargoglobal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clearweaponpool();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr clientowner();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr closedialog(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr closedisplay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr closeoverlay(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr collapseobjecttree(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr collect3denhistory(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr collectivertd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr collisiondisabledwith(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr combatbehaviour(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr combatmode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandartilleryfire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandchat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commander(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandfire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandfollow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandfsm(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandgetout(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandingmenu();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandmove(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandradio(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandstop(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandsuppressivefire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandtarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commandwatch(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr comment(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr commitoverlay(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr compatibleitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr compatiblemagazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr compile(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr compilefinal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr compilescript(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr completedfsm(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr composetext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configaccessor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configclasses(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configfile();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr confighierarchy(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr confignull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configof(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configproperties(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configsourceaddonlist(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configsourcemod(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr configsourcemodlist(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr confirmsensortarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr connectterminaltouav(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr connecttoserver(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr continuewith(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr controlnull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr controlsgroupctrl(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr conversationdisabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr copyfromclipboard();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr copytoclipboard(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr copywaypoints(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cos(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr count(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr countenemy(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr countfriendly(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr countside(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr counttype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr countunknown(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr create3dencomposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr create3denentity(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createagent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createcenter(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createdialog(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr creatediarylink(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr creatediaryrecord(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr creatediarysubject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createdisplay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr creategeardialog(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr creategroup(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createguardedpoint(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createhashmap();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createhashmapfromarray(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createlocation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createmarker(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createmarkerlocal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createmenu(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createmine(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createmissiondisplay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr creatempcampaigndisplay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createsimpleobject(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createsimpletask(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createsite(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createsoundsource(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createtask(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createteam(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createtrigger(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createunit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createvehicle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createvehiclecrew(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr createvehiclelocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr crew(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctaddheader(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctaddrow(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctclear(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctcursel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctfindheaderrows(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctfindrowheader(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctheadercontrols(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctheadercount(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctremoveheaders(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctremoverows(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlactivate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrladdeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlangle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlanimatemodel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlanimationphasemodel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlautoscrolldelay(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlautoscrollrewind(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlautoscrollspeed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlbackgroundcolor(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlchecked(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlclassname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlcommit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlcommitted(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlcreate(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrldelete(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlenable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlfade(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlfontheight(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlforegroundcolor(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlhtmlloaded(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlidc(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlidd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapanimadd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapanimclear(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapanimcommit(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapanimdone(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapcursor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapdir(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapmouseover(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapscale(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapscreentoworld(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapsetposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmapworldtoscreen(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmodel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmodeldirandup(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmodelscale(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlmouseposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlparent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlparentcontrolsgroup(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlremovealleventhandlers(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlremoveeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlscale(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlscrollvalues(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetactivecolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetangle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetautoscrolldelay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetautoscrollrewind(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetautoscrollspeed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetbackgroundcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetchecked(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetdisabledcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlseteventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfade(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfocus(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfont(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth1(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth1b(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth2(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth2b(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth3(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth3b(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth4(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth4b(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth5(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth5b(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth6(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfonth6b(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontheight(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontheighth1(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontheighth2(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontheighth3(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontheighth4(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontheighth5(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontheighth6(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontheightsecondary(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontp(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontpb(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetfontsecondary(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetforegroundcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetmodel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetmodeldirandup(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetmodelscale(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetmouseposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetpixelprecision(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetpositionh(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetpositionw(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetpositionx(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetpositiony(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetscale(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetscrollvalues(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetshadow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsetstructuredtext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettextcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettextcolorsecondary(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettextsecondary(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettextselection(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettooltip(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettooltipcolorbox(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettooltipcolorshade(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettooltipcolortext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlsettooltipmaxwidth(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlseturl(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlseturloverlaymode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlshadow(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlshow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlshown(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlstyle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrltext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrltextcolor(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrltextheight(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrltextsecondary(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrltextselection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrltextwidth(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrltooltip(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrltype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlurl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlurloverlaymode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrlvisible(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrowcontrols(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctrowcount(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctsetcursel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctsetdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctsetheadertemplate(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctsetrowtemplate(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctsetvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ctvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatoraddons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatorcamera();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatorcameraarea(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatorcameraareaceiling(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatorcoef(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatoreditableobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatoreditingarea(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatoreditingareatype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatormouseover();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatorpoints(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatorregisteredobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatorselected();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr curatorwaypointcost(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr current3denoperation();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentchannel();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentcommand(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentmagazine(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentmagazinedetail(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentmagazinedetailturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentmagazineturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentmuzzle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentnamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentpilot(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currenttask(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currenttasks(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentthrowable(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentvisionmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentwaypoint(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentweapon(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentweaponmode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentweaponturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr currentzeroing(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cursorobject();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cursortarget();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr customchat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr customradio(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr customwaypointposition();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cutfadeout(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cutobj(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cutrsc(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr cuttext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr damage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr date();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr datetonumber(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr daytime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deactivatekey(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr debriefingtext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr debugfsm(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr debuglog(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr decaygraphvalues(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deg(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr delete3denentities(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deleteat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletecenter(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletecollection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deleteeditorobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletegroup(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletegroupwhenempty(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deleteidentity(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletelocation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletemarker(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletemarkerlocal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deleterange(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deleteresources(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletesite(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletestatus(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deleteteam(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletevehicle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletevehiclecrew(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr deletewaypoint(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr detach(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr detectedmines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_activemissionfsms();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_activescripts();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_activesqfscripts();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_activesqsscripts();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_allmissioneventhandlers();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_captureframe(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_captureframetofile(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_captureslowframe(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_codeperformance(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_deltatime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_drawmode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_dumpcalltracetolog();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_dumpscriptassembly(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_dumpterrainsynth();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_dynamicsimulationend(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_enable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_enabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_exportconfig(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_exportterrainsvg(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_fps();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_fpsmin();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_frameno();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_getterrainsegmentoffset(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_lightnewload(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_list(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_localized(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_log(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_logslowframe(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_mergeconfigfile(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_recordturretlimits(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_resetfsm();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_resetshapes();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_scope();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_setlightnew(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_stacktrace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_ticktime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diag_toggle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dialog();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diaryrecordnull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr diarysubjectexists(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr didjip();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr didjipowner(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr difficulty();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr difficultyenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr difficultyenabledrtd();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr difficultyoption(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr direction(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr directionstabilizationenabled(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr directsay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disableai(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disablebrakes(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disablecollisionwith(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disableconversation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disabledebriefingstats();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disablemapindicators(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disablenvgequipment(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disableremotesensors(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disableserialization();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disabletiequipment(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disableuavconnectability(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr disableuserinput(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displayaddeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displaychild(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displayctrl(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displaynull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displayparent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displayremovealleventhandlers(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displayremoveeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displayseteventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displayuniquename(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr displayupdate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dissolveteam(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr distance(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr distance2d(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr distancesqr(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr distributionregion();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr do3denaction(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr doartilleryfire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dofire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dofollow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dofsm(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dogetout(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr domove(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr doorphase(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dostop(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dosuppressivefire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dotarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dowatch(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawarrow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawellipse(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawicon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawicon3d(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawlaser(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawline(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawline3d(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawlink(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawlocation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawpolygon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawrectangle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drawtriangle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr driver(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr drop(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dynamicsimulationdistance(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dynamicsimulationdistancecoef(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dynamicsimulationenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr dynamicsimulationsystemenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr east();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr echo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr edit3denmissionattributes(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr editobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr editorseteventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr effectivecommander(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr elevateperiscope(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr emptypositions(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableai(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableaifeature(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableaimprecision(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableattack(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableaudiofeature(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableautostartuprtd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableautotrimrtd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablecamshake(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablecaustics(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablechannel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablecollisionwith(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablecopilot(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enabledebriefingstats(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablediaglegend(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enabledirectionstabilization(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enabledynamicsimulation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enabledynamicsimulationsystem(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableenddialog();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableengineartillery(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableenvironment(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablefatigue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablegunlights(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableinfopanelcomponent(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableirlasers(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablemimics(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablepersonturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableradio(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablereload(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableropeattach(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablesatnormalondetail(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablesaving(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablesentences(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablesimulation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablesimulationglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablestamina(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablestressdamage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableteamswitch(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enabletraffic(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableuavconnectability(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableuavwaypoints(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablevehiclecargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enablevehiclesensor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enableweapondisassembly(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr endl();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr endloadingscreen();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr endmission(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr engineon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enginesisonrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enginespowerrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enginesrpmrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr enginestorquertd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr entities(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr environmentenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr environmentvolume();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr equipmentdisabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr estimatedendservertime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr estimatedtimeleft(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr evalobjectargument(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr everybackpack(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr everycontainer(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr exec(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr execeditorscript(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr execfsm(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr execvm(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr exit();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr exitwith(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr exp(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr expecteddestination(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr exportjipmessages(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr eyedirection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr eyepos(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr face(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr faction(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fadeenvironment(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fademusic(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr faderadio(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fadesound(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fadespeech(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr failmission(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fileexists(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fillweaponsfrompool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr find(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr findany(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr findcover(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr finddisplay(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr findeditorobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr findemptyposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr findemptypositionready(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr findif(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr findnearestenemy(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr finishmissioninit();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr finite(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fireattarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr firstbackpack(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr flag(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr flaganimationphase(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr flagowner(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr flagside(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr flagtexture(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr flatten(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fleeing(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr floor(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr flyinheight(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr flyinheightasl(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr focusedctrl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fog();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fogforecast();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fogparams();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forceadduniform(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forceatpositionrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forcecadetdifficulty(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forcedmap();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forceend();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forceflagtexture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forcefollowroad(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forcegeneratorrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forcemap(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forcerespawn(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forcespeed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forceunicode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forcewalk(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forceweaponfire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forceweatherchange();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr foreachmember(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr foreachmemberagent(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr foreachmemberteam(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr forgettarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr format(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr formation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr formationdirection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr formationleader(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr formationmembers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr formationposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr formationtask(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr formattext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr formleader(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr freeextension(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr freelook();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr from(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fromeditor(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fuel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr fullcrew(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gearidcammocount(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gearslotammocount(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gearslotdata(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gesturestate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denactionstate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denattribute(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3dencamera();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denconnections(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denentity(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denentityid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3dengrid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3deniconsvisible();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denlayerentities(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denlinesvisible();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denmissionattribute(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denmouseover();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr get3denselected(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getaimingcoef(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getallenv3dsoundcontrollers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getallenvsoundcontrollers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getallhitpointsdamage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getallownedmines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getallpylonsinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getallsoundcontrollers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getallunittraits(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getammocargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getanimaimprecision(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getanimspeedcoef(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getarray(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getartilleryammo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getartillerycomputersettings();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getartilleryeta(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getassetdlcinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getassignedcuratorlogic(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getassignedcuratorunit(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getattacktarget(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getaudiooptionvolumes();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getbackpackcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getbleedingremaining(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getburningvalue(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcalculateplayervisibilitybyfriendly();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcameraviewdirection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcargoindex(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcenterofmass(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getclientstate();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getclientstatenumber();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcompatiblepylonmagazines(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getconnecteduav(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getconnecteduavunit(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcontainermaxload(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcorpse(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcruisecontrol(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcursorobjectparams();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcustomaimcoef(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcustomsoundcontroller(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getcustomsoundcontrollercount(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdammage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdebriefingtext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdescription(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdirvisual(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdiverstate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdlcassetsusage();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdlcassetsusagebyname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdlcs(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getdlcusagetime(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr geteditorcamera(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr geteditormode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr geteditorobjectscope(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getelevationoffset();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getenginetargetrpmrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getenv3dsoundcontroller(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getenvsoundcontroller(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr geteventhandlerinfo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getfatigue(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getfieldmanualstartpage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getforcedflagtexture(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getforcedspeed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getfriend(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getfsmvariable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getfuelcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getgraphvalues(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getgroupicon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getgroupiconparams(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getgroupicons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gethidefrom(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gethit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gethitindex(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gethitpointdamage(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getitemcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getlighting();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getlightingat(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getloadedmodsinfo();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmagazinecargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmarkercolor(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmarkerpos(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmarkersize(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmarkertype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmass(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmissionconfig(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmissionconfigvalue(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmissiondlcs();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmissionlayerentities(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmissionlayers();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmissionpath(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmodelinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmouseposition();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getmusicplayedtime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getnumber(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectargument(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectchildren(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectdlc(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectfov(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectmaterials(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectproxy(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectscale(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjecttextures(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjecttype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getobjectviewdistance();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getopticsmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getordefault(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getordefaultcall(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getoxygenremaining(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getpersonuseddlcs(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getpilotcameradirection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getpilotcameraposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getpilotcamerarotation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getpilotcameratarget(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getpipviewdistance();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getplatenumber(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getplayerchannel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getplayerid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getplayerscores(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getplayeruid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getplayervonvolume(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getposasl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getposaslvisual(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getposaslw(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getposatl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getposatlvisual(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getposvisual(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getposworld(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getposworldvisual(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getpylonmagazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getreldir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getrelpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getremotesensorsdisabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getrepaircargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getresolution();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getroadinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getrotorbrakertd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getsensortargets(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getsensorthreats(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getshadowdistance();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getshotparents(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getslingload(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getsoundcontroller(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getsoundcontrollerresult(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getspeed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getstamina(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getstatvalue(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getsteamfriendsservers();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getsubtitleoptions();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getsuppression(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getterraingrid();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getterrainheight(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getterrainheightasl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getterraininfo();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gettext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gettextraw(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gettextureinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gettextwidth(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gettiparameters();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gettotaldlcusagetime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gettowparent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gettrimoffsetrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getturretlimits(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getturretopticsmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getunitfreefallinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getunitloadout(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getunittrait(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getunloadincombat(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getuserinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getusermfdtext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getusermfdvalue(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getvariable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getvehiclecargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getvehicletipars(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getvideooptions();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getweaponcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getweaponsway(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getwingsorientationrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getwingspositionrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr getwppos(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr glanceat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr globalchat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr globalradio(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr goggles(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr group(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupchat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupfromnetid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupiconselectable();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupiconsvisible();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupowner(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupradio(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groups(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupselectedunits(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr groupselectunit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr grpnull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gunner(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr gusts();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr halt();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr handgunitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr handgunmagazine(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr handgunweapon(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr handshit(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hashvalue(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hasinterface();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr haspilotcamera(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hasweapon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcallgroups(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcgroupparams(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcleader(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcremoveallgroups(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcremovegroup(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcselected(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcselectgroup(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcsetgroup(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcshowbar(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hcshownbar();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr headgear(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hidebody(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hideobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hideobjectglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hideselection(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hint(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hintc(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hintcadet(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hintsilent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hmd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hostmission(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr htmlload(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr hudmovementlevels();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr humidity();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr image(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr importallgroups(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr importance(IntPtr rightGameValue);


        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inarea(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inareaarray(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr incapacitatedstate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr independent();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inflame(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inflamed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr infopanel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr infopanelcomponentenabled(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr infopanelcomponents(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr infopanels(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ingameuiseteventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inheritsfrom(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr initambientlife();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inpolygon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inputaction(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inputcontroller(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inputmouse(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inrangeofartillery(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr insert(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr inserteditorobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr insidebuilding(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr intersect(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr is3den();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr is3denmultiplayer();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr is3denpreview();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isabletobreathe(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isactionmenuvisible();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isagent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isaimprecisionenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isallowedcrewinimmobile(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isarray(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isautohoveron(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isautonomous(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isautostartupenabledrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isautotest();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isautotrimonrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isawake(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isbleeding(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isburning(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isclass(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr iscollisionlighton(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr iscopilotenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isdamageallowed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isdedicated();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isdlcavailable(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isengineon(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isequalref(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isequalto(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isequaltype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isequaltypeall(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isequaltypeany(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isequaltypearray(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isequaltypeparams(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isfilepatchingenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isfinal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isflashlighton(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isflatempty(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isforcedwalk(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isformationleader(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isgamefocused();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isgamepaused();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isgroupdeletedwhenempty(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ishidden(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isinremainscollector(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isinstructorfigureenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isirlaseron(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr iskeyactive(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr iskindof(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr islaseron(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr islighton(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr islocalized(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ismanualfire(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ismarkedforcollection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ismissionprofilenamespaceloaded();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ismultiplayer();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ismultiplayersolo();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isnil(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isnotequalref(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isnotequalto(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isnull(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isnumber(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isobjecthidden(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isobjectrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isonroad(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ispipenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isplayer(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isrealtime(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isremoteexecuted();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isremoteexecutedjip();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr issaving();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr issensortargetconfirmed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isserver();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isshowing3dicons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr issimpleobject(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr issprintallowed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isstaminaenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr issteammission();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr issteamoverlayenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isstreamfriendlyuienabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isstressdamageenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr istext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr istouchingground(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isturnedout(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr istuthintsenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isuavconnectable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isuavconnected(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isuicontext();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isuniformallowed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isvehiclecargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isvehicleradaron(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isvehiclesensorenabled(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr iswalking(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isweapondeployed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr isweaponrested(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr itemcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr items(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr itemswithmagazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr join(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr joinas(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr joinassilent(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr joinsilent(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr joinstring(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr kbadddatabase(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr kbadddatabasetargets(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr kbaddtopic(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr kbhastopic(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr kbreact(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr kbremovetopic(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr kbtell(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr kbwassaid(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr keyimage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr keyname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr keys(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr knowsabout(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr land(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr landat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr landresult(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr language();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lasertarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbadd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbclear(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbcolorright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbcursel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbdelete(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbisselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbpicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbpictureright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbselection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetcolorright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetcursel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetpicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetpicturecolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetpicturecolordisabled(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetpicturecolorselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetpictureright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetpicturerightcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetpicturerightcolordisabled(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetpicturerightcolorselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetselectcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetselectcolorright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsettext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsettextright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsettooltip(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsetvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsize(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsort(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsortby(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbsortbyvalue(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbtext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbtextright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbtooltip(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lbvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leader(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboarddeinit(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboardgetrows(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboardinit(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboardrequestrowsfriends(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboardrequestrowsglobal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboardrequestrowsglobalarounduser(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboardsrequestuploadscore(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboardsrequestuploadscorekeepbest(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leaderboardstate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr leavevehicle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr librarycredits();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr librarydisclaimers();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lifestate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lightattachobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lightdetachobject(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lightison(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lightnings();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr limitspeed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr linearconversion(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr linebreak();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lineintersects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lineintersectsobjs(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lineintersectssurfaces(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lineintersectswith(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr linkitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr list(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr listobjects(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr listremotetargets(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr listvehiclesensors(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ln(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbaddarray(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbaddcolumn(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbaddrow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbclear(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbcolorright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbcurselrow(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbdeletecolumn(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbdeleterow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbgetcolumnsposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbpicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbpictureright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetcolorright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetcolumnspos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetcurselrow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetpicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetpicturecolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetpicturecolorright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetpicturecolorselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetpicturecolorselectedright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetpictureright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsettext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsettextright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsettooltip(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsetvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsize(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsort(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsortby(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbsortbyvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbtext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbtextright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lnbvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr load(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadabs(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadbackpack(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadconfig(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadfile(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadgame();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadidentity(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadmagazine(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadoverlay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadstatus(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loaduniform(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr loadvest(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr local(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr localize(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr localnamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr locationnull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr locationposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr Lock(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockcamerato(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockcargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockdriver(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr locked(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockedcamerato(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockedcargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockeddriver(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockedinventory(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockedturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockidentity(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockinventory(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lockwp(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr logentities();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lognetwork(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lognetworkterminate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lookat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr lookatpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinecargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesallturrets(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesammo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesammocargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesammofull(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesdetail(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesdetailbackpack(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesdetailuniform(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesdetailvest(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazinesturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr magazineturretammo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr mapanimadd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr mapanimclear();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr mapanimcommit();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr mapanimdone();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr mapcenteroncamera(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr mapgridposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markasfinishedonsteam();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markeralpha(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markerbrush(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markerchannel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markercolor(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markerdir(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markerpolyline(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markerpos(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markershadow(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markershape(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markersize(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markertext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr markertype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr matrixmultiply(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr matrixtranspose(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr max(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr maxload(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr members(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuaction(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuadd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuchecked(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuclear(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menucollapse(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menudata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menudelete(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuenable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuenabled(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuexpand(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuhover(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menupicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusetaction(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusetcheck(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusetdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusetpicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusetshortcut(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusettext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuseturl(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusetvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menushortcut(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menushortcuttext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusize(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menusort(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menutext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuurl(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr menuvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr merge(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr mineactive(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr minedetectedby(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missiletarget(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missiletargetpos(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missionconfigfile();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missiondifficulty();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missionend();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missionname();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missionnamesource();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missionnamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missionprofilenamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missionstart();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr missionversion();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr mod(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr modeltoworld(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr modeltoworldvisual(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr modeltoworldvisualworld(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr modeltoworldworld(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr modparams(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moonintensity();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moonphase(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr morale(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr move(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr move3dencamera(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveinany(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveincargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveincommander(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveindriver(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveingunner(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveinturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveobjecttoend(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveout(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr movetime(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr moveto(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr movetocompleted(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr movetofailed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr musicvolume();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr name(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr namedproperties(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr namesound(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearentities(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearestbuilding(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearestlocation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearestlocations(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearestlocationwithdubbing(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearestmines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearestobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearestobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearestterrainobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearobjects(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearobjectsready(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearroads(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nearsupplies(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr neartargets(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr needreload(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr needservice(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr netid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr netobjnull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr newoverlay(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nextmenuitemindex(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nextweatherchange();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nil();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr nmenuitems(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr not(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr numberofenginesrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr numbertodate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr objectcurators(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr objectfromnetid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr objectparent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr objnull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr objstatus(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onbriefinggroup(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onbriefingnotes(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onbriefingplan(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onbriefingteamswitch(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr oncommandmodechanged(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ondoubleclick(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr oneachframe(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ongroupiconclick(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ongroupiconoverenter(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ongroupiconoverleave(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onhcgroupselectionchanged(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onmapsingleclick(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onplayerconnected(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onplayerdisconnected(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onpreloadfinished(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onpreloadstarted(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onshownewobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr onteamswitch(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr opencuratorinterface();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr opendlcpage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr opengps(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr openmap(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr opensteamapp(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr openyoutubevideo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr opfor();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr or(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ordergetin(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr overcast();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr overcastforecast();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr owner(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr param(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr parsenumber(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr parsesimplearray(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr parsetext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr parsingnamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr particlesquality();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr periscopeelevation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pi();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pickweaponpool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pitch(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pixelgrid();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pixelgridbase();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pixelgridnouiscale();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pixelh();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pixelw();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playableslotsnumber(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playableunits();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playaction(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playactionnow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr player();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playerrespawntime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playerside();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playersnumber(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playgesture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playmission(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playmove(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playmovenow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playmusic(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playscriptedmission(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playsound(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playsound3d(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr playsoundui(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pose(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr position(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr positioncameratoworld(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr posscreentoworld(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr posworldtoscreen(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ppeffectadjust(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ppeffectcommit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ppeffectcommitted(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ppeffectcreate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ppeffectdestroy(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ppeffectenable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ppeffectenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ppeffectforceinnvg(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr precision(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr preloadcamera(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr preloadobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr preloadsound(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr preloadtitleobj(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr preloadtitlersc(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr preprocessfile(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr preprocessfilelinenumbers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr primaryweapon(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr primaryweaponitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr primaryweaponmagazine(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr priority(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr processdiarylink(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr productversion();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr profilename();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr profilenamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr profilenamesteam();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr progressloadingscreen(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr progressposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr progresssetposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr publicvariable(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr publicvariableclient(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr publicvariableserver(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pushback(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr pushbackunique(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr putweaponpool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr queryitemspool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr querymagazinepool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr queryweaponpool(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rad(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr radiochanneladd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr radiochannelcreate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr radiochannelinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr radiochannelremove(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr radiochannelsetcallsign(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr radiochannelsetlabel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr radioenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr radiovolume();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rain();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rainbow();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rainparams();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr random(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rank(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rankid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rating(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rectangular(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr regexfind(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr regexmatch(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr regexreplace(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr registeredtasks(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr registertask(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr reload(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr reloadenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr remotecontrol(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr remoteexec(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr remoteexeccall(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr remoteexecutedowner();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr remove3denconnection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr remove3deneventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr remove3denlayer(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeaction(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeall3deneventhandlers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallactions(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallassigneditems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallbinocularitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallcontainers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallcuratoraddons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallcuratorcameraareas(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallcuratoreditingareas(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removealleventhandlers(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallhandgunitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallitemswithmagazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallmissioneventhandlers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallmpeventhandlers(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallmusiceventhandlers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallownedmines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallprimaryweaponitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallsecondaryweaponitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removealluseractioneventhandlers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeallweapons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removebackpack(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removebackpackglobal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removebinocularitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removecuratoraddons(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removecuratorcameraarea(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removecuratoreditableobjects(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removecuratoreditingarea(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removediaryrecord(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removediarysubject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removedrawicon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removedrawlinks(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removefromremainscollector(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removegoggles(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removegroupicon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removehandgunitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeheadgear(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeitemfrombackpack(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeitemfromuniform(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeitemfromvest(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeitems(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removemagazine(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removemagazineglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removemagazines(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removemagazinesturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removemagazineturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removemenuitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removemissioneventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removempeventhandler(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removemusiceventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeownedmine(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeprimaryweaponitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removesecondaryweaponitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removesimpletask(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeswitchableunit(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeteammember(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeuniform(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeuseractioneventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removevest(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeweapon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeweaponattachmentcargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeweaponcargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeweaponglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr removeweaponturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr reportremotetarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr requiredversion(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr resetcamshake();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr resetsubgroupdirection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr resistance();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr resize(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr resources(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr respawnvehicle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr restarteditorcamera(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr reveal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr revealmine(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr reverse(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr reversedmousey();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr roadat(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr roadsconnectedto(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr roledescription(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropeattachedobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropeattachedto(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropeattachenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropeattachto(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropecreate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropecut(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropedestroy(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropedetach(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropeendposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropelength(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropes(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropesattachedto(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropesegments(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropeunwind(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr ropeunwound(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rotorsforcesrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr rotorsrpmrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr round(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr runinitscript();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr safezoneh();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr safezonew();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr safezonewabs();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr safezonex();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr safezonexabs();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr safezoney();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr save3deninventory(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr savegame();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr saveidentity(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr savejoysticks();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr savemissionprofilenamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr saveoverlay(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr saveprofilenamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr savestatus(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr savevar(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr savingenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr say(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr say2d(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr say3d(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr scopename(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr score(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr scoreside(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr screenshot(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr screentoworld(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr scriptdone(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr scriptname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr scriptnull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr scudstate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr secondaryweapon(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr secondaryweaponitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr secondaryweaponmagazine(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr select(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectbestplaces(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectdiarysubject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectededitorobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selecteditorobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectionnames(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectionposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectionvectordirandup(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectleader(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectmax(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectmin(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectnoplayer();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectplayer(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectrandom(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectrandomweighted(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectweapon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr selectweaponturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sendaumessage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sendsimplecommand(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sendtask(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sendtaskresult(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sendudpmessage(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sentencesenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr servercommand(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr servercommandavailable(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr servercommandexecutable(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr servername();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr servernamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr servertime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denattribute(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denattributes(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3dengrid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3deniconsvisible(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denlayer(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denlinesvisible(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denlogictype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denmissionattribute(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denmissionattributes(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denmodelsvisible(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denobjecttype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr set3denselected(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setacctime(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setactualcollectivertd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setairplanethrottle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setairportside(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setammo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setammocargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setammoonpylon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setanimspeedcoef(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setaperture(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setaperturenew(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setarmorypoints(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setattributes(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setautonomous(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setbehaviour(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setbehaviourstrong(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setbleedingremaining(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setbrakesrtd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcamerainterest(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcamshakedefparams(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcamshakeparams(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcamuseti(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcaptive(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcenterofmass(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcollisionlight(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcombatbehaviour(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcombatmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcompassoscillation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setconvoyseparation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcruisecontrol(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcuratorcameraareaceiling(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcuratorcoef(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcuratoreditingareatype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcuratorwaypointcost(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcurrentchannel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcurrenttask(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcurrentwaypoint(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcustomaimcoef(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcustommissiondata(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcustomsoundcontroller(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setcustomweightrtd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdamage(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdammage(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdebriefingtext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdefaultcamera(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdestination(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdetailmapblendpars(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdiaryrecordtext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdiarysubjectpicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdirection(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdrawicon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdriveonpath(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdropinterval(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdynamicsimulationdistance(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setdynamicsimulationdistancecoef(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr seteditormode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr seteditorobjectscope(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr seteffectcondition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr seteffectivecommander(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setenginerpmrtd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setface(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfaceanimation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfatigue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfeaturetype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setflaganimationphase(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setflagowner(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setflagside(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setflagtexture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfog(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setforcegeneratorrtd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setformation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setformationtask(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setformdir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfriend(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfromeditor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfsmvariable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfuel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setfuelcargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setgroupicon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setgroupiconparams(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setgroupiconsselectable(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setgroupiconsvisible(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setgroupid(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setgroupidglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setgroupowner(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setgusts(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sethidebehind(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sethit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sethitindex(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sethitpointdamage(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sethorizonparallaxcoef(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sethudmovementlevels(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sethumidity(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setidentity(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setimportance(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setinfopanel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setleader(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightambient(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightattenuation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightbrightness(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightconepars(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightdaylight(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightflaremaxdistance(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightflaresize(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightintensity(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightnings(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightuseflare(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlightvolumeshape(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setlocalwindparams(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmagazineturretammo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkeralpha(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkeralphalocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkerbrush(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkerbrushlocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkercolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkercolorlocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkerdir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkerdirlocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkerpolyline(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkerpolylinelocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkerpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkerposlocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkershadow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkershadowlocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkershape(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkershapelocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkersize(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkersizelocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkertext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkertextlocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkertype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmarkertypelocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmass(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmaxload(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmimic(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmissiletarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmissiletargetpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmouseposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmusiceffect(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setmusiceventhandler(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setname(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setnamesound(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setobjectarguments(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setobjectmaterial(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setobjectmaterialglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setobjectproxy(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setobjectscale(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setobjecttexture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setobjecttextureglobal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setobjectviewdistance(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setopticsmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setovercast(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setowner(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setoxygenremaining(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setparticlecircle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setparticleclass(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setparticlefire(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setparticleparams(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setparticlerandom(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpilotcameradirection(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpilotcamerarotation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpilotcameratarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpilotlight(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpipeffect(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpipviewdistance(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpitch(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setplatenumber(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setplayable(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setplayerrespawntime(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setplayervonvolume(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setposasl(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setposasl2(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setposaslw(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setposatl(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setposworld(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpylonloadout(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setpylonspriority(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setradiomsg(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setrain(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setrainbow(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setrandomlip(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setrank(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setrectangular(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setrepaircargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setrotorbrakertd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setshadowdistance(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setshotparents(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setside(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsimpletaskalwaysvisible(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsimpletaskcustomdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsimpletaskdescription(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsimpletaskdestination(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsimpletasktarget(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsimpletasktype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsimulweatherlayers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsize(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setskill(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setslingload(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsoundeffect(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setspeaker(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setspeech(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setspeedmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setstamina(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setstaminascheme(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setstatvalue(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsuppression(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setsystemofunits(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settargetage(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settaskmarkeroffset(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settaskresult(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settaskstate(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setterraingrid(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setterrainheight(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settimemultiplier(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settiparameter(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settitleeffect(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settowparent(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settrafficdensity(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settrafficdistance(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settrafficgap(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settrafficspeed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settriggeractivation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settriggerarea(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settriggerinterval(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settriggerstatements(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settriggertext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settriggertimeout(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settriggertype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setturretlimits(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setturretopticsmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr settype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunconscious(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunitability(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunitcombatmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunitfreefallheight(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunitloadout(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunitpos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunitposweak(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunitrank(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunitrecoilcoefficient(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunittrait(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setunloadincombat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setuseractiontext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setusermfdtext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setusermfdvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvariable(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvectordir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvectordirandup(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvectorup(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehicleammo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehicleammodef(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehiclearmor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehiclecargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehicleid(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehiclelock(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehicleposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehicleradar(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehiclereceiveremotetargets(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehiclereportownposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehiclereportremotetargets(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehicletipars(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvehiclevarname(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvelocity(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvelocitymodelspace(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvelocitytransformation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setviewdistance(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setvisibleiftreecollapsed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwantedrpmrtd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaves(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointbehaviour(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointcombatmode(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointcompletionradius(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointdescription(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointforcebehaviour(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointformation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointhouseposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointloiteraltitude(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointloiterradius(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointloitertype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointname(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointscript(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointspeed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointstatements(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointtimeout(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointtype(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwaypointvisible(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setweaponreloadingtime(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setweaponzeroing(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwind(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwinddir(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwindforce(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwindstr(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwingforcescalertd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr setwppos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr show3dicons(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showchat(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showcinemaborder(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showcommandingmenu(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showcompass(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showcuratorcompass(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showgps(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showhud(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showlegend(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showmap(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownartillerycomputer();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownchat();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showncompass();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showncuratorcompass();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showneweditorobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showngps();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownhud();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownmap();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownpad();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownradio();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownscoretable();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownsubtitles();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownuavfeed();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownwarrant();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr shownwatch();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showpad(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showradio(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showscoretable(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showsubtitles(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showuavfeed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showwarrant(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showwatch(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showwaypoint(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr showwaypoints(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr side(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sideambientlife();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sidechat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sideempty();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sideenemy();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sidefriendly();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sidelogic();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sideradio(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sideunknown();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr simpletasks(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr simulationenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr simulclouddensity(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr simulcloudocclusion(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr simulinclouds(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr simulweathersync();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sin(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr size(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sizeOf(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr skill(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr skillfinal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr skiptime(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sleep(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sliderposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sliderrange(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr slidersetposition(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr slidersetrange(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr slidersetspeed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sliderspeed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr slingloadassistantshown();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr soldiermagazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr someammo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sort(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr soundvolume();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr spawn(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr speaker(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr speechvolume();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr speed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr speedmode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr splitstring(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sqrt(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr squadparams(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr stance(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr startloadingscreen(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr step(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr stop(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr stopenginertd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr stopped(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr str(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr sunormoon();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr supportinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr suppressfor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr surfaceiswater(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr surfacenormal(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr surfacetexture(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr surfacetype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr swimindepth(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr switchableunits();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr switchaction(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr switchcamera(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr switchgesture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr switchlight(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr switchmove(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr synchronizedobjects(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr synchronizedtriggers(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr synchronizedwaypoints(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr synchronizeobjectsadd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr synchronizeobjectsremove(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr synchronizetrigger(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr synchronizewaypoint(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr systemchat(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr systemofunits();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr systemtime();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr systemtimeutc();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tan(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr targetknowledge(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr targets(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr targetsaggregate(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr targetsquery(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskalwaysvisible(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskchildren(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskcompleted(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskcustomdata(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskdescription(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskdestination(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskhint(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskmarkeroffset(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tasknull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskparent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskresult(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr taskstate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tasktype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr teammember(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr teammembernull();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr teamname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr teams();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr teamswitch();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr teamswitchenabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr teamtype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr terminate(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr terrainintersect(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr terrainintersectasl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr terrainintersectatasl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr text(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr textlog(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr textlogformat(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tg(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr timemultiplier();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr titlecut(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr titlefadeout(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr titleobj(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr titlersc(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr titletext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr to(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr toarray(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tofixed(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tolower(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr toloweransi(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tostring(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr toupper(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr toupperansi(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggeractivated(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggeractivation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggerammo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggerarea(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggerattachedvehicle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggerattachobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggerattachvehicle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggerdynamicsimulation(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggerinterval(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggerstatements(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggertext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggertimeout(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggertimeoutcurrent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr triggertype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr trim(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr turretlocal(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr turretowner(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr turretunit(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvadd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvclear(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvcollapse(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvcollapseall(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvcount(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvcursel(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvdelete(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvexpand(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvexpandall(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvisselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvpicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvpictureright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvselection(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetcursel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetdata(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetpicture(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetpicturecolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetpicturecolordisabled(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetpicturecolorselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetpictureright(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetpicturerightcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetpicturerightcolordisabled(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetpicturerightcolorselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetselectcolor(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetselected(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsettext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsettooltip(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsetvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsort(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsortall(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsortbyvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvsortbyvalueall(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvtext(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvtooltip(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr tvvalue(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr type(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr typename(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr typeOf(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr uavcontrol(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr uinamespace();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr uisleep(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unassigncurator(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unassignitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unassignteam(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unassignvehicle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr underwater(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr uniform(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr uniformcontainer(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr uniformitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr uniformmagazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr uniqueunititems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitaddons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitaimposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitaimpositionvisual(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitbackpack(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitcombatmode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitisuav(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitpos(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitready(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitrecoilcoefficient(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr units(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitsbelowheight(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unitturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unlinkitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unlockachievement(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr unregistertask(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr updatedrawicon(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr updatemenuitem(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr updateobjecttree(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr useaiopermapobstructiontest(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr useaisteeringcomponent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr useaudiotimeformoves(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr userinputdisabled();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr values(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectoradd(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectorcos(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectorcrossproduct(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectordiff(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectordir(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectordirvisual(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectordistance(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectordistancesqr(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectordotproduct(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectorfromto(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectorlinearconversion(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectormagnitude(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectormagnitudesqr(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectormodeltoworld(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectormodeltoworldvisual(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectormultiply(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectornormalized(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectorup(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectorupvisual(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectorworldtomodel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vectorworldtomodelvisual(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehicle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehiclecargoenabled(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehiclechat(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehiclemoveinfo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehicleradio(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehiclereceiveremotetargets(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehiclereportownposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehiclereportremotetargets(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehicles();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vehiclevarname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr velocity(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr velocitymodelspace(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr verifysignature(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vest(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vestcontainer(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vestitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr vestmagazines(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr viewdistance();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr visiblecompass();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr visiblegps();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr visiblemap();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr visibleposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr visiblepositionasl(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr visiblescoretable();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr visiblewatch();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waituntil(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waves();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointattachedobject(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointattachedvehicle(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointattachobject(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointattachvehicle(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointbehaviour(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointcombatmode(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointcompletionradius(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointdescription(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointforcebehaviour(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointformation(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointhouseposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointloiteraltitude(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointloiterradius(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointloitertype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointname(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointposition(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypoints(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointscript(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointsenableduav(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointshow(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointspeed(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointstatements(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointtimeout(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointtimeoutcurrent(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointtype(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr waypointvisible(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponaccessories(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponaccessoriescargo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponcargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weapondirection(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponinertia(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponlowered(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponreloadingtime(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weapons(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponsinfo(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponsitems(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponsitemscargo(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponstate(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weaponsturret(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr weightrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr west();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr wfsidetext(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr wind();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr winddir();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr windrtd();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr windstr();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr wingsforcesrtd(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr with(IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr worldname();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr worldsize();

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr worldtomodel(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr worldtomodelvisual(IntPtr leftGameValue, IntPtr rightGameValue);

        [SuppressUnmanagedCodeSecurity, DllImport("rvcss_x64")]
        private static extern IntPtr worldtoscreen(IntPtr rightGameValue);





        private readonly IntPtr _internalGameValue;
        public GameValue()
        {
            _internalGameValue = CreateGameValue();
        }

        public GameValue(float value)
        {
            _internalGameValue = CreateGameValueFloat(value);
        }

        public GameValue(int value)
        {
            _internalGameValue = CreateGameValueInt(value);
        }

        public GameValue(bool value)
        {
            _internalGameValue = CreateGameValueBool(value);
        }

        public GameValue(string value)
        {
            _internalGameValue = CreateGameValueString(value);
        }

        public GameValue(GameValue array, int length)
        {
            _internalGameValue = CreateGameValueArray(array._internalGameValue, length);
        }

        public GameValue(List<int> list)
        {
            _internalGameValue = CreateGameValueArrayEmpty();
            for (int i = 0; i < list.Count; i++)
            {
                var temp = new GameValue(list[i]);
                pushback(_internalGameValue, temp._internalGameValue);
            }
        }

        private GameValue(IntPtr array, int length)
        {
            _internalGameValue = CreateGameValueArray(array, length);
        }

        private GameValue(Vector2 value)
        {
            _internalGameValue = CreateGameValueVector2(value);
        }

        private GameValue(Vector3 value)
        {
            _internalGameValue = CreateGameValueVector3(value);
        }

        private GameValue(IntPtr gamePointer)
        {
            _internalGameValue = gamePointer;
        }

        ~GameValue()
        {
            DeleteGameValue(_internalGameValue);
        }

        /// <summary>
        /// Method <c>GetString</c> returns a c# type from an GameValue instance from the RV engine
        /// </summary>
        public static String GetString(GameValue instance)
        {
            var pointer = GetDataString(instance._internalGameValue);
            String? message = String.Empty;
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                message = Marshal.PtrToStringUni(pointer);
            }
            else
            {
                message = Marshal.PtrToStringUTF8(pointer);
            }

            if (message != null)
            {
                return message;
            }
            else
            {
                return String.Empty;
            }

        }

        public static float GetFloat(GameValue instance)
        {
            return GetDataFloat(instance._internalGameValue);
        }

        public static int GetInt(GameValue instance)
        {
            return GetDataInt(instance._internalGameValue);
        }

        public static bool GetBool(GameValue instance)
        {
            return GetDataBool(instance._internalGameValue);
        }

        public static Vector2 GetVector2(GameValue instance)
        {
            return Marshal.PtrToStructure<Vector2>(GetDataVector2(instance._internalGameValue));
        }

        public static Vector3 GetVector3(GameValue instance)
        {
            return Marshal.PtrToStructure<Vector3>(GetDataVector3(instance._internalGameValue));
        }

        //static methods

        /// <summary>
        /// Returns the current simulation acceleration factor.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue AccTime()
        {
            return new GameValue(acctime());
        }

        /// <summary>
        /// Make a unit perform an action. See Actions for action names and syntaxes. in singleplayer, when user Alt-Tabs the simulation is paused and so the action will also halt until user returns to the game. For example, player action ["GetInDriver", car]; executed while user is Alt-Tabbed will result in the user seeing the action happening when he returns to the game screen. This doesn't happen in Multiplayer. the alternative syntax creates a temporary Logic entity in place of unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Action(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(action(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Array of Numbers, where numbers are IDs of all user actions added to given entity with addAction command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ActionIDs(GameValue rightInstance)
        {
            return new GameValue(actionids(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Array containing dikCodes of keys, buttons and combos assigned to the given user action. Action names could be found in config class ControllerSchemes or user action names or user profile, for example: keyWatch[] = { 24 }; To retrieve the value, use the property name without 'key': actionKeys "Watch"; // 24 In addition, some of the actions are also listed in here: inputAction/actions
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ActionKeys(GameValue rightInstance)
        {
            return new GameValue(actionkeys(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gives a broken down version of actionKeys return. Returns an Array containing the breakdowns of the dikCodes of keys, buttons and combos assigned to the given user action. Action names can be found in config class ControllerSchemes or user action names or user profile (see Example 1). In addition, some of the actions are also listed here: inputAction/actions The Key Device can be one of several types: "KEYBOARD" "MOUSE_BUTTON" "MOUSE_AXIS" "JOYSTICK_BUTTON" "JOYSTICK_AXIS" "JOYSTICK_POV" "XINPUT" - (Xbox) Controller Input "TRACKER" - Motion Tracking (TrackIR, Tobii etc)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ActionKeysEx(GameValue rightInstance)
        {
            return new GameValue(actionkeysex(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of button images or names assigned to the given user action. A maximum of maxKeys keys is listed. You can find the action names in config class ControllerSchemes or user action names.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue text</returns>
        public static GameValue ActionKeysImages(GameValue rightInstance)
        {
            return new GameValue(actionkeysimages(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of button names assigned to the given user action. Action names can be found in config class ControllerSchemes or user action names.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ActionKeysNames(GameValue rightInstance)
        {
            return new GameValue(actionkeysnames(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of button names assigned to the given user action. You can find the action names in config class ControllerSchemes or user action names.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ActionKeysNamesArray(GameValue rightInstance)
        {
            return new GameValue(actionkeysnamesarray(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns localized name of action.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ActionName(GameValue rightInstance)
        {
            return new GameValue(actionname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Array with params for given user action id (similar to addAction param array).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ActionParams(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(actionparams(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Activates the listed addons.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ActivateAddons(GameValue rightInstance)
        {
            return new GameValue(activateaddons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of all activated addons.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue ActivatedAddons()
        {
            return new GameValue(activatedaddons());
        }

        /// <summary>
        /// Activates the given keyname for the current user profile. The keys are used to unlock missions or campaigns. See keys, keysLimit and doneKeys in the Description.ext#Mission Keys chapter.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ActivateKey(GameValue rightInstance)
        {
            return new GameValue(activatekey(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns type, effect, speed and map visibility of the given active title effect (see allActiveTitleEffects)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ActiveTitleEffectParams(GameValue rightInstance)
        {
            return new GameValue(activetitleeffectparams(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Connect entities together.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Add3DENConnection(GameValue rightInstance)
        {
            return new GameValue(add3denconnection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds an Eden Editor Event Handler.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Add3DENEventHandler(GameValue rightInstance)
        {
            return new GameValue(add3deneventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds an editing layer in Eden Editor.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Add3DENLayer(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(add3denlayer(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds an entry to the action menu of an object. The action can only be activated when in proximity to the object and looking at it. Adding an action to the player makes that action available to the player at all times. For event handling of user interaction see inGameUISetEventHandler.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing_scalar</returns>
        public static GameValue AddAction(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addaction(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a backpack for a unit. If a unit already has a backpack, the old backpack will be placed on the ground under the unit. Items defined in the backpack's config will be added as well. Classname list of available backpacks: Arma 2 OA backpacks Arma 3 backpacks - objects starting with "B_", starts with "B_AssaultPack_khk"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddBackpack(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addbackpack(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add backpack(s) to the cargo space of vehicle. Classname list of available backpacks is here. For a list of possible backpacks, see: 1.50 Arma 2: Operation Arrowhead: Backpacks 1.00 Arma 3: CfgVehicles Equipment (starting with B_) In Arma 3, arguments for this command are local LALocal. For the global variant, see addBackpackCargoGlobal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddBackpackCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addbackpackcargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add backpack(s) to the cargo space of vehicle. Classname list of available backpacks: Arma 2 OA backpacks Arma 3 backpacks - objects starting with "B_", starts with "B_AssaultPack_khk"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddBackpackCargoGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addbackpackcargoglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a backpack to a unit (even non-local).⚠Beware, the backpack added with this command will be created on the PC local to the unit you are adding it to, even if executed on the server. Because of this, if non-local unit is the target and one tries to immediately access added backpack, the backpack returned will be  Null. When adding backpack dynamically to a remote unit, wait until backpack is added (See Example 2)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddBackpackGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addbackpackglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds weapon item, including magazine, directly to the binocular weapon. This is used for infantry weapons.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddBinocularItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addbinocularitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates the camera shaking effect, like when you are near an explosion
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddCamShake(GameValue rightInstance)
        {
            return new GameValue(addcamshake(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Allow curator use of given addon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddCuratorAddons(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addcuratoraddons(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds or changes curator camera area (depends on if ID is already used).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddCuratorCameraArea(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addcuratorcameraarea(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Register objects which can be edited by a curator.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddCuratorEditableObjects(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addcuratoreditableobjects(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds or changes curator edit area (depends on if ID is already used).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddCuratorEditingArea(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addcuratoreditingarea(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds or removes curator points. Points can be only in range from 0 to 1.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddCuratorPoints(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addcuratorpoints(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add an object to the editor and assign arguments. Create script is,called with _new equal to true. Returns the ID of the new EditorObject.,Subtype class is optional.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue AddEditorObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addeditorobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds an Event Handler to the given object. As many Event Handlers of any type can be added - existing Event Handlers do not get overwritten Use removeEventHandler to remove an Event Handler Read Event Handlers for more information and a list of all available Event Handlers.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing_scalar</returns>
        public static GameValue AddEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Applies impulse force to unit or given PhysX object at given position. For more information see NVIDIA docs.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddForce(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addforce(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds force generator to world. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AddForceGeneratorRTD(GameValue rightInstance)
        {
            return new GameValue(addforcegeneratorrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a new item and try to link it into goggles (glasses) slot. This command does not add NVGs, which are hmd slot items (see linkItem instead).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddGoggles(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addgoggles(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds icon to a group leader. Returns icon ID, Control icons visibility with setGroupIconsVisible.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AddGroupIcon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addgroupicon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds weapon item, including magazine, directly to the handgunWeapon. This is used for infantry weapons.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddHandgunItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addhandgunitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a headgear item and tries to link it to headgear slot. If slot is occupied with another item, the item in the slot will be replaced.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddHeadgear(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addheadgear(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates new item and tries to add it into inventory. Inventory must have enough space to accomodate new item or command will fail.The item can also be a weapon or a magazine.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(additem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates new items and stores them in given container. Works with items, weapons, magazines, equipment and glasses but not backpacks. In the latter case use addBackpackCargo instead. For the global variant, see addItemCargoGlobal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddItemCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(additemcargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Global variant of addItemCargo.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddItemCargoGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(additemcargoglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds count items of type name into the weapon pool (used in the campaign to transfer items to the next mission)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddItemPool(GameValue rightInstance)
        {
            return new GameValue(additempool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create new item and store it to soldier's backpack. The item can also be a weapon or a magazine.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddItemToBackpack(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(additemtobackpack(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create new item and store it to soldier's uniform. The item can also be a weapon or a magazine.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddItemToUniform(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(additemtouniform(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create new item and store it to soldier's vest. The item can also be a weapon or a magazine.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddItemToVest(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(additemtovest(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds score to the Xbox Live Statistics score for the given unit (or the commander unit of the given vehicle).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddLiveStats(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addlivestats(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a magazine to a person. Infantry units can only carry a specific number of magazines, once the magazine slots are filled (or uniform/vest/bagpack are full in Arma 3), any further addMagazine commands are ignored. If class of magazine does not exist, an error message is printed in .rpt: player addMagazine "dasdsa"; // .rpt: Given magazine[dasdsa] not found) Use addMagazine before addWeapon for the weapon to be loaded with magazine automatically.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddMagazine(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmagazine(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds magazines with specified ammo count to the cargo space of a vehicle or a container.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddMagazineAmmoCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmagazineammocargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add magazines to the cargo space of vehicles, which can be taken out by infantry units. Once the magazine cargo space is filled up, any further addMagazineCargo commands are ignored. In Arma 3, arguments for this command must be local (LALocal). For the global variant see addMagazineCargoGlobal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddMagazineCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmagazinecargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add magazines to the cargo space of vehicles, which can be taken out by infantry units. MP Synchronized
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddMagazineCargoGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmagazinecargoglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds magazine to a unit regardless of locality. This command can also be used to add magazine to a vehicle, like a static gun, for example.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddMagazineGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmagazineglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds magazines to the magazine pool, of which the player may choose in the following mission. Available in campaigns only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddMagazinePool(GameValue rightInstance)
        {
            return new GameValue(addmagazinepool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds multiple magazines to the unit. For cargo containers use addMagazineCargoGlobal command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddMagazines(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmagazines(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a magazine to the turret. Use turret path [-1] for driver's turret. ⚠You may create invalid combinations by using this function, for example by adding 20 grenades. When doing so, application behaviour is undefined.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddMagazineTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmagazineturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a new menu button. Priority is optional. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AddMenu(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmenu(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a new menu item. Menu can be "file" or "view",index is index,as returned from addMenu command. priority is optional and determines,where in the menu the item will reside (higher priority items first).  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AddMenuItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmenuitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds event handler attached to the current mission and returns event handler handle. For the list of available mission event handlers see: Arma 3: Mission Event Handlers
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AddMissionEventHandler(GameValue rightInstance)
        {
            return new GameValue(addmissioneventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a multiplayer event handler (EH) to the given object and returns EH handle. See Event Handlers. ⚠A Multiplayer Event Handler is not saved in a save file and therefore will not be restored on load - use it accordingly.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing_scalar</returns>
        public static GameValue AddMPEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addmpeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds playMusic event handler. Returns id of the handler or -1 when failed. Like addMissionEventHandler, the music event handler is attached to the mission. See Arma 3: Event Handlers - Music Event Handlers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AddMusicEventHandler(GameValue rightInstance)
        {
            return new GameValue(addmusiceventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of files present in the addon. Querying protected .ebo addons will return an empty array [].
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AddonFiles(GameValue rightInstance)
        {
            return new GameValue(addonfiles(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets ownership over a remotely detonatable mine to the unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddOwnedMine(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addownedmine(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// MP server only: Adds player score.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddPlayerScores(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addplayerscores(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds weapon item, including magazine, directly to the primaryWeapon. This is used for infantry weapons.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddPrimaryWeaponItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addprimaryweaponitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// This command is deprecated since the introduction of remoteExec and remoteExecCall. This event handler will detect if a missionNamespace variable (it is attached to) has been broadcast over network with publicVariable, publicVariableClient or publicVariableServer commands and will execute EH code upon detection. Arguments passed to the code in _this array are: _this select 0: String - broadcast variable name (same variable name EH is attached to) _this select 1: Anything - broadcast variable value _this select 2: Object, Group - target the variable got set on with setVariable  (see Alternative Syntax) This EH works only in Multiplayer environment There is no way to remove this EH This EH will not fire on the machine that executed broadcast with publicVariable command, only on the machines that receive the broadcast The value of broadcast variable can be exactly the same, it is the actual broadcast that triggers EH not the change in variable
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddPublicVariableEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addpublicvariableeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add a number to the rating of a unit - negative values can be used to reduce the rating. This command is usually used to reward for completed mission objectives. The rating is given at the end of the mission and is automatically adjusted when killing enemies or friendlies.  When the rating gets below -2000, the unit's side switches to "ENEMY" (sideEnemy) and the unit is attacked by everyone.(see Rating Values) See also: Arma 3: Event Handlers
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddRating(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addrating(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds resources to a team member.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddResources(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addresources(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a number to the score of a unit. Negative values will remove from the score.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddScore(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addscore(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds side score. This is shown in the MP score tab as the total score. MP only.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddScoreSide(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addscoreside(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds weapon item, including magazine, directly to the secondaryWeapon. This is used for infantry weapons.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddSecondaryWeaponItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addsecondaryweaponitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a unit to the list of units available for Team Switch. Units marked as playable in editor are automatically switchable. This command adds non-playable unit into array of switchableUnits and makes them available for teamSwitch. Singleplayer only!
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddSwitchableUnit(GameValue rightInstance)
        {
            return new GameValue(addswitchableunit(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add given member to given team. Effect is local, unless both member and team are local to PC on which command is executed, then effect is global.  The same Team Member can be member of several different teams at the same time.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddTeamMember(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addteammember(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds an array of vehicles/units to disposal manager for automatic wreck/body removal. The disposal manager follows wreck/body removal values set in description.ext
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddToRemainsCollector(GameValue rightInstance)
        {
            return new GameValue(addtoremainscollector(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Applies torque (rotation momentum) to the  center of mass of the given object. Torque force is defined as vector [x, y, z] applied in world space. If you need to define torque in model space, convert the torque vector first by vectorModelToWorld or vectorModelToWorldVisual command. The torque applied as impulse. Diagram below explain which way the object would rotate.  For more information see NVIDIA docs  A single application of torque would produce one impulse, which may not be enough. In this case consider applying a series of continuous impulses, for example to make a quad bike to roll forward: onEachFrame { quad addTorque (quad vectorModelToWorld [100,0,0]) }; ⚠This command doesn't follow convention for torque direction, which obeys right-hand rule. To comply, negate all values in the vector.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddTorque(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addtorque(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a new uniform and try to link it into uniform slot (given uniform has to be supported by allowedUniforms list of target soldier). To check if a uniform is allowed use isUniformAllowed, and to force an incompatible uniform use forceAddUniform.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddUniform(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(adduniform(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a user action event handler to the current mission and returns its event handler index.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AddUserActionEventHandler(GameValue rightInstance)
        {
            return new GameValue(adduseractioneventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a specified vehicle for use by a specified AI led group. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddVehicle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addvehicle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a new vest and try to link it into vest slot.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddVest(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addvest(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds (or inserts when index is given) a new waypoint to a group. The waypoint is placed randomly within a circle with the given center and radius. The function returns a waypoint with format [group, index]. Prior to Arma 3 v1.90, if you need exact waypoint placement, use setWaypointPosition
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AddWaypoint(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addwaypoint(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add a weapon to a unit. For a global version of this command see addWeaponGlobal. Infantry units can only carry a specific number of weapons, once the weapon slots are filled, any further addWeapon commands are ignored. a magazine must be added first for the added weapon to be loaded. ⚠In Arma 3 this command can also link items to the inventory slots, the functionality is identical to linkItem command, which it global and thus differ in how it should be used.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeapon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addweapon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add weapons to the cargo space of vehicles, which can be taken out by infantry units. Ignores available cargo space. In Arma 3, arguments for this command must be local (LALocal). For global variant see addWeaponCargoGlobal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeaponCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addweaponcargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add weapons to the cargo space of vehicles, which can be taken out by infantry units.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeaponCargoGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addweaponcargoglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add a weapon to a unit. Infantry units can only carry weapons in their respective slots (primary, secondary and handgun), the addWeaponGlobal command will replace the weapon currently in a slot with the added weapon if it shares the same slot. This command can link items to respective slots as well, in which case the functionality is identical to linkItem. To make sure the added weapon is loaded and ready, add the magazine first. ⚠This command is broken when used on dedicated server
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeaponGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addweaponglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a weapon item to the specified weapon. The item can be weapon magazine, in which case the amount of ammo and target muzzle could also be specified.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeaponItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addweaponitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add weapons to the weapon pool, of which the player may choose in the following mission. Available in campaigns only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeaponPool(GameValue rightInstance)
        {
            return new GameValue(addweaponpool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a weapon to the turret. Use turret path [-1] for driver's turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeaponTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addweaponturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a weapon into the cargo space of a vehicle / box with given attachments / magazines. Ignores available cargo space. If the weapon class has any pre-attached items (LinkedItems), they are removed and new items, supplied via command arguments, are added.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeaponWithAttachmentsCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addweaponwithattachmentscargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a weapon into the cargo space of a vehicle / box with given attachments / magazines. Ignores available cargo space. If the weapon class has any pre-attached items (LinkedItems), they are removed and new items, supplied via command arguments, are added.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AddWeaponWithAttachmentsCargoGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(addweaponwithattachmentscargoglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// This is dedicated server command, which queries the admin state of any client on the network by their client (owner) id. To self-check the admin state of a local client, use BIS_fnc_admin.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Admin(GameValue rightInstance)
        {
            return new GameValue(admin(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return a person for a given agent.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue Agent(GameValue rightInstance)
        {
            return new GameValue(agent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return a list of agents in the current mission.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Agents()
        {
            return new GameValue(agents());
        }

        /// <summary>
        /// Converts position from PositionAGL to PositionASL.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AGLToASL(GameValue rightInstance)
        {
            return new GameValue(agltoasl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns how good the weapon of the vehicle is aimed at the target.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AimedAtTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(aimedattarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the position of the object other units can aim to.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AimPos(GameValue rightInstance)
        {
            return new GameValue(aimpos(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with air density data.For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AirDensityCurveRTD()
        {
            return new GameValue(airdensitycurvertd());
        }

        /// <summary>
        /// Returns air density in given altitude. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AirDensityRTD(GameValue rightInstance)
        {
            return new GameValue(airdensityrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns throttle position. Works only on player's vehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AirplaneThrottle(GameValue rightInstance)
        {
            return new GameValue(airplanethrottle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the side of an airport, set by setAirportSide. Default side is sideUnknown. See Arma: Airport IDs for a list of airport ids.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue side</returns>
        public static GameValue AirportSide(GameValue rightInstance)
        {
            return new GameValue(airportside(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Alternative Injury Simulation (AIS) end state. Used to tell engine that script side healing is done when using "HandleHeal" event handler.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AISFinishHeal(GameValue rightInstance)
        {
            return new GameValue(aisfinishheal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if given vehicle/person/building is alive (i.e. not dead or destroyed).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Alive(GameValue rightInstance)
        {
            return new GameValue(alive(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of all currently placed Eden Editor entities. This information is only available in Eden Editor. If used during mission, it will return [[],[],[],[],[],[],[],[-999]].
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue All3DENEntities()
        {
            return new GameValue(all3denentities());
        }

        /// <summary>
        /// Returns a list of all layers that have currently active title effect. Numbers equal to or greater than 0 represent cut layers, where as -1 represents title layer (see Title Effect Type). Named layers are represented by their respective index.Effects created with titleText, titleRsc and titleObj commands do not have a numbered layer, so they are represented as -1 layer in the result. Effects created with cutText, cutRsc and cutObj are created either on layer 0, if no layer is specified, or on the given layer, if the layer index is specified, so they are represented by the layer index.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllActiveTitleEffects()
        {
            return new GameValue(allactivetitleeffects());
        }

        /// <summary>
        /// Returns the list of all loaded addons.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllAddonsInfo()
        {
            return new GameValue(alladdonsinfo());
        }

        /// <summary>
        /// Returns all map airports, both static and dynamic.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllAirports()
        {
            return new GameValue(allairports());
        }

        /// <summary>
        /// Returns a list of all controls for desired existing display. Returned controls also include controls from CT_CONTROLS_GROUPs.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllControls(GameValue rightInstance)
        {
            return new GameValue(allcontrols(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns list of all curator logic units, not the units assigned to the logic.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllCurators()
        {
            return new GameValue(allcurators());
        }

        /// <summary>
        /// Returns all named layers used by cutRsc, cutText, cutObj or cutFadeOut. The layer normally would be added on the first use of any of the aforementioned commands, however if a layer needs to be reserved it could be done like so: private _layerNum = "TAG_myLayerName" cutFadeOut 0;
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllCutLayers()
        {
            return new GameValue(allcutlayers());
        }

        /// <summary>
        /// Return a list of all dead units including agents and destroyed vehicles. Dead units may be in vehicles.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllDead()
        {
            return new GameValue(alldead());
        }

        /// <summary>
        /// Return a list of dead units including agents. Dead unit might be inside vehicle.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllDeadMen()
        {
            return new GameValue(alldeadmen());
        }

        /// <summary>
        /// Returns array with all Diary Records for the given subject available to the given person. See Diary for the explanation on the available subjects and their structure.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllDiaryRecords(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(alldiaryrecords(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all Diary subjects available to the given person. See Diary for the explanation on the available subjects and their structure.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllDiarySubjects(GameValue rightInstance)
        {
            return new GameValue(alldiarysubjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of all opened GUI displays. Other displays could be accessed via uiNamespace variable which is updated every time a display is opened or closed. For example, to access IGUI displays: private _iguiDisplays = uiNamespace getVariable ["IGUI_displays", []]; Other display variables: "3DENDisplaysTemp_displays" "3DENDisplays_displays" "BootcampDisplays_displays" "BootcampTitles_displays" "CuratorDisplays_displays" "CuratorTitles_displays" "GUI_displays" "IGUI_displays" "KartDisplays_displays" "Loading_displays"
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllDisplays()
        {
            return new GameValue(alldisplays());
        }

        /// <summary>
        /// Returns all environmental 3D sound sources (Objects) like trees and houses in camera vicinity.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllEnv3DSoundSources()
        {
            return new GameValue(allenv3dsoundsources());
        }

        /// <summary>
        /// Return a list of all groups created on the following sides east, west, resistance/independent and civilian only. Does not contain groups of sideLogic.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllGroups()
        {
            return new GameValue(allgroups());
        }

        /// <summary>
        /// Returns the list of object or model LODs.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllLODs(GameValue rightInstance)
        {
            return new GameValue(alllods(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all markers in map including user placed markers (_USER_DEFINED #).  Since Arma 3 v1.58 User defined markers have the following name format: _USER_DEFINED #<PlayerID>/<MarkerID>/<ChannelID> where: <PlayerID> - unique network id of the player in String format, also available as String in the 6th param in  "PlayerConnected" and "PlayerDisconnected" EHs <MarkerID> - a marker counter id <ChannelID> - id of the chat channel on which marker was placed (see currentChannel) For custom waypoint position (LShift+LMB) see customWaypointPosition
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllMapMarkers()
        {
            return new GameValue(allmapmarkers());
        }

        /// <summary>
        /// Returns an array of all mines in the mission
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllMines()
        {
            return new GameValue(allmines());
        }

        /// <summary>
        /// Returns all objects of the given type that are currently present in the mission. In some cases, the entities command is a much faster alternative to this command. Some of the special types that can be detected with this command (and with nearestObject): "" - returns everything, e.g. agents, bees, mosquitoes, footprints, armed mines, ... "all" - more restrictive than "": no ambient insects, only agents such as rabbits and snakes, no footprints, tracks, no armed mines "#slop" - blood drops "#mark" - unit footprints "#track" - vehicle tracks "#crater" - explosion craters on the ground "#crateronvehicle" - bullet marks on vehicles "#explosion" - explosions "#objectdestructed" - building, tree or bush destruction "#soundonvehicle" - sounds created with say3D for example "#dynamicsound" - sound sources created using createSoundSource "EmptyDetector" - all Triggers "Logic" - all game logics ⚠This command is quite performance heavy. Use with caution!
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllMissionObjects(GameValue rightInstance)
        {
            return new GameValue(allmissionobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of requested objects as fast as the engine allows it. The objects can be requested by object type and simulation kind. Some terrain placed objects are not part of slow vehicles collection, use nearestTerrainObjects command to return these objects
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllObjects(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allobjects(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Allow/dissallow 3D mode.,  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Allow3DMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allow3dmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// If true, units will remain in a vehicle with broken tracks/wheels; they will still eject if the vehicle is drowning, about to explode or upside down for a while. The alternative syntax provides the ability to keep the crew in vehicle when it is upside down.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowCrewInImmobile(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowcrewinimmobile(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Allows curator placing and working with modules outside of edit areas.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowCuratorLogicIgnoreAreas(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowcuratorlogicignoreareas(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables / disables an entity's ability to receive damage. This command does not prevent the entity from taking scripted damage from commands such as setDamage, setHit, setHitIndex or setHitPointDamage. This command only supports entities (Entity is a child class of Object, i.e. all entities are objects, but not all objects are entities). Consequently, there are objects that are not affected by this command, for example terrain vegetation such as trees.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowDamage(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowdamage(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Allow or prevent an object being damaged (or injured, or killed). The command does not prevent object from taking scripted damage such as setDamage or setHit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowDammage(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowdammage(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns which types of repair/refuel/rearm service are allowed. The two available types are manual, where the action is displayed to the user, and auto, where the service happens within distance. The engine default is both (manual and auto) for historic reasons.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AllowedService(GameValue rightInstance)
        {
            return new GameValue(allowedservice(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Allow/dissallow file ops (load/save etc). Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowFileOperations(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowfileoperations(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the cowardice level (the lack of courage or bravery) of a group or unit.  Notes: Fleeing only affects AI led groups. Only the group as a whole can flee (or not). The courage of the AI group is based on the group's leader courage subskill. Each group has a max strength (summed "armor" of all infantry units - plus armor when inside vehicles). If the group losses by injury/damage or death/destruction are higher than the max strength, multiplied by leader's courage or allowFleeing level , then the group will start fleeing. As result primarily the AI flees to a nearby "supply point" (some friendly units - preferably with medic or engineer, or a vehicle with repair/ammo/fuel cargo). Alternatively it will try to find a safe position within a 600m radius from the initial waypoint (danger, distance, amount of cover positions are taken into account). After the fleeing has been finished the group's initial strength is reset. Fleeing units in combatMode red, will be set to yellow when fleeing to avoid engaging enemies while doing so. While fleeing, the group leader will be set to green, to avoid giving engage or fire orders, unless in combatMode blue already. Also speedMode is set to full. When reaching their flee point/destination, they will change to combatMode yellow and speedMode normal. With allowFleeing one can make unit's flee earlier (or essentially never flee). Apply it, overrides the courage subskill influence.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowFleeing(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowfleeing(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set if the units given in the list are allowed to enter vehicles. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowGetIn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowgetin(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets which type of repair/refuel/rearm service is allowed. The two available types are manual, where the action is displayed to the user, and auto, where the service happens within distance. The engine default is both (manual and auto) for historic reasons.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowService(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowservice(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Force player to run/jog if set to false.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AllowSprint(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(allowsprint(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of all units controlled by connected clients. This includes: Normal human players (including dead players) Virtual Entities (see Systems → Logic Entities → Virtual Entities in the Eden Editor) Headless Clients (HeadlessClient_F) Virtual Curators (VirtualCurator_F, *_VirtualCurator_F) Virtual Spectators (VirtualSpectator_F) Use BIS_fnc_listPlayers or see Example 1 to only get human players.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllPlayers()
        {
            return new GameValue(allplayers());
        }

        /// <summary>
        /// Returns array of all simple objects that belong to the listed class names. If the array of types is empty [], all simple objects are returned including those without class name. There is no inheritance in simple objects, so only exact class match is allowed. className is not case sensitive.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllSimpleObjects(GameValue rightInstance)
        {
            return new GameValue(allsimpleobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return all sites in map. ⚠This command is considered deprecated and is no longer supported
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllSites()
        {
            return new GameValue(allsites());
        }

        /// <summary>
        /// Returns array of available turret paths from vehicle object. to look up turrets from config, use BIS_fnc_allTurrets to get config from turret path, use BIS_fnc_turretConfig
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllTurrets(GameValue rightInstance)
        {
            return new GameValue(allturrets(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of all units, except agents, dead units or units waiting for respawn, outside and inside vehicles that were created on the following sides east, west, independent and civilian. To get all units of given side, use units Side.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllUnits()
        {
            return new GameValue(allunits());
        }

        /// <summary>
        /// Return a list of all UAV vehicles.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllUnitsUAV()
        {
            return new GameValue(allunitsuav());
        }

        /// <summary>
        /// Returns a list of player ids of all the users on an MP server. This also lists Headless Clients.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AllUsers()
        {
            return new GameValue(allusers());
        }

        /// <summary>
        /// Returns a list of all variables from the desired namespace.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AllVariables(GameValue rightInstance)
        {
            return new GameValue(allvariables(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns ambient temperature on the current terrain in Celsius in format: [airTemperature, blackSurfaceTemperature, whiteSurfaceTemperature]
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue AmbientTemperature()
        {
            return new GameValue(ambienttemperature());
        }

        /// <summary>
        /// Check how many rounds are left in the currently loaded magazine in the given muzzle. Since Arma v1.56 the command also returns ammo for units in vehicles.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Ammo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ammo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns ammo count on given pylon (or false on failure).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AmmoOnPylon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ammoonpylon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true only if both conditions are true. In case of the alternative syntax, lazy evaluation is used - if left operand is false, evaluation of the right side is ignored.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue And(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(and(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Activates given object animation. Animation is defined in CfgModels animations class. Class names listed in CfgVehicles AnimationSources bound to "Proxy" controller can also be animated with animate command (see Arma 3: createVehicle/vehicles). It is recommended that animateSource command is used instead of animate whenever is possible, as it is more efficient and optimised for multiplayer Since Arma 3 v1.58 animation names can be obtained with animationNames ⚠Mixing animateSource command with animate command to animate the same part may produce some undefined behaviour.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Animate(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(animate(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces animation of bay to given state, -1 for reset to engine handling, can cause weapon inoperative, because weapon is released when bay state == 1. While there is no getter to read the animation phase of the given bay, animationPhase command can be used with the individual bay door name from animationNames as a workaround. For example, for the UCAV Sentinel: ucav animateBay [1, 1]; // can be checked with ucav animationPhase "weapons_bay_l_1" // or ucav animationPhase "weapons_bay_l_2"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AnimateBay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(animatebay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Animates a door on a vehicle. Animation is defined in config file in CfgVehicles ->  AnimationSources. Wanted animation phase is set with phase param. This command works only on animation sources with "door" controller. Door_L in the example below can be animated with animateDoor but not CargoRamp_Open: heli animateDoor ["Door_L", 1];⚠animateDoor phase param will be rounded: anything >0.5 will be rounded to 1 and <=0.5 will be rounded to 0. Therefore it is not possible to open a door half way with this command  class AnimationSources { 	class CargoRamp_Open 	{ 		source = "user"; 		animPeriod = 5; 		initPhase = 0; 	}; 	class Door_L 	{ 		source = "door"; 		animPeriod = 1.6; 	}; }; To animate doors or other sources that have "user" controller, use animate command, or even better, animateSource (recommended). Sources with "hit" controller can be animated with setHitPointDamage command applied to the name contained in hitpoint property. For availability of animation sources and their controller types see: Arma 3: createVehicle/vehicles
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AnimateDoor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(animatedoor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Force animation of pylon to given state, -1 for reset to engine handling, can cause weapon inoperative, because weapon is released  when pylon state == 1.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AnimatePylon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(animatepylon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Process an animation of the object. If animate uses class name from CfgModels Animations, animateSource uses name defined by the source property. AnimationSources can animate multiple animate Animations. AnimationSource is defined in CfgVehicles' AnimationSources (see Arma 3: createVehicle/vehicles). It is recommended that animateSource command is used instead of animate whenever is possible, as it is more efficient and optimized for MP ⚠Mixing animateSource command with animate command to animate the same part may produce some undefined behaviour.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AnimateSource(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(animatesource(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Array of Strings where elements are the names of model animations, which should theoretically be available for use with animate command. However in practice this depends on whether animation is also made available for use in scripts via config.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AnimationNames(GameValue rightInstance)
        {
            return new GameValue(animationnames(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the phase of the given animation on the given object. Animation can be scripted (animate, animateSource, animateDoor) or engine driven. Animation names for an object could be found out with animationNames command. When animation is rotation, like with "MainTurret" for example, the output is in radians, to convert to degrees use deg command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AnimationPhase(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(animationphase(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current animation phase of given source. Similar to animationPhase or doorPhase but designed to complement animateSource. This command could be used to obtain relative turret direction and gun elevation on a vehicle (see Example 2).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue AnimationSourcePhase(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(animationsourcephase(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of a unit's current primary animation. Seems to be forced to lower case in Arma 3. This command is only for a man unit, other units such as animals cannot use this command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue AnimationState(GameValue rightInstance)
        {
            return new GameValue(animationstate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current aperture parameters.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue ApertureParams()
        {
            return new GameValue(apertureparams());
        }

        /// <summary>
        /// Appends array2 to the back of array1 modifying array1. See insert for an "appendUnique" equivalent. append does not return array, it modifies the existing array. If you need to return a copy, use "+": array3 = array1 + array2;
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Append(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(append(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Applies the given code to each element of the given data structure and collects the results in an array.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Apply(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(apply(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns, stored in [USERNAME].ArmaXProfile, value of armoryPoints entry. If the entry doesn't exist, it returns 0.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue ArmoryPoints()
        {
            return new GameValue(armorypoints());
        }

        /// <summary>
        /// Intersects two arrays returning an array of unique common elements, avoiding nil values. Using the same array as both parameters will return unique elements of that array. Intersects only the first dimension of said arrays. From Arma 3 v 2.14 the order of the intersected elements would follow 'array1' order
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ArrayIntersect(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(arrayintersect(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Arcsine of a number, result in Degrees.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Asin(GameValue rightInstance)
        {
            return new GameValue(asin(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts position from PositionASL to PositionAGL
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ASLToAGL(GameValue rightInstance)
        {
            return new GameValue(asltoagl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts a position from PositionASL to PositionATL
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ASLToATL(GameValue rightInstance)
        {
            return new GameValue(asltoatl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Tests a condition and if the condition is false, displays error on screen (if -showscripterrors enabled) and logs error into .rpt file. It does not interrupt the script execution. If script was pre-processed with preprocessFileLineNumbers, it will also show/log the error line number and the file name.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Assert(GameValue rightInstance)
        {
            return new GameValue(assert(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assign a unit as cargo of a vehicle. Used together with orderGetIn to order a unit to get in as cargo into a specific vehicle. Before usage of this command a subordinate unit has not got the option to get into the cargo space of the vehicle. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignAsCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assignascargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assigns the character to a specific cargo / passenger index of the given vehicle. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignAsCargoIndex(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assignascargoindex(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assign a unit as commander of a vehicle. Used together with orderGetIn to order subordinate units to get in as commander of a specific vehicle. Before usage of this command a subordinate unit has not got the option to get into the commander place of the vehicle. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignAsCommander(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assignascommander(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assign a unit as driver of a vehicle. Used together with orderGetIn to order subordinate units to get in as driver of a specific vehicle. Before usage of this command a subordinate unit has not got the option to get into the driver place of the vehicle. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignAsDriver(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assignasdriver(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assign a unit as gunner of a vehicle. Used together with orderGetIn to order subordinate units to get in as gunner of a specific vehicle. Before usage of this command a subordinate unit has not got the option to get into the gunner place of the vehicle. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignAsGunner(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assignasgunner(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assigns the soldier to turret. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignAsTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assignasturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assign player as curator. Two players cannot act as one curator.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignCurator(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assigncurator(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the list of soldiers assigned to the given vehicle as a cargo.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AssignedCargo(GameValue rightInstance)
        {
            return new GameValue(assignedcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the soldier assigned to the given vehicle as a commander.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue AssignedCommander(GameValue rightInstance)
        {
            return new GameValue(assignedcommander(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the soldier assigned to the given vehicle as a driver.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue AssignedDriver(GameValue rightInstance)
        {
            return new GameValue(assigneddriver(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Group to which the given vehicle was added last with addVehicle. To update assignedGroup to the current group, run addVehicle to the current group again.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue group</returns>
        public static GameValue AssignedGroup(GameValue rightInstance)
        {
            return new GameValue(assignedgroup(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the soldier assigned to the given vehicle as a gunner.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue AssignedGunner(GameValue rightInstance)
        {
            return new GameValue(assignedgunner(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with assigned items. The resulting Array order is not guaranteed. To check availability of a particular slot item use getSlotItemName. To return stored items see items and itemsWithMagazines.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AssignedItems(GameValue rightInstance)
        {
            return new GameValue(assigneditems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the target assigned to an unit or the vehicle's effectiveCommander. The target can be assigned by the group/vehicle/formation leader (as player via quick command menu or "target" complex command menu). To unassign the target use doWatch objNull or commandWatch objNull or as player and group leader order "no target" in the "target" complex command menu. This command does not return the target a unit is actually engaging ("attack unit"). For this information, see getAttackTarget. If a player is inside a vehicle as the effectiveCommander, the vehicle's crew assignedTarget will always be objNull.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue AssignedTarget(GameValue rightInstance)
        {
            return new GameValue(assignedtarget(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the team the unit belongs to. Possible values: "MAIN" (default and white) "RED" "GREEN" "BLUE" "YELLOW" 1.94 "" if given unit is objNull or remoteControlling another unit
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue AssignedTeam(GameValue rightInstance)
        {
            return new GameValue(assignedteam(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the vehicle to which a unit is assigned, usually with assignAsXXX command. If no vehicle is assigned objNull is returned. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue AssignedVehicle(GameValue rightInstance)
        {
            return new GameValue(assignedvehicle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the role a unit is assigned to within its assigned vehicle. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AssignedVehicleRole(GameValue rightInstance)
        {
            return new GameValue(assignedvehiclerole(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all vehicles added to the given Group with addVehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AssignedVehicles(GameValue rightInstance)
        {
            return new GameValue(assignedvehicles(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assigns existing item from inventory (uniform, vest, backpack) to a correct slot. If the slot is occupied by another item, it gets replaced. See also linkItem.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assignitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Team Value White "MAIN" Red "RED" Green "GREEN" Blue "BLUE" Yellow "YELLOW" Assigns the unit (in case of a vehicle, its commander) to the given team. Team is an option in group control (unit management) menu that allows to split player group in teams and then give bulk order to separate teams. In order to operate properly, the command requires specific conditions: the command requires player to be fully initialised the unit getting assigned must be either player himself or a unit in player's group The colour of the assigned team for a unit is seen on the group management UI as well as squad radar. ⚠In older versions of the game (Arma 2?) the effect of this command is local LELocal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignTeam(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assignteam(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assigns a plane to an airport ID or object.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AssignToAirport(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(assigntoairport(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the arcus tangens.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Atan(GameValue rightInstance)
        {
            return new GameValue(atan(rightInstance._internalGameValue));
        }

        /// <summary>
        ///  ArcTangent of y/x. Used to determine the angle of a vector [y,x]. Result in Degrees between -180 and 180. This command can handle x being 0, unlike when using atan, and will return 90 ⚠Even though this command is a binary operator just like select command, it has  higher precedence than select command, therefore the following expression: _pos select 0 atan2 (_pos select 1) will produce an error. The correct usage in this case will be: (_pos select 0) atan2 (_pos select 1) Alternatively, consider using the # operator: _pos#0 atan2 _pos#1
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Atan2(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(atan2(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the arcus tangens.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Atg(GameValue rightInstance)
        {
            return new GameValue(atg(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts a position from PositionATL to PositionASL
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ATLToASL(GameValue rightInstance)
        {
            return new GameValue(atltoasl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object a location is attached to. If the location is unattached, then objNull is returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue AttachedObject(GameValue rightInstance)
        {
            return new GameValue(attachedobject(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of objects attached to the given object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue AttachedObjects(GameValue rightInstance)
        {
            return new GameValue(attachedobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns object the given object is attached to or objNull if the given object is not attached to anything.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue AttachedTo(GameValue rightInstance)
        {
            return new GameValue(attachedto(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attaches a location to the specified object. To detach a location, attach it to objNull.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AttachObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(attachobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attaches an object to another object. The offset is applied to the object center unless a memory point is provided, in which case the offset will be applied to the memory point position. If no offset is specified, the current offset between the two objects will be used. All direction commands, such as setDir, setVectorDirAndUp, etc. for an attached object should be used relative to the reference object's direction (i.e. in model space), e.g _attachedObj setDir 0 will make it face the same direction as the reference object, 90 face to the right, 180 face to the back, etc. Attached triggers only follow the direction of the object to which they are attached, not pitch or roll.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue AttachTo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(attachto(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return whether a group's leader can issue attack commands to soldiers under his command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue AttackEnabled(GameValue rightInstance)
        {
            return new GameValue(attackenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Wakes up sleeping PhysX object or puts a PhysX object to sleep. In 2.10 this command can be used on corpses of type Man and has no effect on alive units. When unit gets killed it goes into ragdoll state for a short while, then the units get frozen and any simulation and collision is removed to save system resources. As a result, corpses do not react to their surrounding any more. Using this command will temporarily re-enable ragdoll state of a corpse to the same state it was when unit died. If this command is used in "enable/disable" sequence on a dead body, it gives the corpse a visible nudge (See example 3). This command won't have lasting effect on vehicles as vehicles are actively simulated, but it works rather well on smaller PhysX enabled objects.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Awake(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(awake(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a class of a backpack.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Backpack(GameValue rightInstance)
        {
            return new GameValue(backpack(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with backpacks from ammo box (or any general weapon holder container).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BackpackCargo(GameValue rightInstance)
        {
            return new GameValue(backpackcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a cargo container of a unit's backpack.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue BackpackContainer(GameValue rightInstance)
        {
            return new GameValue(backpackcontainer(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with all items (of any kind, even weapons) in backpack of the given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BackpackItems(GameValue rightInstance)
        {
            return new GameValue(backpackitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with all magazines from backpack of the given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BackpackMagazines(GameValue rightInstance)
        {
            return new GameValue(backpackmagazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns how much space is in backpack for given weapon or magazine
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BackpackSpaceFor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(backpackspacefor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the behaviour of the individual unit, this is why it only accepts Object as the argument. For Arma 3 behaviour explanation see Arma_3_AI_Behavior
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Behaviour(GameValue rightInstance)
        {
            return new GameValue(behaviour(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the value of "3D Performance" in OFP Preferences (flashpoint.cfg). This can be used to estimate the computer performance to adapt CPU and GPU demanding settings like view distance dynamically in missions.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Benchmark()
        {
            return new GameValue(benchmark());
        }

        /// <summary>
        /// Gets interpolated value based on Bézier curve with given control points (progress value is 0...1 for a curve that starts at pos0 and finishes at posN) 
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BezierInterpolation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(bezierinterpolation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns class name of currently used binocular weapon.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Binocular(GameValue rightInstance)
        {
            return new GameValue(binocular(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all items assigned to the binocular weapon except magazines. Use binocularMagazine command for the latter. This command is used for infantry weapons only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BinocularItems(GameValue rightInstance)
        {
            return new GameValue(binocularitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Collects all loaded magazines from all binocular muzzles and returns them in Array, otherwise it returns []. This command is used for infantry weapons only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue BinocularMagazine(GameValue rightInstance)
        {
            return new GameValue(binocularmagazine(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Pre-defined variable for the blufor side.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue Blufor()
        {
            return new GameValue(blufor());
        }

        /// <summary>
        ///  Returns a bounding box of given object in model coordinate space, adjusted according to destruction/animation of an object. This command is rather generous on the size estimation, for more precise coordinates use boundingBoxReal. In 1.92 The output of both syntaxes got extended to include bounding sphere diameter. See also sizeOf.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BoundingBox(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(boundingbox(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        ///  Returns a raw bounding box of given object in model coordinates space. This command is similar to boundingBox but gives more precise measurements. The alternative syntax allows to specify clipping type to be used, which in some cases could make the result even more precise.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BoundingBoxReal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(boundingboxreal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the position of the original (loaded) center of an object in model coordinates. Despite its name, it has nothing to do with boundingBox or boundingBoxReal, it returns offset where [0, 0, 0] was Object Builder / Oxygen 2 when model was created.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BoundingCenter(GameValue rightInstance)
        {
            return new GameValue(boundingcenter(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the status of autobrake (see disableBrakes).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue BrakesDisabled(GameValue rightInstance)
        {
            return new GameValue(brakesdisabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Breaks out of the scope with given name. An unknown scopeName name will cause the script error Generic error in expression If multiple scopes with the same name exist, the command will break out the nearest scope. See Example 3.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue BreakOut(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(breakout(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Breaks block to scope named name. Nil is returned. Scope name can be assigned using scopeName command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue BreakTo(GameValue rightInstance)
        {
            return new GameValue(breakto(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Skips all loop iterations and immediately returns the given value.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue BreakWith(GameValue rightInstance)
        {
            return new GameValue(breakwith(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of the current briefing/scenario name.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue BriefingName()
        {
            return new GameValue(briefingname());
        }

        /// <summary>
        /// Returns the given indexed exit in a building. The returned value is in format Position.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BuildingExit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(buildingexit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns position of a given indexed position in a building.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue BuildingPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(buildingpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables road diagnostics in buldozer.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Buldozer_EnableRoadDiag(GameValue rightInstance)
        {
            return new GameValue(buldozer_enableroaddiag(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if road diagnostics are enabled in buldozer.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue Buldozer_IsEnabledRoadDiag()
        {
            return new GameValue(buldozer_isenabledroaddiag());
        }

        /// <summary>
        /// Generates new roads. Working only in buldozer.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Buldozer_LoadNewRoads(GameValue rightInstance)
        {
            return new GameValue(buldozer_loadnewroads(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Reload oper map visible in costMap diag tool. Working only in buldozer.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue Buldozer_reloadOperMap()
        {
            return new GameValue(buldozer_reloadopermap());
        }

        /// <summary>
        /// Returns the action assigned to a control of the currently active user dialog. Can be used for buttons and active texts. Read Arma: GUI Configuration for more information about user dialogs and controls.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ButtonAction(GameValue rightInstance)
        {
            return new GameValue(buttonaction(rightInstance._internalGameValue));
        }

        /// <summary>
        /// 🕖The following information is obsolete. Reason: Use ctrlAddEventHandler instead. Set the action of a control of the currently active user dialog. The script statement is executed on button release and _this is available, but contains ""; See Arma: GUI Configuration for more information about user dialogs. Works with: CT_BUTTON CT_XBUTTON CT_ACTIVETEXT CT_SHORTCUTBUTTON
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ButtonSetAction(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(buttonsetaction(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prior to Arma 3 it returns if the player is currently playing in cadet or veteran mode.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue CadetMode()
        {
            return new GameValue(cadetmode());
        }

        /// <summary>
        /// Spawns an agent that will execute an AI path calculation and fire the "PathCalculated"  event handler. The vehicle type to simulate could be one of the following presets: "man" (will use "C_man_1") "car" (will use "C_Offroad_01_F") "tank" (will use "B_MBT_01_cannon_F") "wheeled_APC" (will use "B_APC_Tracked_01_rcws_F") "boat" (will use "C_Rubberboat") "plane" (will use "B_Plane_CAS_01_dynamicLoadout_F") "helicopter" (will use "B_Heli_Light_01_F") If the given vehicle type is not one of the above presets, the exact given type is used. ⚠In order to guarantee that the event handler is added to the result of this command before the path is calculated, use isNil to run the code in an Unscheduled Environment: isNil { calculatePath ["man", "safe", _startPos, _endPos] addEventHandler ["PathCalculated", { hint str _this }] }; If an exact path is desired, it is recommended to avoid this command and simply use the PathCalculated event handler. Paths to long distances are typically calculated in segments. This command only gives the first calculated segment.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CalculatePath(GameValue rightInstance)
        {
            return new GameValue(calculatepath(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets if friendly units will calculate player's visibility or not. Default value is false.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CalculatePlayerVisibilityByFriendly(GameValue rightInstance)
        {
            return new GameValue(calculateplayervisibilitybyfriendly(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds given set of compiled instructions to the current stack and waits for it to finish and return, provides an option to pass arguments to the executed Code. See Scheduler to learn more about how the code is executed and behaves.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue Call(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(call(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Calls custom .dll also known as Extension. The name of the extension is the name of the extension .dll without ".dll" part (or without "_x64.dll" part on 64-bit Arma). For example if the file is 'myExtension.dll' the name of the extension will be "myExtension". For 64-bit extensions, the name of the extension doesn't need to change and is still "myExtension". The game will automatically look for 'myExtension_x64.dll' when you use 64-bit Arma exe. This command is blocking, meaning that the game will wait for the extension to return before continuing. This may cause FPS drop if extension is not optimised. If extension takes too long, consider making asynchronous extension, where the result of the work of the extension is collected in a separate call. Currently there is no limit how much data you can send to the extension. However there is a limit on how much data you can return from extension in one call. The limit is known to the extension and is passed in  int outputSize. The limit may or may not change in the future and is currently 10240 bytes. It is up to extension designer to handle multipart results if returned data exceeds output limit. Since Arma 3 v1.67 it is possible to pass array of arguments to extensions. The array of arguments could be anything and all elements will be converted to strings, however you might want to only send simple types like Booleans, Strings, Numbers and Arrays of all of the above. There is currently a limit on how many arguments can be sent and it is 2048 (since Arma 3 v1.92; previous limit: 1024). However an argument could be an Array itself, in this case extension maker will have to provide additional methods for parsing such arguments. Possible error codes: 101: SYNTAX_ERROR_WRONG_PARAMS_SIZE 102: SYNTAX_ERROR_WRONG_PARAMS_TYPE 201: PARAMS_ERROR_TOO_MANY_ARGS 301: EXECUTION_WARNING_TAKES_TOO_LONG Each error will have entry in .rpt file with more details. The extension execution timeout, after which 301: EXECUTION_WARNING_TAKES_TOO_LONG warning is issued, is hardcoded on clients and is 1000.0 milliseconds (1 second). On the server the default limit is also 1 second, however it is possible to set custom limit with callExtReportLimit param (see  Server Options). If an extension with the given name can't be found (or it is found but doesn't implement the required interface properly / at all) the following error will be written into the RPT (In this example the given dll-name was "MyExtension"): 14:27:07 CallExtension 'MyExtension' could not be found If an extension is not whitelisted with BattlEye (see Extensions for more info) it will be blocked on clients running with enabled BattlEye protection. RPT message outputted however is a little obscure: 21:35:04 Call extension 'MyExtension' could not be loaded: Insufficient system resources exist to complete the requested service Since Arma 3 v1.69, RVExtensionVersion interface (see source code example below) has been added, which is called by the engine on extension load and expects extension version. This interface is designed to work with both, Linux and Windows. The max buffer size is 32 bytes. The version information will then appear in .rpt file like so: 19:06:36 CallExtension loaded: test_extension (.\test_extension.dll) [1.0.0.1] For more information see Extensions. Linux specific While on Windows the extension name is case-insensitive, on Linux the extension name is case-sensitive and should match the name of the .so file exactly (minus ".so" part). ⚠If a user has anti-virus software real time protection running, this could cause brand new extension to stutter the game and return with EXECUTION_WARNING_TAKES_TOO_LONG when executed for the first time, because of the AV software scanning. After the extension is whitelisted by AV this should go away until a new version of the extension is installed. Perhaps a dummy call to the extension on init should be considered as a feature of implementation to account for that Extension Callback Since Arma 3 v1.95 it is possible to call the game directly from the extension via function pointer provided when extension is called for the first time (assuming the extension implements at least one of the RVExtension or RVExtensionArgs methods). The function pointer passed over to RVExtensionRegisterCallback method is of the following signature (see Example 4): int(*callbackProc)(char const *name, char const *function, char const *data) Calling this function pointer from extension will trigger  "ExtensionCallback" mission event handler with 3 user supplied params. The params are name - make it unique name, for example the extension name, so that other modders can quickly filter out calls from own extensions function - make it name of the function the extension sends the result to. (Note: The returned function is just a STRING! So compile is needed, before using call or spawn, to execute it) data - make it the actual result. You can also format it as an array so it could be parsed by parseSimpleArray Calling function pointer returns an int. This is the number of available slots in the input buffer left for this frame after your call and can range from 99 to -1. The buffer is processed and cleared every frame and the maximum number of slots that can be filled per frame is 100. If you are planning to call back with more than 100 results per frame, make sure your extension retries if it receives negative int, which means the buffer was full and your call did not succeed. Ideally suited for callbacks from different threads, but if callback is initiated from the calling thread, the EH will fire on the next frame of game simulation. Needless to say, the "ExtensionCallback" event handler needs to exist before any callbacks, otherwise the data will just stay in the buffer. Removing all "ExtensionCallback" EHs clears the buffer as well as mission restart. Extension Context Since Arma 3 v2.11 the engine will call RVExtensionContext method (if exists, see Example 5) and pass the following data: steamID of the client calling extension getPlayerUID or "0" fileSource from which the extension was executed or "" if done on the fly missionName missionNameSource serverName serverName
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CallExtension(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(callextension(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Executes a command on the given camera / actor object. Known commands: All cameras "Camera" "Seagull" "CamCurator" "manual on" "manual off" "inertia on" "inertia off" "landed" lands the seagull "airborne" makes the seagull fly "maxPitch (x)" (number, in degrees) "minPitch (x)" (number, in degrees) "speedDefault (x)" (number) "speedMax (x)" (number) "ceilingHeight (x)" (number, in meters, ASL) "atl (x)" (on/off) "surfaceSpeed (x)" (on/off) The camCommand effect is immediate and does not need camCommit/camCommitPrepared.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamCommand(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camcommand(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Smoothly conduct the changes that were assigned to a camera within the given time. If the time is set to zero, the changes are done immediately. For camPrepareXXX commands use camCommitPrepared.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamCommit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camcommit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Smoothly conducts the changes that were assigned to a camera within the given time. If the time is set to zero, the changes are done immediately. This command is for use with camPrepareXXX commands. For the normal cam command use camCommit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamCommitPrepared(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camcommitprepared(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if the conduction of the last camCommit call already finished.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CamCommitted(GameValue rightInstance)
        {
            return new GameValue(camcommitted(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets construction camera parameters. To work with "camconstruct" object. ⚠Beware: camConstuctionSetParamssic.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamConstuctionSetParams(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camconstuctionsetparams(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a camera or a seagull object on the given position. The creation happens immediately and doesn't wait for camCommit. Among other commands, cameraEffect must be used to enter the camera's view and camDestroy to delete the created camera. See also Camera Control.⚠ Other objects can be created this way, but vehicles created with camCreate cannot be entered Any unit created with camCreate will remain static Unlike createVehicle, objects are created exactly at the given position, without consideration of the surrounding objects
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CamCreate(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camcreate(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Destroys camera object created with camCreate. This command doesn't need camCommit.  ⚠Destroying camera object does not terminate camera effect automatically, use cameraEffect prior to deleting the camera (see Example 2)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamDestroy(GameValue rightInstance)
        {
            return new GameValue(camdestroy(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the given effect on the given camera. If you want to switch the screen directly to the first-person, aiming, third-person or group view of an object, use switchCamera instead. The effect type "Terminate" is used to exit the current camera view and switch back to the player's view. Does not need camCommit. Since 1.74, it is possible to terminate individual r2t source. For example: cam cameraEffect ["terminate", "back", "rtt1"]; // would terminate "rtt1" r2t source cam cameraEffect ["terminate", "back"]; // would terminate all r2t sources ⚠One cannot mix and match cameraEffect and can either have multiple r2t cameras or a single camera for the whole screen. If one needs a background stream overlayed with r2t streams, this could be achieved by creating an object and using switchCamera to switch to it for background image, while using cameraEffect for r2t overlay (see Example 4).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CameraEffect(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(cameraeffect(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable / disable showing of in-game UI during currently active camera effect. By default the HUD is off, which will make results of drawIcon3D invisible, for example.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CameraEffectEnableHUD(GameValue rightInstance)
        {
            return new GameValue(cameraeffectenablehud(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return camera interest for given entity, as set by setCameraInterest, or as autodetected.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CameraInterest(GameValue rightInstance)
        {
            return new GameValue(camerainterest(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the vehicle to which the camera is attached.
        /// </summary>
        /// <returns>GameValue object</returns>
        public static GameValue CameraOn()
        {
            return new GameValue(cameraon());
        }

        /// <summary>
        /// Returns mode of active camera view. Mode is one of:  "INTERNAL" (1st person) "EXTERNAL" (3rd person) "GUNNER" (optics / sights) "GROUP" (commander view)
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue CameraView()
        {
            return new GameValue(cameraview());
        }

        /// <summary>
        /// Returns root of campaign description.ext entries hierarchy.
        /// </summary>
        /// <returns>GameValue config</returns>
        public static GameValue CampaignConfigFile()
        {
            return new GameValue(campaignconfigfile());
        }

        /// <summary>
        /// Preloads the scene for the prepared camera with given timeout after which preloading is aborted. Max timeout is 30 seconds. Timeout of 0 means max timeout of 30 seconds as well. This command will read prepared params set with camPrepareFOV, camPreparePos and camPrepareTarget, so no camCommitPrepared is necessary. If camPrepareFOV is not set, the default value is 1. If camPrepareTarget (for direction) and camPreparePos (for position) are not set, current direction and position of the camera are used. The prepared camera preload will preload main camera as well. cameraEffect is not necessary
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPreload(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreload(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the camera has finished preloading.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CamPreloaded(GameValue rightInstance)
        {
            return new GameValue(campreloaded(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prepares the camera bank angle. ⚠This command is non-functional!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPrepareBank(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparebank(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prepares the camera heading.  ⚠This command is non-functional!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPrepareDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparedir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prepares the camera dive angle.  ⚠This command is non-functional!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPrepareDive(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparedive(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// focusRange is . Prepares the camera focus blur. [-1,1] will reset default values (auto focusing), [-1,-1] will disable postprocessing (all is focused). Needs the call of camCommitPrepared to be conducted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPrepareFocus(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparefocus(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prepares the camera field of view (zoom). The default zoom level is 0.75, 0.01 is the nearest and 2 the furthest zoom value. The angle of the field of view is atan(FOV)*2 radians when in 4:3 aspect ratio. Needs the call of camCommitPrepared to be conducted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPrepareFov(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparefov(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prepares the camera field of view range for auto zooming. ⚠This command is non-functional!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPrepareFovRange(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparefovrange(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prepares the camera position. Needs the call of camCommitPrepared to be conducted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPreparePos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparepos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prepares the camera position relative to the current position of the currect target (see camPrepareTarget). Needs the call of camCommitPrepared to be conducted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPrepareRelPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparerelpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Prepares the camera target to a position or to a target. Needs the call of camCommitPrepared to be conducted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamPrepareTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(campreparetarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets camera bank angle. Does not commit changes. ⚠This command is non-functional!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetBank(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsetbank(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the orientation of the given camera in the direction of the given vector. Needs camCommit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsetdir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets camera dive angle. Does not commit changes.  ⚠This command is non-functional!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetDive(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsetdive(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets camera focus range in format [distance, blur]. blur param - sets the camera focus blur. It does not automatically commit changes (see camCommit). Use [-1, -1] to disable focus completely.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetFocus(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsetfocus(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the zoom level (Field Of View) of the given camera. The zoom level is from 0.01 for the nearest and 8.5 for the furthest zoom value, with a default zoom level of 0.75 The angle of the field of view is atan(FOV)*2 radians when in 4:3 aspect ratio. Needs the call of camCommit to be conducted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetFov(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsetfov(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the zoom level (Field Of View) start and end values for automatical zooming.  The default zoom level is 0.7 where 0 is the nearest and 1 is the most far zoom value.  ⚠This command is non-functional!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetFovRange(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsetfovrange(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the position of the given camera or seagull (see camCreate). It is worth mentioning that camera position can also be set with setPos, in which case it would be instant. With camSetPos it is possible to make smooth position transition in time, defined with camCommit, which is required in this case.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsetpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the position of the given camera relative to its target, set with camSetTarget. Needs a call to camCommit to be conducted.⚠Since it sets relative position to the target, the camSetTarget command should be executed already, before camSetRelPos.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetRelPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsetrelpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the target object or position where the given camera should point at. Needs the call of camCommit to be conducted. To reset the target use objNull.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamSetTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(camsettarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns camera's target.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CamTarget(GameValue rightInstance)
        {
            return new GameValue(camtarget(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set / clear using of night vision during cutscenes. This command only works with camCreate created camera that is currently the main camera for the player (see example).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CamUseNVG(GameValue rightInstance)
        {
            return new GameValue(camusenvg(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if given object can be stored in inventory of given object or any inventory container (uniform, vest, backpack) of given unit. Since Arma 3 v2.09 this command will count unit storage space as whole, instead of as biggest container, when multiple items are queried.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanAdd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(canadd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if given object can be stored into soldier's backpack.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanAddItemToBackpack(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(canadditemtobackpack(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if given object can be stored into soldier's uniform.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanAddItemToUniform(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(canadditemtouniform(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if given object can be stored into soldier's vest.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanAddItemToVest(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(canadditemtovest(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Cancels a simple task destination.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CancelSimpleTaskDestination(GameValue rightInstance)
        {
            return new GameValue(cancelsimpletaskdestination(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if a unit's weapon can be deployed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanDeployWeapon(GameValue rightInstance)
        {
            return new GameValue(candeployweapon(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the given vehicle is still able to fire. For the command to return true, vehicle must be alive, have weapon operator and the weapon cannot be damaged ≥ 0.9 but can be empty due to running out of ammo. If mission starts with vehicle having no ammo or setVehicleAmmo 0 command is executed on the vehicle, then canFire will always report false for it.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanFire(GameValue rightInstance)
        {
            return new GameValue(canfire(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if the given vehicle is still able to move. This command does not check for the amount of fuel the vehicle has, except for helicopters and airplanes. A helicopter with a damaged tail rotor may return that it cannot move, where a skilled pilot could use it.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanMove(GameValue rightInstance)
        {
            return new GameValue(canmove(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if setSlingLoad is possible.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanSlingLoad(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(canslingload(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if the given soldier is able to stand up. It only checks for the unit's legs and not its alive/dead status - it can return true for a dead unit. Since Arma 3 v1.60 and the introduction of limping, this command always returns true for humans.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanStand(GameValue rightInstance)
        {
            return new GameValue(canstand(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if sleep, uiSleep or waitUntil commands can be used in current scope. Usually when suspension is not allowed but used, for example when code is executed in unscheduled environment, the script engine would ignore any suspension command and throw error: "Suspending not allowed in this context". Using canSuspend command allows to detect the correct environment for the code. The definition of scheduled and unscheduled environment is not the same as whether or not the script execution can or cannot be suspended. For example while .sqs and .fsm scripts are scheduled (i.e. added to the scheduler: diag_activeSQSScripts, diag_activeMissionFSMs), they cannot use sleep or be suspended like execVM or spawn scripts can, therefore canSuspend for these types of scripts will return false.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue CanSuspend()
        {
            return new GameValue(cansuspend());
        }

        /// <summary>
        /// A getter for triggerDynamicSimulation
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanTriggerDynamicSimulation(GameValue rightInstance)
        {
            return new GameValue(cantriggerdynamicsimulation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns config value of `unloadInCombat` for a vehicle. Alternatively see getUnloadInCombat
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CanUnloadInCombat(GameValue rightInstance)
        {
            return new GameValue(canunloadincombat(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns bool array if it is possible to load cargo inside vehicle and if possible to load cargo into empty vehicle
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CanVehicleCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(canvehiclecargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the captive state of the given unit (set with setCaptive). A captive unit will not be attacked by its enemies. ⚠While a captive unit won't be attacked, it will still attack its enemies – be sure to setBehaviour "CARELESS" / removeAllWeapons accordingly.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Captive(GameValue rightInstance)
        {
            return new GameValue(captive(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the unit is a captive. If the unit is a vehicle, its commander is checked instead. If a unit's captivity level was set as a Boolean, then the returned number is either 0 (for false) or 1 (for true).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CaptiveNum(GameValue rightInstance)
        {
            return new GameValue(captivenum(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current state of a CT_CHECKBOX control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CbChecked(GameValue rightInstance)
        {
            return new GameValue(cbchecked(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the current state of a CT_CHECKBOX control. Use "CheckedChanged" control event handler with it.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CbSetChecked(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(cbsetchecked(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// The ceil value of x.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Ceil(GameValue rightInstance)
        {
            return new GameValue(ceil(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Array of Booleans in format [enabledChat, enabledVoN] for the given channel. For more information about enabling/disabling of chat channels see enableChannel. channel ID number correspondence Global Side Command Group Vehicle Direct Custom1 Custom2 Custom3 Custom4 Custom5 Custom6 Custom7 Custom8 Custom9 Custom10 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ChannelEnabled(GameValue rightInstance)
        {
            return new GameValue(channelenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether cheats are enabled (whether the designers' version is running).
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue CheatsEnabled()
        {
            return new GameValue(cheatsenabled());
        }

        /// <summary>
        /// Checks if the given AI feature is currently enabled.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CheckAIFeature(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(checkaifeature(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Affected by Not affected by terrain grid obstacles particles(with blockAIVisibility = 1) daylight distance overcast fog Checks if one position is visible from another position and how much. Particles that have blockAIVisibility set to 1 will influence the result, but will never make checkVisibility return 0; an extremely small number will be returned instead.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CheckVisibility(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(checkvisibility(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Pre-defined variable for the civilian side. When used in a format statement (hint format["/// </summary>",civilian]), the string returned is "CIV".
        /// <returns>GameValue side</returns>
        public static GameValue Civilian()
        {
            return new GameValue(civilian());
        }

        /// <summary>
        /// Returns short name of location. For config class name, see configName
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ClassName(GameValue rightInstance)
        {
            return new GameValue(classname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Clears the value of the given entity's attribute in Eden Editor. An attribute is identified by its property (data when it is engine-drive attribute) value in config. For the list of all attributes with their properties, see Setting Attributes. ⚠Attributes are available only within the Eden Editor workspace. You cannot access them in scenario preview or exported scenario!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Clear3DENAttribute(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(clear3denattribute(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes inventory from mission.sqm of given units. Effect is not immediately visible, only when previewing the inventory resets to default.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Clear3DENInventory(GameValue rightInstance)
        {
            return new GameValue(clear3deninventory(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from backpack of a unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearAllItemsFromBackpack(GameValue rightInstance)
        {
            return new GameValue(clearallitemsfrombackpack(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all backpacks from ammo box (or any general weapon holder container).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearBackpackCargo(GameValue rightInstance)
        {
            return new GameValue(clearbackpackcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all backpacks from the vehicle cargo space. MP synchronized.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearBackpackCargoGlobal(GameValue rightInstance)
        {
            return new GameValue(clearbackpackcargoglobal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all force generators from world. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearForcesRTD()
        {
            return new GameValue(clearforcesrtd());
        }

        /// <summary>
        /// Removes all icons from group.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearGroupIcons(GameValue rightInstance)
        {
            return new GameValue(cleargroupicons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from ammo box (or any general weapon holder container).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearItemCargo(GameValue rightInstance)
        {
            return new GameValue(clearitemcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from ammo box (or any general weapon holder container). It also removes vests and uniforms.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearItemCargoGlobal(GameValue rightInstance)
        {
            return new GameValue(clearitemcargoglobal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from ammo box (or any general weapon holder container)
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearItemPool()
        {
            return new GameValue(clearitempool());
        }

        /// <summary>
        /// Remove all magazines from the given vehicle's magazine cargo space.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearMagazineCargo(GameValue rightInstance)
        {
            return new GameValue(clearmagazinecargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all magazines from the vehicle cargo space. MP synchronized.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearMagazineCargoGlobal(GameValue rightInstance)
        {
            return new GameValue(clearmagazinecargoglobal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all magazines from the magazine pool, of which the player may choose in the following missions. Available in campaigns only.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearMagazinePool()
        {
            return new GameValue(clearmagazinepool());
        }

        /// <summary>
        /// Clear the current overlay. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearOverlay(GameValue rightInstance)
        {
            return new GameValue(clearoverlay(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Clean up the content of radio protocol history.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearRadio()
        {
            return new GameValue(clearradio());
        }

        /// <summary>
        /// Remove all weapons from the given vehicle's weapon cargo space.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearWeaponCargo(GameValue rightInstance)
        {
            return new GameValue(clearweaponcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all weapons from the vehicle cargo space. MP synchronized.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearWeaponCargoGlobal(GameValue rightInstance)
        {
            return new GameValue(clearweaponcargoglobal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove all weapons from the weapon pool, of which the player may choose in the following missions. Available in campaigns only.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue ClearWeaponPool()
        {
            return new GameValue(clearweaponpool());
        }

        /// <summary>
        /// Returns the  machine network ID of the client executing the command.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue ClientOwner()
        {
            return new GameValue(clientowner());
        }

        /// <summary>
        /// Close the currently active user dialog with exit code. Most common exit codes are: #define IDC_OK 1 // emulate "Ok" button #define IDC_CANCEL 2 // emulate "Cancel" button
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CloseDialog(GameValue rightInstance)
        {
            return new GameValue(closedialog(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Closes given display with exit code. It does not instantly close the display but does it on next simulation cycle. Most common exit codes are: #define IDC_OK		1 // emulate "OK" button #define IDC_CANCEL	2 // emulate "Cancel" button ⚠Sometimes when one display is opened on top of another display the previous display may not close properly; some display EHs such as "onUnload" may never fire. Use this command to manually handle such displays.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CloseDisplay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(closedisplay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Closes the current overlay without committing.  Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CloseOverlay(GameValue rightInstance)
        {
            return new GameValue(closeoverlay(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Collapse the object tree. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CollapseObjectTree(GameValue rightInstance)
        {
            return new GameValue(collapseobjecttree(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Execute a block of code in which all Eden Editor operations will be recorded as one history step. For example creating an entity, setting its attributes and then connections would normally be recorded as three different steps. Calling them all within single collect3DENHistory block will group them together and the user will need to undo only once to revert the changes. In order to only change the 2nd or 3rd parameter of the alternative syntax use nil as the preceding parameters. Some useful icons are: Show texture paths "\a3\3den\data\cfg3den\history\addtolayer_ca.paa" "\a3\3den\data\cfg3den\history\changeattributes_ca.paa" "\a3\3den\data\cfg3den\history\changeseat_ca.paa" "\a3\3den\data\cfg3den\history\connectitems_ca.paa" "\a3\3den\data\cfg3den\history\create_ca.paa" "\a3\3den\data\cfg3den\history\createcomment_ca.paa" "\a3\3den\data\cfg3den\history\deleteitems_ca.paa" "\a3\3den\data\cfg3den\history\disconnectitems_ca.paa" "\a3\3den\data\cfg3den\history\makenewlayer_ca.paa" "\a3\3den\data\cfg3den\history\missionnew_ca.paa" "\a3\3den\data\cfg3den\history\moveitems_ca.paa" "\a3\3den\data\cfg3den\history\multipleoperations_ca.paa" "\a3\3den\data\cfg3den\history\pasteitems_ca.paa" "\a3\3den\data\cfg3den\history\removefromlayer_ca.paa" "\a3\3den\data\cfg3den\history\rotateitems_ca.paa" "\a3\3den\data\cfg3den\history\scaleitems_ca.paa"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Collect3DENHistory(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(collect3denhistory(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current position of a helicopter's collective pitch control. 0: fully lowered 1: fully raised For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CollectiveRTD(GameValue rightInstance)
        {
            return new GameValue(collectivertd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object, given object has collision disabled with and whether or not returned object has also collision disabled with given object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CollisionDisabledWith(GameValue rightInstance)
        {
            return new GameValue(collisiondisabledwith(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns combat behaviour of unit or group. To set unit or group behaviour see setCombatBehaviour. The behaviour is one of:
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CombatBehaviour(GameValue rightInstance)
        {
            return new GameValue(combatbehaviour(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the combat mode of the given AI  group. See setCombatMode for more information about combat modes.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CombatMode(GameValue rightInstance)
        {
            return new GameValue(combatmode(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders an artillery unit to fire a burst on the given position (via the radio).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandArtilleryFire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandartilleryfire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Types text to the command radio channel. The text will be visible only on the PC where command was executed. If you need the message to show on all computers, you have to execute it globally (see remoteExec) ⚠The unit must have an assigned radio item (such as "ItemRadio") to see or transmit the messages. A radio item must have the property simulation = "ItemRadio"; in its CfgWeapons config.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandChat(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandchat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// In Operation Flashpoint it returns the commander of a vehicle. Since Armed Assault it returns the primary observer. The commander of a vehicle can be found with effectiveCommander.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue Commander(GameValue rightInstance)
        {
            return new GameValue(commander(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit to fire on the given target (via the radio). If the target is objNull, the unit is ordered to fire on its current target (set with doTarget or commandTarget).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandFire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandfire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to follow another from his own group (via radio). It can also be used to resume unit formation after e.g doStop.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandFollow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandfollow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders a unit to process command defined by FSM file (via the radio).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandFSM(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandfsm(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders one or multiple units to get out from the vehicle (via the radio). Same as doGetOut with latter being silent.  Works for both AI and player entities AI unit gets back in - unless is under player command or combined with other sqf commands (orderGetIn false, allowGetIn false or leaveVehicle) Ignores vehicle's lock state - unlike action "Eject" and moveOut AI waits for execution until vehicle has stopped/is no longer flying (unclear if any timeout exists for order to be discarded) - unlike action "Eject" and moveOut Plays the vehicle's position's get out animation (same as action "Eject") - unlike moveOut When execute for multiple units, it waits till the action is completed, before the next to take his turn (same as action "Eject") - unlike moveOut AI gets back into formation afterwards Works only on alive units - unlike action "Eject" (one after another) or moveOut (instantly) Does not work on unconscious units - unless the AI is under player command. Unlike moveOut or action "Eject" (but one after another)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandGetOut(GameValue rightInstance)
        {
            return new GameValue(commandgetout(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of the topmost commanding menu or "" if the menu is closed. For action menu visibility check see isActionMenuVisible. See Notes for Arma 2/Arma 3 structure.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue CommandingMenu()
        {
            return new GameValue(commandingmenu());
        }

        /// <summary>
        /// Order the given unit(s) to move to the given location (via the radio). Exactly the same as doMove, except this command displays a radio message. The command will not put a visible waypoint marker unlike when move command is given via commanding menu.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandMove(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandmove(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sends the audio message to the command radio channel. The message is defined in CfgRadio in the description.ext file or config radio protocol. The transmission will play only on the PC where command was executed. If you need the transmission to play on all computers, you have to execute it globally (see remoteExec). ⚠The unit must have an assigned radio item (such as "ItemRadio") to see or transmit the messages. A radio item must have the property simulation = "ItemRadio"; in its CfgWeapons config. When transmitting unit gets killed, transmission will be interrupted. However when receiving unit gets killed, the transmission continues to play.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandRadio(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandradio(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to stop via radio. A stop command will never finish, the unit(s) will never be ready.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandStop(GameValue rightInstance)
        {
            return new GameValue(commandstop(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders the given unit or a group of units to suppress the given position or target (with radio messages, see doSuppressiveFire if you don't want messages).  When an Array of units is passed as param, only units from the same Group as the first unit in array are considered. The unit (units) starts firing at the given target or position random amount of shots (exact formula unknown, but seems to depend on amount of ammo unit has) after which it stops. currentCommand shows "Suppress" and there is no way of stopping unit before it completes random amount of rounds. If position is passed as target param, it stays fixed. If object is passed as target param, it depends on what kind of object. If it is considered a proper target by the unit, it is tracked by the unit dynamically. If it is not, the position gets obtained via getPosWorld, which could be different from PositionASL of the object, and it is fixed even if the target is able to change position later.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandSuppressiveFire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandsuppressivefire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to target the given target (via the radio). Command given to the player, puts a red square with words Target and Distance on player's HUD at target location. If player in vehicle and has radar facilities, it also adds target marker to the radar.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandtarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders the unit(s) to watch the given position or target (via the radio). Use objNull as the target to order a unit to stop watching a position/target.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommandWatch(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(commandwatch(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines a comment. See SQF Syntax - Comments to learn more about comments. ⚠This command is evaluated during execution, and as such is infinitely slower than other SQF comment methods (// comment or /* comment */) which get preprocessed and do not exist at runtime). See SQF Syntax for additional documentation on comments. This command is only used to place comments in unpreprocessed codes, such as trigger On Activation field, object init field, etc. Alternatively, one can use a plain string followed by a semicolon as a way to comment; e.g "Some comment";.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Comment(GameValue rightInstance)
        {
            return new GameValue(comment(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Commit the current overlay.  Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CommitOverlay(GameValue rightInstance)
        {
            return new GameValue(commitoverlay(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all items (attachments) that can be mounted on the given weapon.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CompatibleItems(GameValue rightInstance)
        {
            return new GameValue(compatibleitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all magazines that can be loaded in the given weapon.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CompatibleMagazines(GameValue rightInstance)
        {
            return new GameValue(compatiblemagazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compiles String expression into Code.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue code</returns>
        public static GameValue Compile(GameValue rightInstance)
        {
            return new GameValue(compile(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compiles an expression / takes an existing Array/HashMap and makes it final, preventing it from being modified or overwritten (by = assignation, publicVariable, set or any other command). This feature is only available in the retail version of Arma 3.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue code</returns>
        public static GameValue CompileFinal(GameValue rightInstance)
        {
            return new GameValue(compilefinal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// This command is an alias for compile(Final) (prefixHeader + preprocessFileLineNumbers path). See description of preprocessFileLineNumbers for more details. In addition, this command can also compile SQF Bytecode files, which can reduce compilation time.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue code</returns>
        public static GameValue CompileScript(GameValue rightInstance)
        {
            return new GameValue(compilescript(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the given FSM is completed. The FSM handle is the number returned by the execFSM command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CompletedFSM(GameValue rightInstance)
        {
            return new GameValue(completedfsm(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a Structured Text by joining the given  structured or  plain text arguments.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue text</returns>
        public static GameValue ComposeText(GameValue rightInstance)
        {
            return new GameValue(composetext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of config entries which meet criteria in condition code. Command iterates through all available config sub classes of the given config class. Current looked at config is stored in _x variable (similar to alternative count command implementation). Condition has to return true in order for the looked at config to be added to the resulting array. Slightly faster than configProperties, but doesn't account for config properties or inherited entries. ⚠ The condition code passed to configClasses should only be used for simple filter expressions and nothing more Do not use "isClass _x" in the condition. The engine does this check already Arma 3 v2.02 brought specific engine optimisations for the following conditions: "true" "getNumber (_x >> 'scope') > 0"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ConfigClasses(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(configclasses(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return root of config entries hierarchy.
        /// </summary>
        /// <returns>GameValue config</returns>
        public static GameValue ConfigFile()
        {
            return new GameValue(configfile());
        }

        /// <summary>
        /// Returns hierarchy of the given config class. Just like with inheritsFrom, only complete config classes are supported (before 2.14).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ConfigHierarchy(GameValue rightInstance)
        {
            return new GameValue(confighierarchy(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns name of config entry.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ConfigName(GameValue rightInstance)
        {
            return new GameValue(configname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A non-existing Config. ⚠Unlike other null values (objNull, grpNull, etc), configNull returns true when compared to itself. configNull == configNull;							// returns true isNull configNull;									// returns true configNull isEqualTo configNull;					// returns true configNull == configFile >> "ANonExistentEntry";	// returns true
        /// </summary>
        /// <returns>GameValue config</returns>
        public static GameValue ConfigNull()
        {
            return new GameValue(confignull());
        }

        /// <summary>
        /// Returns config path of the provided object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue config</returns>
        public static GameValue ConfigOf(GameValue rightInstance)
        {
            return new GameValue(configof(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of config entries which meet criteria in condition code. Command iterates through available classes and config properties for given config entry. If 3rd param is true the search also includes inherited properties. Current looked at config is stored in _x variable (similar to alternative count command implementation). Condition has to return true in order for the looked at property to be added to the resulting array. A bit slower than configClasses but allows to access inherited entries. ⚠The condition code passed to configProperties should only be used for simple filter expressions and nothing more. Since 2.02 the following conditions are optimised for performance: "true" (omitted condition) "isClass _x" "isClass _x && (...)"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ConfigProperties(GameValue rightInstance)
        {
            return new GameValue(configproperties(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of addons (CfgPatches) in which the given config class is defined.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ConfigSourceAddonList(GameValue rightInstance)
        {
            return new GameValue(configsourceaddonlist(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns modDir of the mod that given config class was loaded from.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ConfigSourceMod(GameValue rightInstance)
        {
            return new GameValue(configsourcemod(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of mods (CfgMods) in which the given config class is defined.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ConfigSourceModList(GameValue rightInstance)
        {
            return new GameValue(configsourcemodlist(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets for which Side the entity becomes a "confirmed hostile" target - a target that becomes highlighted red on the sensors display.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ConfirmSensorTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(confirmsensortarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Connect person with UAV terminal to UAV unit. UAV Terminal item needs to be assigned to GPS slot. If UAV is already connected to another terminal, this new connection will fail.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue ConnectTerminalToUAV(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(connectterminaltouav(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Connects the client to the provided server. only works on the Main Menu. must be executed from  UI context, such as onButtonDown or similar events (see User Interface Event Handlers).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ConnectToServer(GameValue rightInstance)
        {
            return new GameValue(connecttoserver(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Skips the current loop iteration, continues with the next one and returns the given value.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue ContinueWith(GameValue rightInstance)
        {
            return new GameValue(continuewith(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A non-existing Control. To compare non-existent objects use isNull or isEqualTo (see examples).
        /// </summary>
        /// <returns>GameValue control</returns>
        public static GameValue ControlNull()
        {
            return new GameValue(controlnull());
        }

        /// <summary>
        /// Returns a child control with specified idc from a controls group
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue control</returns>
        public static GameValue ControlsGroupCtrl(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(controlsgroupctrl(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for disableConversation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue ConversationDisabled(GameValue rightInstance)
        {
            return new GameValue(conversationdisabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return ANSI content of the (text) clipboard. If Unicode support is desired, see forceUnicode.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue CopyFromClipboard()
        {
            return new GameValue(copyfromclipboard());
        }

        /// <summary>
        /// Copies ANSI text string to the clipboard. If Unicode support is desired, see forceUnicode.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CopyToClipboard(GameValue rightInstance)
        {
            return new GameValue(copytoclipboard(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Copy the chain of waypoints from source to target group. The target group will start to process waypoints from the first one.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CopyWaypoints(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(copywaypoints(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Cosine of a number, argument in degrees.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Cos(GameValue rightInstance)
        {
            return new GameValue(cos(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Can be used to count: The number of elements in an array (returns the already internally known array size) The number of elements in an array matching the condition The number of sub-entries in a config entry 1.28 The number of characters in an ANSI string If Unicode support is desired, see forceUnicode.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Count(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(count(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Count how many units in the array are considered enemy to the given unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CountEnemy(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(countenemy(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Count how many units in the array are considered friendly to the given unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CountFriendly(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(countfriendly(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns how many units in the given array belong to given side.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CountSide(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(countside(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Count how many objects in the array are of given type. This command also works with parent classes like "Air", "Tank", and "Car". For a full class reference see Classes.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CountType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(counttype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Count how many units in the array are unknown to the given unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CountUnknown(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(countunknown(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create new Composition. To create individual entities, use create3DENEntity.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Create3DENComposition(GameValue rightInstance)
        {
            return new GameValue(create3dencomposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create new Eden Entity. Used for creating individual entities; to create a composition (e.g., infantry squad), use create3DENComposition and to create a layer use add3DENLayer. This is the only way to add new editable entities to an Eden Editor scenario. Other 'create' commands like createVehicle or createUnit will still work, but the resulting entity will not be editable.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue Create3DENEntity(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(create3denentity(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates an agent of the given type. An agent does not have a group or leader or the standard soldier FSM associated with it - for instance, an enemy soldier spawned as an agent has limited AI and will do nothing when fired upon - which can be useful to limit the amount of AI processing being done in a mission with very large numbers of "AI". Animals are also commonly created as agents. Players assigned to an agent using selectPlayer will be able to control the agent, operate weapons and other actions, but will not be able to access their inventory using the gear screen. To create objects of type "Logic", use createUnit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateAgent(GameValue rightInstance)
        {
            return new GameValue(createagent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Instanciate a Side center. A Side center is required to be able to create groups of this side. Centers can only be created for east, west, resistance, civilian and sideLogic sides. Created sides must have their "side-friendship" defined with setFriend. In Armed Assault and Arma 2, only Mission.sqm's units side centers are created; e.g if no resistance unit has been placed in the editor you must use createCenter before being able to create a resistance group. In Arma 3, centers for all sides are all created by the engine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue side</returns>
        public static GameValue CreateCenter(GameValue rightInstance)
        {
            return new GameValue(createcenter(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a dialog which is defined either in the mission's description.ext, in the campaign's description.ext or in the global resource.cpp. The given name has to be the class name used in one of these files. If another dialog is already opened, the desired dialog is created as a child dialog of the one already opened. By default, displays created with createDisplay are rendered on top of dialogs created with createDialog. If forceOnTop is set to true, the dialog will be rendered on top of displays.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue display</returns>
        public static GameValue CreateDialog(GameValue rightInstance)
        {
            return new GameValue(createdialog(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a link to the given diary entry.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CreateDiaryLink(GameValue rightInstance)
        {
            return new GameValue(creatediarylink(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a Diary entry. Supported tags and their parameters: Show text Tag Options Example img image: String - path to image. When present, any element with it will be displayed as image. width: Number - image width in pixels. height: Number - image height in pixels. 2.10 title: String - tooltip to show on mouse over image 2.10 src: String - alternative to 'image' Maximum width supported seems to be 370 pixels as a wider image will be cut off. Height should be calculated with the aspect ratio of the image. height = 370; ratio = 16/9; height = width / ratio; <img image="picture.paa" width="128" height="64" /> Since Arma 3 v2.10: <img src="picture.paa" width="128" height="64" title="this is an image" /> font color: String - HTML color in format #aarrggbb or #rrggbb size: Number - font height in pixels (default: 14) face: String - font type (see Fonts) <font color="#FF00FF" size="16" face="LucidaConsoleB">Hello there</font> br N/A Line 1<br />Line 2 marker name: String - marker name <marker name="respawn_west">Respawn point</marker> execute expression: String - executed code <execute expression="player setDamage 1">Die!</execute> executeClose expression: String - executed code, diary is closed afterwards <executeClose expression="player setDamage 1">Die and close</executeClose> log subject: String - subject name. record: String - record ID (e.g. "Record6" or "Unit1059524") <log subject="Hello">Get to the "Hello" subject</log> <log subject="Hello" record="Record0">Go to the first record added to "Hello"</log> gear unit: Number - unit ID <gear unit="123456">Open unit 123456's gear</gear> teamSwitch unit: Number - unit ID <teamSwitch unit="123456">Switch to unit 123456</teamSwitch> kick id: Number - unit ID <kick unit="123456">Kick player unit 123456</kick> ban id: Number - unit ID <ban unit="123456">ban player unit 123456</ban> mute id: Number - unit ID <mute unit="123456">mute player unit 123456</mute> voteadmin id: Number - unit ID <voteadmin unit="123456">vote admin unit 123456</voteadmin> votekick id: Number - unit ID <votekick unit="123456">vote kick player unit 123456</votekick> currentTask id: Number - task ID action: String - 'n' or 's' (select) <currentTask id="my_task">get to my_task task</currentTask> If the createDiaryRecord command fails, it returns a null record. Before Arma 3 v2.00, isNull did not work with the diary record type and diaryRecordNull did not exist. In order to verify a null record, it is possible to create a variable and compare against it: private _recordNull = objNull createDiaryRecord []; private _createdRecord = player createDiaryRecord ["Diary", ["Title", "Description"]]; if (_createdRecord isEqualTo _recordNull) then { hint "Failed"; };
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue diary_record</returns>
        public static GameValue CreateDiaryRecord(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(creatediaryrecord(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a new subject in the Diary.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CreateDiarySubject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(creatediarysubject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates child display of given display and loads from "resourceName". The notable difference between createDisplay and createDialog is that with createDisplay the player would be able to move around while the display is shown. Displays created with createDisplay or createDialog will take control of the mouse pointer and will close when user presses Esc. Since Arma 3 v1.50 createDisplay returns Display and will first look in description.ext for resourceName config, if not found, it will then look in main config. If an overlay is needed instead, use cutRsc.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue display</returns>
        public static GameValue CreateDisplay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createdisplay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Opens gear dialog for given unit. action command can also be used:player action ["Gear", player];
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CreateGearDialog(GameValue rightInstance)
        {
            return new GameValue(creategeardialog(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a new Group for the given Side. Using this command if the group limit is reached will return grpNull. The new Group exists globally, but it's locality is where this command was executed. Game 1.00 1.00 1.00 1.00 1.50 1.00 1.00 1.68 Group auto-deletion Group limit per side 63 144 288 ⚠ Groups can only be created for the west/blufor, opfor/east, independent/resistance, civilian and sideLogic sides - any other side will return grpNull Before Arma 3, a Side center must exist before group creation (either by having editor-placed units or createCenter usage) createCenter usage is not needed anymore as all centers are automatically created. When the last unit leaves its group, the group usually gets immediately auto-deleted, regardless of its auto-deletion setting.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue group</returns>
        public static GameValue CreateGroup(GameValue rightInstance)
        {
            return new GameValue(creategroup(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a point guarded by the given side (scripted way of adding equivalent of "GUARDED BY" trigger in Editor). A closest AI group in the given side with assigned "GUARD" waypoint will attempt to secure this guard point. The actual guarded position is determined via the following rules: Given "position" is always considered. It could be Object, Group, Position2D or Position3D. In every case, z coordinate will be ignored and point will be placed on nearest surface. If "objectMapID" is not negative, the position of the object with the given ID is used (Overrides "position"). -1 to ignore this argument. z of the object position will be intact. If the given "vehicle" is valid, the position of the vehicle is extracted and guarded (Overrides both "position" and "objectMapID"). objNull to ignore. z of the vehicle position will be intact. To be used with "GUARD" waypoint. To know how does the "GUARD" waypoint work, see Waypoint:Guard.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CreateGuardedPoint(GameValue rightInstance)
        {
            return new GameValue(createguardedpoint(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a new empty HashMap.
        /// </summary>
        /// <returns>GameValue hashmap</returns>
        public static GameValue CreateHashMap()
        {
            return new GameValue(createhashmap());
        }

        /// <summary>
        /// Creates a new HashMap and initializes it from a key-value pair array
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue hashmap</returns>
        public static GameValue CreateHashMapFromArray(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createhashmapfromarray(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a location of the specified class and dimensions at the specified position. Classes are defined in CfgLocationTypes; for possible location types see Location Types. The alternative syntax allows to convert a non-editable (built-in) terrain location into an editable one, with the following restrictions: it cannot be deleted (but can be setType to "Invisible" to hide it) it cannot be moved
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue location</returns>
        public static GameValue CreateLocation(GameValue rightInstance)
        {
            return new GameValue(createlocation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a new map marker at the given position. The marker will be created for every connected player as well as all JIP players. The marker name has to be unique; the command will be ignored if a marker with the given name already exists. ⚠The marker will be visible only once at least markerType has been defined: _marker = createMarker ["markername", player]; // Not visible yet. _marker setMarkerType "hd_dot"; // Visible. If the marker position is given in 3D format, the z-coordinate is stored with the marker and will be used when the marker is passed to commands such as createVehicle, createUnit, createAgent, createMine or setVehiclePosition.When a marker is manually placed in the editor, z is always 0, which means the marker is placed on the ground. But when the player places a marker on the map in game, it is placed at sea level, so the z-coordinate of that marker is -getTerrainHeightASL markerPos "userMarker";.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CreateMarker(GameValue rightInstance)
        {
            return new GameValue(createmarker(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a local marker at the given position - the marker only exists on the machine that created it. The marker name has to be unique, if a marker with the given name exists, the command will be ignored. Use deleteMarkerLocal to delete a local marker. If the position is given in 3D format, z coordinate is stored with the marker and will be used when marker is passed to commands like createVehicle, createUnit, createAgent, createMine, setVehiclePosition for example. However getMarkerPos and markerPos will always return 0 for z.  ⚠Local markers have their own set of local commands "xxMarkerxxLocal" to work with. If you use global marker commands on a local marker, the local marker will become global.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CreateMarkerLocal(GameValue rightInstance)
        {
            return new GameValue(createmarkerlocal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a previously added menu. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CreateMenu(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createmenu(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a mine of the given type. If the markers array only contains one marker name, it is ignored and the position parameter is used instead. If markers contains multiple marker names, one of them is chosen randomly and used as the center of the placement area. This command creates objects of the CfgAmmo class named in configFile >> "CfgVehicles" >> _type >> "ammo". Unit ability to detect mines depends on many factors: The starting value is defined in config, for example ./CfgVehicles/B_soldier_F/detectSkill, which in this case is 12. Mine specialist value for example, defined in  ./CfgVehicles/B_soldier_exp_F/detectSkill is 38. This value is then dynamically reduced depending on factors such as distance, if a unit is in a vehicle, if it is day or night time, how directly unit is looking at the mine, how fast unit is moving, how inconspicuous is the mine or even if it is visible.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateMine(GameValue rightInstance)
        {
            return new GameValue(createmine(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create single missions display as a child of given display. The mission dialog will be set to the directory given as an argument "root".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue display</returns>
        public static GameValue CreateMissionDisplay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createmissiondisplay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a MP campaign display. The class name must be a mission collection declared in the configs; for example, configFile >> "CfgMissions" >> "MPMissions" >> "Apex" If the class does not exist or is not a mission collection, the display will be created empty.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CreateMPCampaignDisplay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(creatempcampaigndisplay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create object with given shape defined as path to .p3d model. Supported LODs include Geometry, Fire Geometry, Roadway, View Geometry and ShadowVolume. Supported features include collision, texturing, animation, penetration, AI spotting occlusion, and surface specific sounds (like footsteps). Unsupported features include PhysX, damage, AI pathfinding (causes walking through walls), and built-in lights. Given the simulation limitations, global decorative objects can be created with very little network traffic. Objects that could be exclusively created with this command are: trees, bushes, rocks, bridges, roads, vehicle wrecks, custom models in mission, and other objects without a class in config. The height of the placement position might need to be adjusted experimentally. See Arma 3: createSimpleObject/objects for a p3d models' list. See Arma 3: Livonia Props for Livonia furniture. See Arma 3: Simple Objects to learn more about simple objects. addAction does not work with simple objects. objects created with Syntax 1 cannot be textured. Some objects may also have inverted default direction. objects created with Syntax 2 can be textured. The default direction should match the direction of the object if it was created with createVehicle. only as of 1.68 do simple objects support getVariable and setVariable.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateSimpleObject(GameValue rightInstance)
        {
            return new GameValue(createsimpleobject(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a new Task and adds it to the Diary. Using the Arma 3: Task Framework instead is recommended When task is added as a child, it appears as subcategory to the parent task in the Tasks menu and can be parent to another child task. However this is cosmetic appearance as each task has own id and can be referenced directly via diary link.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue task</returns>
        public static GameValue CreateSimpleTask(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createsimpletask(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a new site.  ⚠This command is considered deprecated and is no longer supported
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateSite(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createsite(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a sound source of the given type (type is the name of the subclass of CfgVehicles which is pointing to the sound defined in CfgSFX). The actual sound object created is of type "#dynamicsound" and could be detected with allMissionObjects. If the markers array contains several marker names, the position of a random one is used, otherwise, the given position is used. The sound source is placed inside a circle with this position as its center and placement as its radius. Some of the vanilla classes pre-configured in Arma 3: "Sound_Alarm" "Sound_Alarm2" "Sound_BattlefieldExplosions" "Sound_BattlefieldFirefight" "Sound_Fire" "Sound_SmokeWreck1" "Sound_SparklesWreck1" "Sound_SparklesWreck2" "Sound_Stream" Since Arma 3 v1.70 it is possible to define sounds for use with createSoundSource in mission config. As mentioned earlier, the sounds needed for this command should be defined inside CfgVehicles class, which itself references CfgSFX class. If given class searched in main config and is not found, the search will continue in description.ext - see Example 3. Note that the sound created by createSoundSource will always be looping. Also when CfgSFX sound definition contains more than 1 sound, there is no guarantee that the sound played will be the same on every PC in Multiplayer.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateSoundSource(GameValue rightInstance)
        {
            return new GameValue(createsoundsource(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a new AI task (subtask of parentTask). Type is name of registered task type.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue task</returns>
        public static GameValue CreateTask(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createtask(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a Team and names it.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue team_member</returns>
        public static GameValue CreateTeam(GameValue rightInstance)
        {
            return new GameValue(createteam(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a trigger of the given type and at the given position. The type must be a class name in CfgNonAIVehicles or CfgVehicles with simulation = detector. An array containing all units that have activated the trigger is available via list triggerobj. Since triggers are Objects, commands such as getPosASL, setPosASL, deleteVehicle etc. work on them. Since Arma 3 v1.54 triggers can be disabled/enabled using enableSimulation command. Triggers are created with default parameters: a: 50 b: 50 c: -1 angle: 0 rectangular: false activationBy: None activationType: Present repeating: false timeoutMin: 0 timeoutMid: 0 timeoutMax: 0 interruptable: true type: None text: "" name: "" expCond: "this" expActiv: "" expDesactiv: "" 1.98 interval: 0.5
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateTrigger(GameValue rightInstance)
        {
            return new GameValue(createtrigger(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a unit of the provided CfgVehicles class. ⚠The unit will not be created if the passed group does not exist (a.k.a grpNull); this can happen if createGroup fails because the group limit has been reached (see createGroup for respective game limits). Syntax 1 Syntax 2 Group's locality the provided group can be non-local, but a warning will be logged the provided group must be local Unit's side using a classname from a different side than the provided group will result in the unit itself being of a (config-defined) side inside a group of another side - see Example 6 for more information using a classname from a different side than the provided group will result in the unit being of the same side as the provided group Other the unit's init code will execute after a slight delay if the provided group is not local this syntax does not return a reference to the created unit (see Example 7) 1.34 1.00 This command could be bugged in Operation Flashpoint or Armed Assault; an additional join may solve the problem. However, some commands such as setUnitPos only work if run before the join.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateUnit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createunit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates an empty object of given classname type. See Arma 3 Assets / Arma 3: createVehicle/vehicles, or CfgVehicles for earlier games. To create objects of type "Logic", use createUnit. To create an editable  Eden Editor entity, see create3DENEntity. To avoid vehicle randomisation in Arma 3, set the BIS_enableRandomization variable immediately after creating the vehicle: private _vehicle = "C_Offroad_01_F" createVehicle position player; _vehicle setVariable ["BIS_enableRandomization", false]; Check Vehicle Customization (VhC) page for more information and settings.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateVehicle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createvehicle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates vehicle crew corresponding to the provided vehicle's faction. If the vehicle is already occupied, the command will only create missing crew in the existing vehicle's group. To find out which crew will be created, use BIS_fnc_vehicleCrewTurrets.    This command: 1.26 creates a group if one is needed (otherwise uses group vehicle) creates a driver (if the vehicle needs one - config hasDriver) creates all non-FFV turrets gunners (if the turret needs one - config hasGunner without dontCreateAI) does not create cargo does not addVehicle to the created crew in the same way this normally happens when crewed vehicle created in the editor. See BIS_fnc_spawnVehicle to spawn a crew-full vehicle with group addition. ⚠While a vehicle with a crew placed in editor will have all crew units of the rank "PRIVATE", this command will create the driver as "LIEUTENANT" and all turret units as "SERGEANT".
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue group</returns>
        public static GameValue CreateVehicleCrew(GameValue rightInstance)
        {
            return new GameValue(createvehiclecrew(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates an object of the given type. Created object is not transferred through network in MP games. netId of such vehicle in multiplayer will be "0:0". To disable local vehicle creation, use CfgDisabledCommands to blacklist this command. Alternatively, you can use createSimpleObject with local option enabled where applicable.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CreateVehicleLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(createvehiclelocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the crew (both dead and alive) of the given vehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Crew(GameValue rightInstance)
        {
            return new GameValue(crew(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a header line of controls according to the HeaderTemplate class. It returns an array containing header index and array of created controls in  format: [<headerIndex>, [<control0>, <control1>...<control n>]]. Note that rows and headers are indexed separately.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtAddHeader(GameValue rightInstance)
        {
            return new GameValue(ctaddheader(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds one row of controls according to the RowTemplate class. It returns an array containing row index and array of created controls in a format [<rowIndex>, [<control0>, <control1>...<control n>]]. Note that rows and headers are indexed separately.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtAddRow(GameValue rightInstance)
        {
            return new GameValue(ctaddrow(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all the lines from the RscControlsTable. Returns Nothing.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtClear(GameValue rightInstance)
        {
            return new GameValue(ctclear(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns index of the selected row. Will take only rows, but not headers into account.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtCurSel(GameValue rightInstance)
        {
            return new GameValue(ctcursel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns metadata associated with a particular row of a CT_CONTROLS_TABLE control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CtData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets array of indices of rows under this header.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtFindHeaderRows(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctfindheaderrows(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets index of the closest header above this row.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtFindRowHeader(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctfindrowheader(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of controls on the header with the given index.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtHeaderControls(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctheadercontrols(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns number of headers (rows not included) in the RscControlsTable.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtHeaderCount(GameValue rightInstance)
        {
            return new GameValue(ctheadercount(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Takes array of header indices as a parameter and removes headers with those indices. Indices of remaining headers will be recomputed.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtRemoveHeaders(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctremoveheaders(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Takes array of row indices as a parameter and removes rows with those indices. Indices of remaining rows will be recomputed.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtRemoveRows(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctremoverows(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Launch actions attached to given (button based) control.   Command only triggers action entry described in control config and engine-based actions (cancel or ok codes) and will not trigger button related User Interface Event Handlers. Command ignores control disabled state. (Example 2)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlActivate(GameValue rightInstance)
        {
            return new GameValue(ctrlactivate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add an event handler to the given control. ⚠ Control event handlers are processed in reversed order, i.e. last added: first, first added: last. So if you have an override it should be set up in the 1st added EH. When using the event names listed here with the ctrlAddEventHandler, ctrlSetEventHandler, displayAddEventHandler or displaySetEventHandler commands, the prefix "on" in the event name must be removed (e.g. 'ButtonDown' instead of 'onButtonDown').
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlAddEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrladdeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets rotation info of a control set as ST_PICTURE. Supported control types: CT_STATIC CT_ACTIVETEXT (Since Arma 3 v2.09.149642)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlAngle(GameValue rightInstance)
        {
            return new GameValue(ctrlangle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Process an animation of 3D Arma: GUI Configuration. Command uses name defined by source property and works similar like animateSource command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlAnimateModel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlanimatemodel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current animation phase of given source. Similar to animationSourcePhase.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlAnimationPhaseModel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlanimationphasemodel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the control at the specified coordinates.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue control</returns>
        public static GameValue CtrlAt(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns number of seconds auto-scroll will wait before scroll and/or rewind. -2 if scrollbar not present.  Autorscroll is available for CT_LISTBOX and CT_CONTROLS_GROUP types of controls only. Autoscroll will wait ctrlAutoScrollDelay seconds (must be  > 0) and then will scroll the scroll bar down to the bottom. ctrlAutoScrollSpeed defines the speed with which scrollbar is scrolled. If ctrlAutoScrollRewind is true, the control will fade out, immediately rewind to the top, then fade in, wait ctrlAutoScrollDelay seconds and then repeat the scrolling in a loop. If user focuses on the control, autoscrolling is interrupted.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlAutoScrollDelay(GameValue rightInstance)
        {
            return new GameValue(ctrlautoscrolldelay(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if auto-scroll should move back to start after it reaches the end. Autorscroll is available for CT_LISTBOX and CT_CONTROLS_GROUP types of controls only. Autoscroll will wait ctrlAutoScrollDelay seconds (must be  > 0) and then will scroll the scroll bar down to the bottom. ctrlAutoScrollSpeed defines the speed with which scrollbar is scrolled. If ctrlAutoScrollRewind is true, the control will fade out, immediately rewind to the top, then fade in, wait ctrlAutoScrollDelay seconds and then repeat the scrolling in a loop. If user focuses on the control, autoscrolling is interrupted.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlAutoScrollRewind(GameValue rightInstance)
        {
            return new GameValue(ctrlautoscrollrewind(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns number of seconds to auto-scroll one line. -1 if auto-scroll is disabled. -2 if scrollbar not present. Autoscroll is available for CT_LISTBOX and CT_CONTROLS_GROUP types of controls only. Autoscroll will wait ctrlAutoScrollDelay seconds (must be  > 0) and then will scroll the scroll bar down to the bottom. ctrlAutoScrollSpeed defines the speed with which scrollbar is scrolled. If ctrlAutoScrollRewind is true, the control will fade out, immediately rewind to the top, then fade in, wait ctrlAutoScrollDelay seconds and then repeat the scrolling in a loop. If user focuses on the control, autoscrolling is interrupted.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlAutoScrollSpeed(GameValue rightInstance)
        {
            return new GameValue(ctrlautoscrollspeed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns control's background color.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlBackgroundColor(GameValue rightInstance)
        {
            return new GameValue(ctrlbackgroundcolor(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current state of given CT_CHECKBOXES control. Since Arma 3 v1.72 it is possible to query multiple checkboxes by providing checkbox index. For more information see CT_CHECKBOXES.The "CheckBoxesSelChanged" control EH returns the control, index of changed checkbox and its current checked state. The checked state however is not a Boolean but Number 0 or 1. To convert ctrlChecked command output into number as well, use parseNumber command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlChecked(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlchecked(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the class name of a Control as it is defined in config. If you need config class of a game created Display, it is stored on display itself: _className = findDisplay 12 getVariable ["BIS_fnc_initDisplay_configClass", ""]; // "RscDiary"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CtrlClassName(GameValue rightInstance)
        {
            return new GameValue(ctrlclassname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Commits control animation to last specified duration. ⚠The duration of the animation is not guaranteed to be exactly the same as the given time.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlCommit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlcommit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if the control animation is finished.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlCommitted(GameValue rightInstance)
        {
            return new GameValue(ctrlcommitted(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a new control in the given display. The control class could be an existing class from the  main config or a custom class defined in the  mission config. The main config is searched first, if the class does not exist there, the mission config is searched. Some of the common controls defined in the main config that can be used with this command: Show list This list contains controls which are guaranteed to work with this command. However, controls not listed here should work as well - as long as they are properly defined. Class Description Available since RscText simple text box RscStructuredText text box which supports structured text RscTextMulti simple multiline text box RscPicture simple picture box RscPictureKeepAspect picture box that doesn't stretch picture RscEdit input box RscEditMulti multiline input box RscEditReadOnly input box with  canModify = false; 1.98 RscEditMultiReadOnly multiline input box with  canModify = false; 1.98 RscTree tree view control RscTreeMulti multi-select tree view 2.02 RscTreeSearch searchable tree view control (see Example 4) RscVideo picture control with autostart for video texture (see BIS_fnc_playVideo) RscVideoKeepAspect picture control for video to keep original video aspect ratio RscButtonMenuBIKI shortcut button with url pointing to "https://community.bistudio.com/wiki/" 1.98 RscControlsGroup default controls group RscControlsGroupNoScrollbars controls group without scrollbars RscControlsGroupNoHScrollbars controls group without horizontal scrollbar RscControlsGroupNoVScrollbars controls group without vertical scrollbar ⚠If you are creating CT_MAP control dynamically, use ctrlMapSetPosition to update control position instead of ctrlSetPosition.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue control</returns>
        public static GameValue CtrlCreate(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlcreate(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes given control. The control has to be created either by script with ctrlCreate or to have deletable property in config set to 1. Use ctrlShow false and ctrlEnable false to disable controls that cannot be deleted. Returns Boolean indicating  whether the deletion was successful. ⚠Using ctrlDelete in a UI eventhandler called by the to be deleted control will crash the game! This also happens when a controls group is deleted that contains the "calling" control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlDelete(GameValue rightInstance)
        {
            return new GameValue(ctrldelete(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables a control of the currently active user dialog. Disabled controls cannot be clicked onto. Read Arma: GUI Configuration for more information about user dialogs and controls.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlEnable(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlenable(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if a control on the currently active user dialog is enabled. Disabled controls cannot be focused. Read Arma: GUI Configuration for more information about user dialogs and controls.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlEnabled(GameValue rightInstance)
        {
            return new GameValue(ctrlenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current fade factor of control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlFade(GameValue rightInstance)
        {
            return new GameValue(ctrlfade(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns control's font size, usually sizeEx value (see ctrlSetFontHeight).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlFontHeight(GameValue rightInstance)
        {
            return new GameValue(ctrlfontheight(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns control's foreground color.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlForegroundColor(GameValue rightInstance)
        {
            return new GameValue(ctrlforegroundcolor(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true when HTML content was successfully loaded.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlHTMLLoaded(GameValue rightInstance)
        {
            return new GameValue(ctrlhtmlloaded(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns control IDC.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlIDC(GameValue rightInstance)
        {
            return new GameValue(ctrlidc(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns display IDD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlIDD(GameValue rightInstance)
        {
            return new GameValue(ctrlidd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds the next frame to the map animation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlMapAnimAdd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlmapanimadd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Clears the map animation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlMapAnimClear(GameValue rightInstance)
        {
            return new GameValue(ctrlmapanimclear(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Plays the map animation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlMapAnimCommit(GameValue rightInstance)
        {
            return new GameValue(ctrlmapanimcommit(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the map animation has finished.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlMapAnimDone(GameValue rightInstance)
        {
            return new GameValue(ctrlmapanimdone(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the default cursor that appears when interacting with a map control to a custom one. Use an empty string to restore the default cursor. ⚠Before Arma 3, if the specified cursor does not exist the default is used and no error is produced. In Arma 3, this would result in the following error: "No entry 'bin\config.bin/CfgWrapperUI/Cursors'". The cursor is the name of a config entry from CfgWrapperUI / Cursors. This command has the following specifics: When used on the Main Map (findDisplay 12 displayCtrl 51), it is possible to override multiple default cursors. For example, while leaving default "Arrow" intact, it is possible to just override "Scroll" with e.g "Wait" (See Example 3) When used on a custom map, for example user made Mini Map, there is only one single cursor "" for everything, therefore only this cursor can be overridden (see Example 4 on how to override it) Some possible class names (See ctrlMapCursor/cursors for the whole list): Arrow Track Move Scroll Rotate Track3D Move3D Rotate3D Raise3D Wait HC_move HC_overFriendly HC_overEnemy HC_overMission HC_unsel
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlMapCursor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlmapcursor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns description of map sign mouse cursor is over. Works with in-game map as well as 2D editor map in edit mode.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlMapMouseOver(GameValue rightInstance)
        {
            return new GameValue(ctrlmapmouseover(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for ctrlMapSetPosition. Returns map position in format [x, y, w, h]. If map is inside a Controls Group, the x and y position is relative to the Controls Group top left corner.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlMapPosition(GameValue rightInstance)
        {
            return new GameValue(ctrlmapposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current scale of given map control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlMapScale(GameValue rightInstance)
        {
            return new GameValue(ctrlmapscale(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts map screen coordinates into world coordinates. Unlike posScreenToWorld, this command returns world position is format [x, y], otherwise it is identical to posScreenToWorld.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlMapScreenToWorld(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlmapscreentoworld(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets position and size of the given map control and recalculates control center. The effect is immediate and no ctrlCommit is necessary, unlike with ctrlSetPosition command. The Map control is different from other controls and normally does not behave well inside Controls Groups. When this command is used on the Map control inside a Controls Group, The x and y will be treated as relative position to the top left of Controls Group. Use this command to set position before you use ctrlMapAnimAdd. Use this command to update Map control after its position or size had been changed or the Map control was created dynamically (Example 2). If you move Controls Group, use this command to refresh Map control (Example 3).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlMapSetPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlmapsetposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts world coordinates into map screen coordinates. This command is identical to posWorldToScreen.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlMapWorldToScreen(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlmapworldtoscreen(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns model used in 3D-Dialog.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CtrlModel(GameValue rightInstance)
        {
            return new GameValue(ctrlmodel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns vectorDir and vectorUp of the model used in 3D-Dialogs.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlModelDirAndUp(GameValue rightInstance)
        {
            return new GameValue(ctrlmodeldirandup(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns 3D control model scale.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlModelScale(GameValue rightInstance)
        {
            return new GameValue(ctrlmodelscale(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns position of the mouse on the screen relative to UI Control in UI coordinates. Also works within CT_CONTROLS_GROUPs. In that case, returned position is relative to the position of the group.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlMousePosition(GameValue rightInstance)
        {
            return new GameValue(ctrlmouseposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the parent Display of the given control. For parent Controls group see ctrlParentControlsGroup.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue display</returns>
        public static GameValue CtrlParent(GameValue rightInstance)
        {
            return new GameValue(ctrlparent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the parent control of a given child control. If the control is not part of a CT_CONTROLS_GROUP control then controlNull is returned. To return parent Display of the control use ctrlParent.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue control</returns>
        public static GameValue CtrlParentControlsGroup(GameValue rightInstance)
        {
            return new GameValue(ctrlparentcontrolsgroup(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current position of 2D control as [x, y, w, h] array. For 3D control it returns relative [x, y, z]. If the control is within a CT_CONTROLS_GROUP, the returned position will be relative to the group's position. If the control is a CT_CONTROLS_TABLE header or row the returned position is relative to the table's position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlPosition(GameValue rightInstance)
        {
            return new GameValue(ctrlposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove all event handlers from the given control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlRemoveAllEventHandlers(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlremovealleventhandlers(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove a given event handler from the given control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlRemoveEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlremoveeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current scale of the control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlScale(GameValue rightInstance)
        {
            return new GameValue(ctrlscale(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns scroll values for current scrollbars in range 0...1 (-1 if not applicable) for the following controls: CT_CONTROLS_TABLE CT_CONTROLS_GROUP CT_TREE CT_LISTBOX CT_COMBO CT_XCOMBO CT_LISTNBOX CT_LISTNBOX_CHECKABLE
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlScrollValues(GameValue rightInstance)
        {
            return new GameValue(ctrlscrollvalues(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets text color of given control when it is selected.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetActiveColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetactivecolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the rotation of a control set as ST_PICTURE. Rotation will be done within the control boundaries, so if the X and Y are given off center, the picture may get clipped by the control boundaries. Only requires ctrlCommit when fourth parameter is set to false. Procedural textures filled controls do not rotate. Supported control types: CT_STATIC CT_ACTIVETEXT (Since Arma 3 v2.09.149642) ⚠Images that touch borders may "bleed" during rotation transformation, to avoid this, make sure the image has 1px transparent padding
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetAngle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetangle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets number of second before auto-scroll starts/rewinds. Setter for ctrlAutoScrollDelay. Autorscroll is available for CT_LISTBOX and CT_CONTROLS_GROUP types of controls only. Autoscroll will wait ctrlAutoScrollDelay seconds (must be  > 0) and then will scroll the scroll bar down to the bottom. ctrlAutoScrollSpeed defines the speed with which scrollbar is scrolled. If ctrlAutoScrollRewind is true, the control will fade out, immediately rewind to the top, then fade in, wait ctrlAutoScrollDelay seconds and then repeat the scrolling in a loop. If user focuses on the control, autoscrolling is interrupted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetAutoScrollDelay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetautoscrolldelay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines if scroll should rewind when auto-scroll reach end. Setter for ctrlAutoScrollRewind. Autorscroll is available for CT_LISTBOX and CT_CONTROLS_GROUP types of controls only. Autoscroll will wait ctrlAutoScrollDelay seconds (must be  > 0) and then will scroll the scroll bar down to the bottom. ctrlAutoScrollSpeed defines the speed with which scrollbar is scrolled. If ctrlAutoScrollRewind is true, the control will fade out, immediately rewind to the top, then fade in, wait ctrlAutoScrollDelay seconds and then repeat the scrolling in a loop. If user focuses on the control, autoscrolling is interrupted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetAutoScrollRewind(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetautoscrollrewind(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets number of second required to scroll to next line. If speed < 0, auto-scroll is disabled. Setter for ctrlAutoScrollSpeed. Autorscroll is available for CT_LISTBOX and CT_CONTROLS_GROUP types of controls only. Autoscroll will wait ctrlAutoScrollDelay seconds (must be  > 0) and then will scroll the scroll bar down to the bottom. ctrlAutoScrollSpeed defines the speed with which scrollbar is scrolled. If ctrlAutoScrollRewind is true, the control will fade out, immediately rewind to the top, then fade in, wait ctrlAutoScrollDelay seconds and then repeat the scrolling in a loop. If user focuses on the control, autoscrolling is interrupted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetAutoScrollSpeed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetautoscrollspeed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets background color of given control. Only affects: CT_COMBO CT_STATIC CT_STRUCTURED_TEXT CT_MAP CT_MAP_MAIN 2.02 CT_BUTTON 2.02 CT_SHORTCUTBUTTON 2.02 CT_ACTIVETEXT
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetBackgroundColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetbackgroundcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets checked state of a CT_CHECKBOXES control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetChecked(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetchecked(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the colorDisabled attribute of a control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetDisabledColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetdisabledcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// 🕖The following information is obsolete as of Arma 2 v1.00. Reason: Use ctrlAddEventHandler instead as it can stack event handlers. Sets given event handler of given control: any previously added event handler is removed. See User Interface Event Handlers for the full list of handler names See also DIK KeyCodes for a list of key code constants relevant to key-related events like KeyDown and KeyUp ⚠When using the event names listed here with the ctrlAddEventHandler, ctrlSetEventHandler, displayAddEventHandler or displaySetEventHandler commands, the prefix "on" in the event name must be removed (e.g. 'ButtonDown' instead of 'onButtonDown').
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlseteventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets wanted transparency for control animation. Requires ctrlCommit to commit changes. To hide or show a control instantly, use ctrlShow.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFade(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfade(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the input focus on given control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFocus(GameValue rightInstance)
        {
            return new GameValue(ctrlsetfocus(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the font for given control (see available fonts)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFont(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfont(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H1 font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH1(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth1(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H1 bold font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH1B(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth1b(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H2 font of given HTML control
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH2(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth2(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H2 bold font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH2B(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth2b(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H3 font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH3(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth3(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H3 bold font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH3B(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth3b(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H4 font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH4(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth4(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H4 bold font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH4B(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth4b(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H5 font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH5(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth5(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H5 bold font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH5B(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth5b(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H6 font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH6(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth6(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H6 bold font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontH6B(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfonth6b(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the sizeEx property for most controls as follows:  CT_MAP - "sizeExNames" CT_HTML - "P" >> "sizeEx" Other - "sizeEx" 2.02 CT_STRUCTURED_TEXT - "size"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontHeight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontheight(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H1 font size of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontHeightH1(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontheighth1(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H2 font size of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontHeightH2(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontheighth2(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H3 font size of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontHeightH3(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontheighth3(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H4 font size of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontHeightH4(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontheighth4(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H5 font size of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontHeightH5(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontheighth5(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets H6 font size of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontHeightH6(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontheighth6(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the font size of the secondary text of given control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontHeightSecondary(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontheightsecondary(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets P font of given HTML control or its size.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontP(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontp(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets P bold font of given HTML control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontPB(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontpb(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the font size of the secondary text of given control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetFontSecondary(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetfontsecondary(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets foreground color of the given control. Also try ctrlSetTextColor, if this command doesn't have the desired effect.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetForegroundColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetforegroundcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets model for 3D-Dialogs (see Arma 3: createSimpleObject/objects for a p3d models' list).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetModel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetmodel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets orientation of 3D control model. It is similar to setVectorDirAndUp command for an object.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetModelDirAndUp(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetmodeldirandup(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets 3D control model scale
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetModelScale(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetmodelscale(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Similar to setMousePosition but relative to the given control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetMousePosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetmouseposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switches mode of pixel precision (rounding) in a given control interface.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetPixelPrecision(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetpixelprecision(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets wanted position and size for 2D control animation. Width and height are optional. ctrlCommit is required to complete the operation. For 3D control, param is relative [x, y, z] and no ctrlCommit is required as it cannot be animated. If target control is inside a CT_CONTROLS_GROUP, the position needs to be relative to it. ⚠This command doesn't work well with CT_MAP control. Use ctrlMapSetPosition instead.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the height of a 2D control. ctrlCommit is required to complete the operation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetPositionH(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetpositionh(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the width of a 2D control. ctrlCommit is required to complete the operation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetPositionW(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetpositionw(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets horizontal position (x) of the 2D control. ctrlCommit is required to complete the operation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetPositionX(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetpositionx(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets vertical position (y) of a 2D control. ctrlCommit is required to complete the operation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetPositionY(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetpositiony(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets scale of a control. Top left corner remains same. This command requires ctrlCommit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetScale(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetscale(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets scroll values for current scrollbars in range 0..1 for the following controls: CT_CONTROLS_TABLE CT_CONTROLS_GROUP CT_TREE CT_LISTBOX CT_COMBO CT_XCOMBO CT_LISTNBOX CT_LISTNBOX_CHECKABLE
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetScrollValues(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetscrollvalues(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets 'shadow' property of the control: 0 - no shadow 1 - shadow 2 - outline
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetShadow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetshadow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the Structured Text which will be displayed in structured text control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetStructuredText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsetstructuredtext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text of a control of the currently active user dialog or display. This command can be used for static texts, buttons, edit lines and active texts as well as for images, where you can use it to set the image path. Read Arma: GUI Configuration for more information about user dialogs and controls. Use endl to insert line breaks. Since Arma 3 v2.05.147765 supported control types are: CT_STATIC CT_EDIT CT_XKEYDESC CT_XBUTTON CT_SHORTCUTBUTTON CT_STRUCTURED_TEXT CT_BUTTON CT_ACTIVETEXT
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets text color of given control. Color is in format Color (RGBA). As of Arma 3 v1.40 this command can also be used to change fill-color of a CT_PROGRESS control. Also try ctrlSetForegroundColor, if this command doesn't have the desired effect.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetTextColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettextcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the secondary text color of a text control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetTextColorSecondary(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettextcolorsecondary(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the secondary text of a text control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetTextSecondary(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettextsecondary(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects length characters of edit control from the start position and places cursor at the end of selection. To only move the cursor, set length to 0. To select text from right to left, use negative length (See ctrlTextSelection for more info)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetTextSelection(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettextselection(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets tooltip text of given control. If control supports URL property, like RscActiveText for example, and the URL is set, tooltip text displayed on mouse over will be appended with URL text.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetTooltip(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettooltip(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets tooltip border color of given control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetTooltipColorBox(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettooltipcolorbox(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets tooltip background color of given control. Color is in format Color (RGBA).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetTooltipColorShade(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettooltipcolorshade(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets tooltip text color of given control. Color is in format Color (RGBA).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetTooltipColorText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettooltipcolortext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set maximum width of a control's tooltip.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlSetTooltipMaxWidth(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlsettooltipmaxwidth(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets URL property of the given control subject to allowedHTMLLoadURIs[] whitelisting in CfgCommands config. Supported controls are: CT_BUTTON CT_SHORTCUTBUTTON CT_ACTIVETEXT
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetURL(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlseturl(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets how to handle opening of URL, default browser ot Steam overlay. Possible values: 0 - default browser 1 - Steam overlay if enabled, otherwise default browser 2 - Steam overlay, shows error message box if disabled (the box has a button to continue with default browser) Toggling Steam overlay in Steam options will require game restart for the changes to take effect.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlSetURLOverlayMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlseturloverlaymode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns 'shadow' property of the control (see ctrlSetShadow).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlShadow(GameValue rightInstance)
        {
            return new GameValue(ctrlshadow(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows or hides a control. Read Arma: GUI Configuration for more information about user dialogs and controls.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtrlShow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrlshow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether given control is shown.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlShown(GameValue rightInstance)
        {
            return new GameValue(ctrlshown(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the provided control's style. See Arma: GUI Configuration - Control Styles.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlStyle(GameValue rightInstance)
        {
            return new GameValue(ctrlstyle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the text of a control of the currently active user dialog. This command can be used on static texts, buttons, edit lines and active texts as well as for images, where it returns the image path. Does not work on HTML control and returns empty string "". Since Arma 3 v2.05.147765 supported control types are: CT_STATIC CT_EDIT CT_XKEYDESC CT_XBUTTON CT_SHORTCUTBUTTON CT_STRUCTURED_TEXT CT_BUTTON CT_ACTIVETEXT
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CtrlText(GameValue rightInstance)
        {
            return new GameValue(ctrltext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns control's text color in Color (RGBA) format (see ctrlSetTextColor).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlTextColor(GameValue rightInstance)
        {
            return new GameValue(ctrltextcolor(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the control text height. Supported control types are: CT_STATIC CT_STRUCTURED_TEXT CT_EDIT Since Arma 3 v2.05.147765 control types added: CT_XKEYDESC CT_XBUTTON CT_SHORTCUTBUTTON CT_BUTTON CT_ACTIVETEXT
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlTextHeight(GameValue rightInstance)
        {
            return new GameValue(ctrltextheight(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the secondary text of a text control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CtrlTextSecondary(GameValue rightInstance)
        {
            return new GameValue(ctrltextsecondary(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns edit control text selection in format [start, length, selectedText].  length can be negative if text selection is made from right to left. Use abs with length or count with selectedText if string length is required. start always indicates at what position in text the selection is started. The cursor position will always be at the end of the selection. So if selection is made from right to left the cursor position will be at the left end of the selection. In order to find cursor position add start and length together (see Example 3).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtrlTextSelection(GameValue rightInstance)
        {
            return new GameValue(ctrltextselection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the width of the control text including left and right margins (0.008 each). Supported control types are: CT_STATIC 0 CT_EDIT 2 CT_STRUCTURED_TEXT 13 2.06 CT_XKEYDESC 40 2.06 CT_XBUTTON 41 2.06 CT_SHORTCUTBUTTON 16 2.06 CT_BUTTON 1 2.06 CT_ACTIVETEXT 11 For control-independent text width estimate see getTextWidth.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlTextWidth(GameValue rightInstance)
        {
            return new GameValue(ctrltextwidth(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the tooltip property of a button control. Getter for ctrlSetTooltip.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CtrlTooltip(GameValue rightInstance)
        {
            return new GameValue(ctrltooltip(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns number representing the type of control, which is also defined by type property in config. For more information see Arma: GUI Configuration
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlType(GameValue rightInstance)
        {
            return new GameValue(ctrltype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the URL property of a button control. Getter for ctrlSetURL.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CtrlURL(GameValue rightInstance)
        {
            return new GameValue(ctrlurl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the URL overlay mode 0, 1, 2 (see ctrlSetURLOverlayMode) or -1 if something went wrong.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtrlURLOverlayMode(GameValue rightInstance)
        {
            return new GameValue(ctrlurloverlaymode(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if a control of the currently active user dialog is shown or not. Read Arma: GUI Configuration for more information about user dialogs and controls.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CtrlVisible(GameValue rightInstance)
        {
            return new GameValue(ctrlvisible(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of controls on the row with the given index.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CtRowControls(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctrowcontrols(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns number of rows (headers not included) in the RscControlsTable.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtRowCount(GameValue rightInstance)
        {
            return new GameValue(ctrowcount(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects the line with the given index. Will take only rows, but not headers into account. -1 deselects all. Returns Nothing.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtSetCurSel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctsetcursel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Associates metadata (string) with the row determined by the index. Returns Nothing.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtSetData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctsetdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Takes config path to the new header template. Clears the whole RscControlsTable and sets the new header template.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtSetHeaderTemplate(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctsetheadertemplate(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Takes config path to the new row template. Clears the whole RscControlsTable and sets the new row template (Deleting all rows and headers is easier to implement than replacing the rows and filling them with new data. IDCs could overflow etc.).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtSetRowTemplate(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctsetrowtemplate(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Associates metadata (number) with the row determined by the index. Returns Nothing.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CtSetValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctsetvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns metadata (number) associated with a particular row of RscControlsTable.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CtValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ctvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns list of addons allowed to given curator. The addon names are not guaranteed to be all lower case
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CuratorAddons(GameValue rightInstance)
        {
            return new GameValue(curatoraddons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns curator camera object.
        /// </summary>
        /// <returns>GameValue object</returns>
        public static GameValue CuratorCamera()
        {
            return new GameValue(curatorcamera());
        }

        /// <summary>
        /// Returns all curator camera areas.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CuratorCameraArea(GameValue rightInstance)
        {
            return new GameValue(curatorcameraarea(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns ceiling height for curator camera.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CuratorCameraAreaCeiling(GameValue rightInstance)
        {
            return new GameValue(curatorcameraareaceiling(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current coeficient setting.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CuratorCoef(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(curatorcoef(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all editable objects which belong to a curator.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CuratorEditableObjects(GameValue rightInstance)
        {
            return new GameValue(curatoreditableobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all curator editing areas.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CuratorEditingArea(GameValue rightInstance)
        {
            return new GameValue(curatoreditingarea(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns type of edit areas assigned to curator (blacklist/whitelist).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue CuratorEditingAreaType(GameValue rightInstance)
        {
            return new GameValue(curatoreditingareatype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Curator Editable Object under curator mouse pointer.
        /// </summary>
        /// <returns>GameValue object</returns>
        public static GameValue CuratorMouseOver()
        {
            return new GameValue(curatormouseover());
        }

        /// <summary>
        /// Returns number of points that curator have. Points can be only in range from 0 to 1.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CuratorPoints(GameValue rightInstance)
        {
            return new GameValue(curatorpoints(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all objects that has curator registered and their settings.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CuratorRegisteredObjects(GameValue rightInstance)
        {
            return new GameValue(curatorregisteredobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns list of all curator selected items.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue CuratorSelected()
        {
            return new GameValue(curatorselected());
        }

        /// <summary>
        /// Return current price for placing waypoints (curator specific).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CuratorWaypointCost(GameValue rightInstance)
        {
            return new GameValue(curatorwaypointcost(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the currently performed editing operation in Eden Editor.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue Current3DENOperation()
        {
            return new GameValue(current3denoperation());
        }

        /// <summary>
        /// Returns currently selected user chat channel on the UI (selected with < and > in multiplayer). Channel ID number correspondence Default Channels Custom Channels Global Side Command Group Vehicle Direct CC 1 CC 2 CC 3 CC 4 CC 5 CC 6 CC 7 CC 8 CC 9 CC 10 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 For Custom Radio, see radioChannelCreate.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue CurrentChannel()
        {
            return new GameValue(currentchannel());
        }

        /// <summary>
        /// Return the current command type (empty string when no command) for the commander of given vehicle (or for a given soldier). Returned value can be one of: "WAIT" "ATTACK" "HIDE" "MOVE" "HEAL" "REPAIR" "REFUEL" "REARM" "SUPPORT" "JOIN" "GET IN" "FIRE" "GET OUT" "STOP" "EXPECT" "ACTION" "ATTACKFIRE" "Suppress"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CurrentCommand(GameValue rightInstance)
        {
            return new GameValue(currentcommand(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns class name of currently loaded vehicle's / unit's magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CurrentMagazine(GameValue rightInstance)
        {
            return new GameValue(currentmagazine(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns description of vehicle's currently loaded magazine, its ammo count (current/default) and its id.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CurrentMagazineDetail(GameValue rightInstance)
        {
            return new GameValue(currentmagazinedetail(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the class name of currently used magazine on specified turret. Use turret path [-1] for driver's turret. Note that a turret is not loaded until unit enters it, so this command will return "".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CurrentMagazineDetailTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(currentmagazinedetailturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of the type of the currently using magazine on specified turret. Use turret path [-1] for driver's turret. Note that a turret is not loaded until unit enters it, so this command will return "".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CurrentMagazineTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(currentmagazineturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a unit's current weapon muzzle. Does not work on vehicles.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CurrentMuzzle(GameValue rightInstance)
        {
            return new GameValue(currentmuzzle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current global namespace the script runs in. Since Arma 3 v2.00, Namespaces can be compared with == and != operators in addition to isEqualTo.
        /// </summary>
        /// <returns>GameValue namespace</returns>
        public static GameValue CurrentNamespace()
        {
            return new GameValue(currentnamespace());
        }

        /// <summary>
        /// Returns the person piloting the vehicle. If co-pilot is piloting, co-pilot is returned. If you need current pilot of a UAV or UGV, see UAVControl command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue CurrentPilot(GameValue rightInstance)
        {
            return new GameValue(currentpilot(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return current task of given person.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue task</returns>
        public static GameValue CurrentTask(GameValue rightInstance)
        {
            return new GameValue(currenttask(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all  uncompleted tasks for the given agent. getVariable could be used on Task to get the following special local variables from the task: "_this" Team Member - the teamMember agent the task is assigned to "_taskType" String - the name of the task (see registeredTasks) "_thisCreated" Number - 1 or 0 "_thisRunning" Number - 1 or 0 "_totalCreated" Number - total number of tasks "_totalRunning" Number - total number of running tasks "_task"Task - often null
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CurrentTasks(GameValue rightInstance)
        {
            return new GameValue(currenttasks(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns currently selected throwable, which will be launched if the user presses G.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CurrentThrowable(GameValue rightInstance)
        {
            return new GameValue(currentthrowable(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current vision mode of unit's weapon. Vision mode could be one of: 0 - normal vision 1 - night vision 2 - thermal vision Alternative syntaxes additionally return FLIR index (see setCamUseTI) of the thermal vision mode (See also  "VisionModeChanged" entity event handler)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CurrentVisionMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(currentvisionmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the index of the current waypoint contrary to misleading name. To determine the validity of the index, compare it to the waypoints count. If all waypoints are completed, then the index is 1 greater than the last valid index. If there are no waypoints, then the index is 0. By default, a group has 1 waypoint at their starting position, which is considered completed and so the currentWaypoint is 1.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue CurrentWaypoint(GameValue rightInstance)
        {
            return new GameValue(currentwaypoint(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the name of the currently selected weapon (on the primary turret for vehicles).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CurrentWeapon(GameValue rightInstance)
        {
            return new GameValue(currentweapon(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current weapon mode of unit's weapon. Result can be: "Single", "Burst", "FullAuto", "manual", "player" ⚠This command will return 0 Number if given object is a vehicle instead of a person. You can alternatively use _muzzle = weaponState player select 2;
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CurrentWeaponMode(GameValue rightInstance)
        {
            return new GameValue(currentweaponmode(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of the currently selected weapon on specified turret. Use turret path [-1] for driver's turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue CurrentWeaponTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(currentweaponturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current zeroing.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue CurrentZeroing(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(currentzeroing(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object under cursor. This command is quite different from cursorTarget as it is more precise in determining the boundaries of the pointed at object and can detect a larger variety of objects including map objects and trees.
        /// </summary>
        /// <returns>GameValue object</returns>
        public static GameValue CursorObject()
        {
            return new GameValue(cursorobject());
        }

        /// <summary>
        /// Returns the target pointed at by the player (usually with cross-hairs). The target has to be known to the player to some degree (knowsAbout > 0). If target is completely unknown, command returns objNull. A valid target could belong to an enemy or a friendly side. Buildings are normally known to player and so are valid targets. Try nearTargets to see what else is considered a target. While friendly targets are usually known to the player, enemy targets can be totally unknown, especially if "auto-spotting" (or sometimes called "auto-reporting") is switched off. To check if auto-spotting is enabled:difficultyEnabled "autospot" cursorTarget also returns locked target for the duration of the lock even if there is another target under the cursor. As soon as missile is fired, cursorTarget switches to current known target under cursor or objNull. Targeting (currently "T" in Arma 3) works regardless of the state of "auto-spotting". Adding a target to the known list could be done with reveal command. When auto-spotting is enabled, zooming on the enemy target with cross-hairs usually reveals the target. As friendly targets are always known, zooming on friendly target could improve knowsAbout value. Side Relations can also influence target knowledge. For example east target is unknown target for civilian, but making them friends with setFriend instantly improves civilian knowledge of the east.
        /// </summary>
        /// <returns>GameValue object</returns>
        public static GameValue CursorTarget()
        {
            return new GameValue(cursortarget());
        }

        /// <summary>
        /// Sends the chat message to the custom radio channel. The radio channel needs to be created on the server before hand, with radioChannelCreate command. ⚠The unit must have an assigned radio item (such as "ItemRadio") to see or transmit the messages. A radio item must have the property simulation = "ItemRadio"; in its CfgWeapons config.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CustomChat(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(customchat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sends the message to the custom radio channel. The message is defined in the description.ext file or radio protocol. ⚠The unit must have an assigned radio item (such as "ItemRadio") to see or transmit the messages. A radio item must have the property simulation = "ItemRadio"; in its CfgWeapons config. When transmitting unit gets killed, transmission will be interrupted. However when receiving unit gets killed, the transmission continues to play.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CustomRadio(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(customradio(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns player's custom waypoint (⇧ Shift + ) position.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue CustomWaypointPosition()
        {
            return new GameValue(customwaypointposition());
        }

        /// <summary>
        /// Terminates the effect in the given layer by fading it out according to the given duration. If named layer is used and it doesn't exist, it will be allocated. For title layer see titleFadeOut. For greater efficiency and ease of moddability, it is recommended to use named layers.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CutFadeOut(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(cutfadeout(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Displays an object defined in the global config in CfgTitles. For greater efficiency and ease of modability, it is recommended to use named layers with Syntax 3.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CutObj(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(cutobj(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Display a resource defined in RscTitles of the mission's Description.ext, the campaign's description.ext or the global config. For greater efficiency and ease of modability, it is recommended to use named layers available with String and Syntax 2. ⚠To avoid conflicts with existing layers it is recommended to register a layer with BIS_fnc_rscLayer and to start the name with a TAG: ("TAG_myLayer" call BIS_fnc_rscLayer) cutRsc ["myRsc", "PLAIN"]; "TAG_myLayer" cutRsc ["myRsc", "PLAIN"];
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CutRsc(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(cutrsc(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Displays a text message in the center of the screen. The text can be displayed on multiple lines by using "" new line characters: cutText ["line1line2line3", "PLAIN"]; For greater efficiency and ease of modability it is recommended to use named layers through the alternative syntax.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue CutText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(cuttext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the damage value of an object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Damage(GameValue rightInstance)
        {
            return new GameValue(damage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the actual in-mission date and time.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Date()
        {
            return new GameValue(date());
        }

        /// <summary>
        /// Convert a date to a float number, based on Jan 1st 00:00:00 = 0 and Dec 31st  23:59:59 = 1. The same day and time in leap year will be different after 28th of February and 23:59 on 31st of December will be 1.00274. This is how this command works. The 365 days of the year are presented in range 0...1. So each day will be: 1 / 365 = 0.00273973 In a leap year there are 366 days, so the range will increase by 1 day: 1 / 365 * 366 = 1.00274 In short, in a normal year the command returns in range 0...1 in a leap year it will return in range 0...1.00274.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue DateToNumber(GameValue rightInstance)
        {
            return new GameValue(datetonumber(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current in-game time in hours. For a formatted version of time, see BIS_fnc_timeToString.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue DayTime()
        {
            return new GameValue(daytime());
        }

        /// <summary>
        /// Deactivates the given keyname for the current user profile. The keys are used to unlock missions or campaigns. See keys, keysLimit and doneKeys in the description.ext file of the missions.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeActivateKey(GameValue rightInstance)
        {
            return new GameValue(deactivatekey(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns debriefing text of provided end.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue DebriefingText(GameValue rightInstance)
        {
            return new GameValue(debriefingtext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Dump (something about FSM) to debugging output. This command is (assumed to be) non-functional in the retail version. ⚠Non functional in retail
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DebugFSM(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(debugfsm(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Dump argument type and value to debugging output.  ⚠This command is non-functional in the retail version. Use diag_log instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DebugLog(GameValue rightInstance)
        {
            return new GameValue(debuglog(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Multiplies graph values by the given coefficient. The corresponding lower bound value is used instead if the product is smaller than the bound.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue DecayGraphValues(GameValue rightInstance)
        {
            return new GameValue(decaygraphvalues(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts given value in radians to degrees. 1 degree equals 0.01745 radians or pi / 180. 2 * pi ≙ 360° → 1 rad = 2 * pi / 360°
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Deg(GameValue rightInstance)
        {
            return new GameValue(deg(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Delete given entities in Eden Editor.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Delete3DENEntities(GameValue rightInstance)
        {
            return new GameValue(delete3denentities(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes array element at the given 0-based index and returns removed element (modifies the original array, just like resize or set). This command will not issue error when -1 index is passed making it ideal for using with find (see Example 2) or findIf (see Example 3).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue DeleteAt(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(deleteat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// In a nutshell, this command removes gaming Side (see createCenter). If a side has >0 Groups it cannot be deleted. Center can only be created for: east, west, resistance, civilian and sideLogic, therefore only centers from the mentioned sides can be deleted. Old description: Destroys the AI center of the given side.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteCenter(GameValue rightInstance)
        {
            return new GameValue(deletecenter(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Delete a collection. As example, used with a soldier, it'll hide the ingame model. When targetting Arma 2 1.06 or newer, use hideObject instead. This function is a relic from dynamic building destruction development. It is left only for compatibility with scripts created before Arma 2 1.06, and its functionality may be changed or removed in the future.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteCollection(GameValue rightInstance)
        {
            return new GameValue(deletecollection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Delete the editor object. Requires all editor object links to be removed prior.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue DeleteEditorObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(deleteeditorobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Destroys the given group - the group must be empty and local to the machine executing this command. In Arma 3 you can find out locality of the group with local command, unlike with previous games. However owner and setOwner don't work with groups anywhere. The group will always be local to the client that created it, until the client disconnects, then the group becomes local to the server. So if you need to delete a group, delete all members first then execute deleteGroup where is it local. In Arma 3 when the last unit leaves a group, the group gets automatically deleted. Manually deleting all units from a group, however, does not automatically delete the empty group. To force the group to get auto-deleted when empty, use deleteGroupWhenEmpty.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteGroup(GameValue rightInstance)
        {
            return new GameValue(deletegroup(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Marks given group for auto-deletion when group is empty. true will mark the group for auto-deletion once empty, false will simply unmark the group that was marked previously. ⚠This command does not prevent group deletion (through e.g deleteGroup or any engine group management).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteGroupWhenEmpty(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(deletegroupwhenempty(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes an identity created with saveIdentity from the campaign's progress file.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue DeleteIdentity(GameValue rightInstance)
        {
            return new GameValue(deleteidentity(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes scripted location.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteLocation(GameValue rightInstance)
        {
            return new GameValue(deletelocation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Destroys the given marker.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteMarker(GameValue rightInstance)
        {
            return new GameValue(deletemarker(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Destroys the given marker.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteMarkerLocal(GameValue rightInstance)
        {
            return new GameValue(deletemarkerlocal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes a range of array elements from the given array. Modifies the original array, just like resize or set.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteRange(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(deleterange(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Delete (unregister) resources of the team member. Resources are deleted in the order they were added. Case insensitive.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteResources(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(deleteresources(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes the site. ⚠This command is considered deprecated and is no longer supported
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteSite(GameValue rightInstance)
        {
            return new GameValue(deletesite(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes a status created with saveStatus from the campaign's progress file.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue DeleteStatus(GameValue rightInstance)
        {
            return new GameValue(deletestatus(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Destroy given team.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteTeam(GameValue rightInstance)
        {
            return new GameValue(deleteteam(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes an object. Only objects inserted in the mission editor and objects created during the game's progress can be deleted by this command. Terrain objects and players cannot be deleted. The actual object deletion, when the object becomes objNull, happens on the next frame after command execution, but there are some object modifications that happen immediately. For example if the object is a unit in a group, it immediately becomes groupless (isNull group _unit; // true).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteVehicle(GameValue rightInstance)
        {
            return new GameValue(deletevehicle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes a member of or the whole crew of a vehicle. Human players cannot be deleted. This command attempts to move the given crew member out before deleting it. Made especially for deleting dead crew members, as using conventional deleteVehicle leads to all sorts of bugs and ghost objects. While the argument is global, you should take extra steps and execute this where vehicle is local as moving units out of the vehicle happens where vehicle is local and you want this to always precede deletion.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteVehicleCrew(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(deletevehiclecrew(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes the specified waypoint. When a waypoint is deleted, all other group waypoints are immediately re-indexed. See Example 2 for a deletion of all group's waypoints. Deleting a group's current waypoint will not stop the group on its tracks.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DeleteWaypoint(GameValue rightInstance)
        {
            return new GameValue(deletewaypoint(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Detaches previously attached with attachTo object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Detach(GameValue rightInstance)
        {
            return new GameValue(detach(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of all mines detected by a given side
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue DetectedMines(GameValue rightInstance)
        {
            return new GameValue(detectedmines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with active Mission FSMs. To see number of all scripts currently in the scheduler use diag_activeScripts.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Diag_activeMissionFSMs()
        {
            return new GameValue(diag_activemissionfsms());
        }

        /// <summary>
        /// Returns 4 element array with numbers of currently running scripts in format: [spawn-ed, execVM-ed, exec-ed, execFSM-ed]
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Diag_activeScripts()
        {
            return new GameValue(diag_activescripts());
        }

        /// <summary>
        /// Returns information about active SQF scripts. To see number of all scripts currently in the scheduler use diag_activeScripts.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Diag_activeSQFScripts()
        {
            return new GameValue(diag_activesqfscripts());
        }

        /// <summary>
        /// Returns array with active SQSs. To see number of all scripts currently in the scheduler use diag_activeScripts.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Diag_activeSQSScripts()
        {
            return new GameValue(diag_activesqsscripts());
        }

        /// <summary>
        /// Returns an array with all mission event handlers.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Diag_allMissionEventHandlers()
        {
            return new GameValue(diag_allmissioneventhandlers());
        }

        /// <summary>
        /// Attempts to run given code with given arguments given number of cycles in unscheduled environment and returns average time it took to run the code as well as actual number of executions performed. The command will return as soon as possible if the tested code is slow and the duration of the command exceeds 1 second. Engine alternative to BIS_fnc_codePerformance.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Diag_codePerformance(GameValue rightInstance)
        {
            return new GameValue(diag_codeperformance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the duration of the previous frame in seconds
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Diag_deltaTime()
        {
            return new GameValue(diag_deltatime());
        }

        /// <summary>
        /// Ends dynamic simulation data gathering and writes collected data into given file. The file is saved in the Arma 3 installation folder. // Example output. Enabled time (in % of collection time)       Subject name   1.$                                          O Bravo 1-5   1.$                                          O Bravo 1-6   1.$                                          extraction_bike (B_Quadbike_01_F) - [3151,9662,59]   .....                                          ..................................   -1.$                                         O Bravo 1-4   -1.$                                         target_1 (O_SAM_System_04_F) - [3571,9878,70]   -1.$                                         O Alpha 3-4 Collection took 0.0s
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Diag_dynamicSimulationEnd(GameValue rightInstance)
        {
            return new GameValue(diag_dynamicsimulationend(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns average framerate calculated over last 16 frames.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Diag_fps()
        {
            return new GameValue(diag_fps());
        }

        /// <summary>
        /// Returns minimal framerate. Calculated from the longest frame over last 16 frames.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Diag_fpsmin()
        {
            return new GameValue(diag_fpsmin());
        }

        /// <summary>
        /// Returns number of frame currently displayed.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Diag_frameno()
        {
            return new GameValue(diag_frameno());
        }

        /// <summary>
        /// Allows loading of lighting config during the gameplay (effectively changing the current scene lighting). Filename path can be either absolute or relative. The file must contain only the class LightingNew, which should contain lighting configuration.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Diag_lightNewLoad(GameValue rightInstance)
        {
            return new GameValue(diag_lightnewload(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all localized keys from the given  stringtable or the array of all stringtables names if empty string "" is given. Common stringtables are: "Global", "Mission", "Campaign".
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Diag_localized(GameValue rightInstance)
        {
            return new GameValue(diag_localized(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Dumps the argument's value to the report file. Each call creates a new line in the file.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Diag_log(GameValue rightInstance)
        {
            return new GameValue(diag_log(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns script scope depth. When script is directly executed by the engine or a new script is added to the scheduler, the scope depth is 0. The examples of such execution are event handlers, spawn, etc. isNil Code will also create a parent scope. Any use of call and such will stack execution creating child scopes and increasing scope depth.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Diag_scope()
        {
            return new GameValue(diag_scope());
        }

        /// <summary>
        /// Overrides currently used scene lighting. The operand is config that is placed as a string (not file). The changes may not be applied immediately, but can be forced by the call of simulWeatherSync.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Diag_setLightNew(GameValue rightInstance)
        {
            return new GameValue(diag_setlightnew(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array containing the function name, line number, scope name and all local variables in form of a hashmap.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Diag_stacktrace()
        {
            return new GameValue(diag_stacktrace());
        }

        /// <summary>
        /// Real time in seconds spent from the start of the game. On Windows the command uses timeGetTime.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Diag_tickTime()
        {
            return new GameValue(diag_ticktime());
        }

        /// <summary>
        /// Tests whether any user dialog is open.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue Dialog()
        {
            return new GameValue(dialog());
        }

        /// <summary>
        /// A non-existent Diary Record. To compare non-existent objects use isNull or isEqualTo: diaryRecordNull == diaryRecordNull;		// false isNull diaryRecordNull;						// true diaryRecordNull isEqualTo diaryRecordNull;	// true Before Arma 3 v2.00, isNull did not work with the diary record type and diaryRecordNull did not exist. In order to verify a null record, it is possible to create a variable and compare against it: private _diaryRecordNull = objNull createDiaryRecord []; private _createdRecord = player createDiaryRecord ["Diary", ["Title", "Description"]]; if (_createdRecord isEqualTo _diaryRecordNull) then { hint "Failed"; };
        /// </summary>
        /// <returns>GameValue task</returns>
        public static GameValue DiaryRecordNull()
        {
            return new GameValue(diaryrecordnull());
        }

        /// <summary>
        /// Checks whether given subject is present in the Diary of given player.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue DiarySubjectExists(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(diarysubjectexists(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if the current client Joined In Progress.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue DidJIP()
        {
            return new GameValue(didjip());
        }

        /// <summary>
        /// Checks if the current owner of supplied Object Joined In Progress. Returns false on clients.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue DidJIPOwner(GameValue rightInstance)
        {
            return new GameValue(didjipowner(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns high-level selected difficulty mode.    Returned value will be: 0 (Recruit), 1 (Regular), 2 (Veteran) or 3 (Elite)
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Difficulty()
        {
            return new GameValue(difficulty());
        }

        /// <summary>
        /// Checks specific difficulty settings of the current user. Difficulty flag names can be found in the ArmA profile file under class Difficulties/xxx/Flags (xxx being regular or veteran).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue DifficultyEnabled(GameValue rightInstance)
        {
            return new GameValue(difficultyenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if Advanced Flight Model is enabled. Forcing of rotorlib simulation could be done with mission param forceRotorLibSimulation.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue DifficultyEnabledRTD()
        {
            return new GameValue(difficultyenabledrtd());
        }

        /// <summary>
        /// Checks specific difficulty settings of the current user. Difficulty flag names can be found in the CfgDifficultyPresets config class or in ArmA profile file under class DifficultyPresets/xxx/Options (xxx being Recruit, Regular or Veteran). This command replaces difficultyEnabled as many options have multiple values and former command only provided Boolean return.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue DifficultyOption(GameValue rightInstance)
        {
            return new GameValue(difficultyoption(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the direction an object or a location is facing (differs from getDir in that this also works with locations).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Direction(GameValue rightInstance)
        {
            return new GameValue(direction(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get state of direction stabilization. This command returns true if the current optic mode of the selected turret has direction stabilization configured in config (directionStabilized) and if it is also not disabled by enableDirectionStabilization. This command can not be used to determine if the current optic of the turret has directionStabilized enabled in config.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue DirectionStabilizationEnabled(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(directionstabilizationenabled(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sends given audio message to the direct channel. Command operates just like xxxxRadio commands, but the sound is played over direct channel and is independent of fadeSound. The message is defined in CfgRadio in the description.ext file or config radio protocol or a kbAddTopic. The transmission will play only on the PC where command was executed. If you need the transmission to play on all computers, you have to execute it globally (see remoteExec).  When transmitting unit gets killed, transmission will be interrupted. However when receiving unit gets killed, the transmission continues to play.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DirectSay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(directsay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Disables parts of the AI behaviour to get a better control over the actions of a unit. If the unit changes locality, this command might need to be executed again at the new locality to maintain effect. ⚠This command might cause unexpected behaviour when used on a player-controlled unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableAI(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(disableai(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Disables autobrake, which is engaged when vehicle is stationary and stops wheels from rotating freely when vehicle is pushed.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableBrakes(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(disablebrakes(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Disable collision between provided objects. The collision is always disabled for both objects in the arguments. ⚠ this command does not disable collision between PhysX objects this command has to be executed where objects are local, and as long as they do not change locality, the effect of this command will be global: if the two objects are not local to the same computer, then it has to be executed on both computers to achieve the desired effect if one or both objects change locality, the command needs to be executed again on the new owner's machine(s) to maintain the effect the feature works by having an object registering a reference to the other object; this command stores such reference on both objects - see Example 3
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableCollisionWith(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(disablecollisionwith(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// In theory disables the ability to talk to other people. In actuality, if true is given, the command increases unit's kbTell IsSpeaking status by 1, thus stopping unit from having a conversation. If false is given, the command decreases unit's kbTell IsSpeaking status by 1. The unit "is speaking" if IsSpeaking > 0.  ⚠kbTell IsSpeaking is a number that is increased or decreased by 1 internally. Default is 0, but it can be any positive or negative value. disableConversation allows to increase or decrease this number. When executed multiple times this can present an unexpected problem. Use conversationDisabled which returns true if this number > 0, to reset this number to 0 if necessary:  while {!conversationDisabled _unit} do {_unit disableConversation true}; while {conversationDisabled _unit} do {_unit disableConversation false};
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableConversation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(disableconversation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Disable debriefing score table. ⚠This command is broken.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableDebriefingStats()
        {
            return new GameValue(disabledebriefingstats());
        }

        /// <summary>
        /// Command allows suppressing visualization of FRIENDLY, ENEMY, MINES and/or PING map indicators from difficulty setting EXTENDED MAP CONTENT.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableMapIndicators(GameValue rightInstance)
        {
            return new GameValue(disablemapindicators(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables transport NV (Night Vision). To disable TI (Thermal Imaging) use disableTIEquipment.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableNVGEquipment(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(disablenvgequipment(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// This command will halt raycasting calculations (on the local machine only) for all groups which don't contain any local entities. Units, that are not in a group with at least one local member, will not check visibility of other units. This will cause, that remote units will not have updated knowsAbout and it will save some CPU time. If a group contains a single local entity then calculations will still be performed for the entire group. These raycasts are used to determine what other entities an entity can see, and they take a lot of CPU time. This is of course a bit of a trick, because rather than a true optimization, it disables part of the simulation. However, there are certainly types of scenarios where these raycasts are not needed. An example is a fully Player-versus-Player scenario, where the visibility between every combination of player entity is not needed. So why not disable this by default? There are cases where you do require these raycasts, for example in stealth scenarios. Without them, commands like knowsAbout, nearTargets and targetKnowledge will only function for local units! The commands themselves are local, can be used on servers and clients, and the state is reset when the scenario ends. So, carefully consider whether your scenario can benefit from this method.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableRemoteSensors(GameValue rightInstance)
        {
            return new GameValue(disableremotesensors(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Disable saving of script containing this command. After this, the script can work with data types which do not support serialization (UI types). See Namespace serialization for more information. ⚠In Arma 2 and up to a certain version of Arma 3, giving a Display or Control to spawned code would raise an error due to the usage of the then non-serializable _this variable. Using disableSerialization or uiNamespace wouldn't help; the trick here is to pass the argument inside an array: _display = findDisplay 46;  _display spawn { hint str _this; };				// would raise a serialization error [_display] spawn { hint str (_this select 0); };	// OK
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableSerialization()
        {
            return new GameValue(disableserialization());
        }

        /// <summary>
        /// Disables TI (Thermal Imaging) equipment for given vehicle. In older versions of Arma this command would also disable NV (Night Vision), but since Arma 3 v1.54 this command disables only TI. Use disableNVGEquipment to disable NV.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableTIEquipment(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(disabletiequipment(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Disables unit's AV terminal(s) connecting to UAV.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableUAVConnectability(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(disableuavconnectability(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Disables or enables the keyboard and mouse input. Usually used during cutscenes.⚠Be careful and responsible with the usage of this command. Once the user input is disabled, the only option left is to restart the game. Make sure you provide scripted mechanics to resolve this, should you need to disable user input for any reason.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisableUserInput(GameValue rightInstance)
        {
            return new GameValue(disableuserinput(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds an event handler to the given display. See User Interface Event Handlers for the full list of event names. If applicable, see DIK_KeyCodes for a list of key code constants, which are relevant to key related user interface events like: KeyDown & KeyUp. ⚠Display EHs are processed from last to first added; an input override should be set up in the first added EH. The event handler ID can be accessed inside the event handler code using the _thisEventHandler magic variable.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue DisplayAddEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(displayaddeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns child display of the given display.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue display</returns>
        public static GameValue DisplayChild(GameValue rightInstance)
        {
            return new GameValue(displaychild(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return child control with specified idc.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue control</returns>
        public static GameValue DisplayCtrl(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(displayctrl(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// A non-existing Display. To compare non-existent displays use isNull or isEqualTo: displayNull == displayNull;		// false isNull displayNull;					// true displayNull isEqualTo displayNull;	// true
        /// </summary>
        /// <returns>GameValue display</returns>
        public static GameValue DisplayNull()
        {
            return new GameValue(displaynull());
        }

        /// <summary>
        /// Returns parent display of the given display.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue display</returns>
        public static GameValue DisplayParent(GameValue rightInstance)
        {
            return new GameValue(displayparent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove all event handlers from the given display.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisplayRemoveAllEventHandlers(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(displayremovealleventhandlers(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove a given event handler from the given display.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisplayRemoveEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(displayremoveeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets given event handler of given display. The return code of the provided function should indicate whether this event was handled correctly. This implies telling the engine whether it is default code should be executed.  See User Interface Event Handlers for the full list of handler names. If applicable, see DIK KeyCodes for a list of key code constants, which are relevant to key related user interface events like onKeyDown and onKeyUp. ⚠When using the event names listed here with the ctrlAddEventHandler, ctrlSetEventHandler, displayAddEventHandler or displaySetEventHandler commands, the prefix "on" in the event name must be removed (e.g. 'ButtonDown' instead of 'onButtonDown').
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisplaySetEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(displayseteventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get the provided display's UI On Texture unique name. See findDisplay to get a Display by its unique name.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue DisplayUniqueName(GameValue rightInstance)
        {
            return new GameValue(displayuniquename(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the provided display to update its UI On Texture render.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DisplayUpdate(GameValue rightInstance)
        {
            return new GameValue(displayupdate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Dissolves the given team. All members become members of the main team.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DissolveTeam(GameValue rightInstance)
        {
            return new GameValue(dissolveteam(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a distance in meters between Objects, Positions or Locations. ⚠If positions are supplied as arguments, the coordinates are treated as PositionAGL. If Position2D is supplied, z is assumed 0. If you need distance between two Position3D coordinates, use vectorDistance.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Distance(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(distance(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a 2D distance (distance projected to X,Y plane) in meters between Objects and/or Positions.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Distance2D(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(distance2d(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Computes the squared distance between two objects or positions.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue DistanceSqr(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(distancesqr(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the numerical index for the distribution region of this copy of Armed Assault. USA Rest of the world
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue DistributionRegion()
        {
            return new GameValue(distributionregion());
        }

        /// <summary>
        /// Performs given Eden Editor action. ⚠Prior to Arma 3 2.12.150678 it was possible to use this command outside of Eden Editor. For example do3DENAction "MissionSave"; would wipe the mission.sqm without a way to restore it when executed accidentally during preview.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Do3DENAction(GameValue rightInstance)
        {
            return new GameValue(do3denaction(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders an artillery unit to fire a burst on the given position (silently).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoArtilleryFire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(doartilleryfire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to fire on the given target (without radio messages). The target is set with doTarget or commandTarget. The target can be a unit or a vehicle, but not an object.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoFire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(dofire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to follow another from his own group as his formation leader (without radio messages). It is also used to order the unit to return to formation after e.g doStop even if it is the leader himself that should return to formation (see Example 2).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoFollow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(dofollow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders a unit to process command defined by FSM file (silently).  Unlike with execFSM where _this is passed to the FSM, the following parameters are passed when using doFSM/commandFSM: _leader leader of subgroup with this command _destination command destination/position _target command target _units list of all persons in subgroup
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoFSM(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(dofsm(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders one or multiple units to get out from the vehicle (silently). Same as commandGetOut with latter being shown via radio chat. Notes: Works for both AI and player entities AI unit gets back in - unless is under player command or combined with other sqf commands (orderGetIn false, allowGetIn false or leaveVehicle) Ignores vehicle's lock state - unlike action "Eject" and moveOut AI waits for execution until vehicle has stopped/is no longer flying (unclear if any timeout exists for order to be discarded) - unlike action "Eject" and moveOut Plays the vehicle's position's get out animation (same as action "Eject") - unlike moveOut When execute for multiple units, it waits till the action is completed, before the next to take his turn (same as action "Eject") - unlike moveOut AI gets back into formation afterwards Works only on alive units - unlike action "Eject" (one after another) or moveOut (instantly) Does not work on unconscious - unless the AI is under player command. Unlike moveOut or action "Eject" (but one after another))
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoGetOut(GameValue rightInstance)
        {
            return new GameValue(dogetout(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to move to the given position (without radio messages). Upon reaching its destination, if it is the group leader it will order the group to form around it's new position. If it is not the leader, it will immediately be ordered to return to formation by the group leader and begin moving back to the group. Use doStop to stop units returning to formation. moveToCompleted will return true when a unit issued this command reaches its destination.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoMove(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(domove(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return animation phase of door on vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue DoorPhase(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(doorphase(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to stop (without radio messages). The units stopped in this way will leave the groups formation. It will prevent them from moving around with their group (or formation leader), while still being able to turn around and even move to a new position if they see fit. The units will still respond to orders from their group leader (like engage, rearm, board a vehicle), but all of their actions will be separate from the group formation. To resume group default behaviour, use doFollow command. For example: units _group doFollow leader _group;
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoStop(GameValue rightInstance)
        {
            return new GameValue(dostop(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Orders the given unit or a group of units to suppress the given position or target (without radio messages, see commandSuppressiveFire is you need messages).  When an Array of units is passed as param, only units from the same Group as the first unit in array are considered. The unit (units) starts firing at the given target or position random amount of shots (exact formula unknown, but seems to depend on amount of ammo unit has) after which it stops. currentCommand shows "Suppress" and there is no way of stopping unit before it completes random amount of rounds. If position is passed as target param, it stays fixed. If object is passed as target param, it depends on what kind of object. If it is considered a proper target by the unit, it is tracked by the unit dynamically. If it is not, the position gets obtained via getPosWorld, which could be different from PositionASL of the object, and it is fixed even if the target is able to change position later.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoSuppressiveFire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(dosuppressivefire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to target the given target (without radio messages).Targeting can be stopped by _unit doWatch objNull; or_unit commandWatch objNull;
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(dotarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order the given unit(s) to watch the given position or target (without radio messages). Use objNull as the target to order a unit to stop watching a position/target.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DoWatch(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(dowatch(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draws a single line arrow on the map. As this command needs to be called every frame, it is preferable using the onDraw UI Event Handler. To draw a color filled arrow of custom shape see BIS_fnc_drawArrow.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawArrow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawarrow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        ///  Draws an ellipse on the map. Just like with marker or trigger area, negative a and b will result in hexagon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawEllipse(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawellipse(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draws an icon on the map. As this command needs to be called every frame, it is preferable using the onDraw UI Event Handler. Some useful icons can be found in configFile >> "CfgVehicleIcons".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawIcon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawicon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draws an icon at the given position in the game world. This command has to be executed every frame. Use the Draw3D Mission Event Handler (which is executed every frame if the user can see the icon). In order for the results of this command to be visible through a custom camera, enable HUD with cameraEffectEnableHUD. showHUD false will hide the icon drawn by this command. In order for arrows to appear, the icon texture should exist. The arrow size is proportionate to the icon size. To avoid flickering and ensure visual fidelity, always use the visual (render time scope) variant of position commands, such as getPosASLVisual. The width and height parameters are multipliers for activeWidth and activeHeight set in config. So for example, if one needs to create an icon half the screen wide (safeZoneW / 2) and half the screen tall (safeZoneH / 2), divide these by the config values respectfully: private _iconWidth = (safeZoneW / 2) / getNumber (configFile >> "CfgInGameUI" >> "Cursor" >> "activeWidth"); private _iconHeight = (safeZoneH / 2) / getNumber (configFile >> "CfgInGameUI" >> "Cursor" >> "activeHeight");
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawIcon3D(GameValue rightInstance)
        {
            return new GameValue(drawicon3d(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draws a laserbeam and a lightpoint at the impact location of the laser. This command has to be executed every frame - see Arma 3: Mission Event Handlers - Draw3D. Lasers drawn with this command are subject to the same limitations as weapon attachment lasers. These limitations are defined in the CfgIRLaserSettings config class.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawLaser(GameValue rightInstance)
        {
            return new GameValue(drawlaser(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draw a line on the map. Can decrease framerate!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawLine(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawline(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draws a line of a given colour between two 3D positions in the current frame. To be used mostly in a "Draw3D" mission event handler.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawLine3D(GameValue rightInstance)
        {
            return new GameValue(drawline3d(rightInstance._internalGameValue));
        }

        /// <summary>
        /// The editor will draw a line between the two specified editor objects. Line type can be LINE or ARROW.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawLink(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawlink(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Used to draw locations in 2D Editor.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawLocation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawlocation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draws given polygon on the given map control with given color. The polygon must consist of at least 3 points. Unlike with other draw* commands and due to complexity, this command does not support filling of the polygon with color. Use drawTriangle command to construct and fill polygon shape as a workaround.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawPolygon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawpolygon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draws a rectangle on the map. 
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawRectangle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawrectangle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Draws one to multiple triangles on the map. When fill param is absent or is an empty string "", the triangle is drawn with lines of the color set in color param. In order to draw color-filled triangle of the same color as color param, set fill param to opaque white procedural texture"#(rgb,1,1,1)color(1,1,1,1)".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue DrawTriangle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(drawtriangle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the driver of a vehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue Driver(GameValue rightInstance)
        {
            return new GameValue(driver(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a particle effect. This command is used to create smoke, fire and similar effects. The particles are single polygons with single textures that always face the player. They can be set to dynamically change their position, size, direction, can be set to different weights and to be more or less dependent on the wind.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Drop(GameValue rightInstance)
        {
            return new GameValue(drop(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for setDynamicSimulationDistance.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue DynamicSimulationDistance(GameValue rightInstance)
        {
            return new GameValue(dynamicsimulationdistance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for setDynamicSimulationDistanceCoef
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue DynamicSimulationDistanceCoef(GameValue rightInstance)
        {
            return new GameValue(dynamicsimulationdistancecoef(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for enableDynamicSimulation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue DynamicSimulationEnabled(GameValue rightInstance)
        {
            return new GameValue(dynamicsimulationenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for enableDynamicSimulationSystem
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue DynamicSimulationSystemEnabled()
        {
            return new GameValue(dynamicsimulationsystemenabled());
        }

        /// <summary>
        /// Pre-defined variable for the eastern side.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue East()
        {
            return new GameValue(east());
        }

        /// <summary>
        /// Sends any text into the debugger console or the logfile. This command is only present in internal version  not in the retail version. Use diag_log instead!
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Echo(GameValue rightInstance)
        {
            return new GameValue(echo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Open a window with scenario attribute in given section.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Edit3DENMissionAttributes(GameValue rightInstance)
        {
            return new GameValue(edit3denmissionattributes(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Show the edit object dialog for the given object.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue EditObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(editobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets given event handler of given editor. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EditorSetEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(editorseteventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the effective commander of the vehicle. Effective commander is the player whom driver AI will listen to. So if in a tank there is a gunner and a commander and AI driver, if the effectiveCommander is gunner, then gunner pressing WASD will give AI orders to move. If gunner jumps out and then enters tank again, the effectiveCommander role most likely has changed to commander that remained in tank. Also the assignment seems to work on first come first served basis.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue EffectiveCommander(GameValue rightInstance)
        {
            return new GameValue(effectivecommander(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Elevates periscope of a vehicle. Vehicles in Arma 3 which are compatible with this tech are Strider, remote laser designators, the robot arm on Eddie, etc. Please note that SDV submarine has a different periscope, which is just an animated selection and could be raised and lowered with animate command. a user can immediately override any elevation in progress by using assigned keyboard keys. To block user input see the blockUserInput parameter. a PeriscopeElevationChanged entity event handler is also provided.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ElevatePeriscope(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(elevateperiscope(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the number of given empty positions in the vehicle. To return the actual units in the vehicle use fullCrew. However if only the number is desired, use emptyPositions because it is faster.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue EmptyPositions(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(emptypositions(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables parts of the AI behavior that was disabled by disableAI.  ⚠When player switches and leaves behind AI unit, you need to enable "TeamSwitch" AI on it _unit enableAI "TeamSwitch" so that the unit continues with waypoints Since Arma 3 v1.96 it is possible to return the state of the given AI flag via checkAIFeature or set it using alias command enableAIFeature
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableAI(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableai(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables/disables given AI feature.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableAIFeature(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableaifeature(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set whether animation's aim precision affects weapon sway.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableAimPrecision(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableaimprecision(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set if leader can issue attack commands to the soldiers in his group.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableAttack(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableattack(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable/disable an audio feature, features are: "lowpass", "building_interior". Since v2.14 it is possible to enable "building_interior" on an object placed in a building. When used on object in multiplayer, remoteExec the command globally with JIP queue enabled, for example [_obj, ["building_interior", true]] remoteExec ["enableAudioFeature", 0, _obj]; Since Arma 2.14 if 'enable' argument is omitted, the command returns the current state of the feature.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue EnableAudioFeature(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableaudiofeature(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggle availability of the automated helicopter start-up and shutdown sequences. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableAutoStartUpRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableautostartuprtd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggle auto-trim for RTD helicopters.  For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue EnableAutoTrimRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableautotrimrtd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Allows camera shake effects via addCamShake. If set to false, then a currently active shake effect will stop immediately. By default, shake effects are enabled, but once they have been disabled by this command, they will have to be enabled first, in order to be visible.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableCamShake(GameValue rightInstance)
        {
            return new GameValue(enablecamshake(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable/disable caustics drawing.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableCaustics(GameValue rightInstance)
        {
            return new GameValue(enablecaustics(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables/disables UI functionality which is responsible for sending text or voice chat to the given chat channel. This command: can override Description.ext or server.cfg's channel setting cannot disable Global channel for the admin or server host, because Global channel is always available for the admin does not disable incoming text or voice actively interrupts (since Arma 3 v2.02) the current communication in progress does not affect chat related scripting commands such as vehicleChat, globalRadio etc. Channel ID number correspondence Default Channels Custom Channels Global Side Command Group Vehicle Direct CC 1 CC 2 CC 3 CC 4 CC 5 CC 6 CC 7 CC 8 CC 9 CC 10 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableChannel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablechannel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Cancels the effects of disableCollisionWith. The collision is always enabled for both objects in the arguments, i.e. vehicle1 with vehicle2 and vehicle2 with vehicle1 ⚠Each object can contain only 1 reference to the object it disabled collision with. This command sets this reference to null. Therefore the command might not work as expected when trying to enable collisions with some objects but not other.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableCollisionWith(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablecollisionwith(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables copilot actions, toggles availability of the actions related to copilots, such as taking over controls, suspending controls, etc. This command triggers the "ControlsShifted" event handler.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableCopilot(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablecopilot(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable debriefing score table.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableDebriefingStats(GameValue rightInstance)
        {
            return new GameValue(enabledebriefingstats(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable or disable the legend for diagnostics. Internal dev only!
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableDiagLegend(GameValue rightInstance)
        {
            return new GameValue(enablediaglegend(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables / disables direction stabilization of turrets. This command only has an effect if the current optic mode of the selected turret has directionStabilized configured in config.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableDirectionStabilization(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enabledirectionstabilization(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables Arma 3: Dynamic Simulation for given non AI object.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableDynamicSimulation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enabledynamicsimulation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables the whole Arma 3: Dynamic Simulation system
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableDynamicSimulationSystem(GameValue rightInstance)
        {
            return new GameValue(enabledynamicsimulationsystem(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables the execution of a custom camera sequence after the players death, coded in onPlayerKilled.sqs.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableEndDialog()
        {
            return new GameValue(enableenddialog());
        }

        /// <summary>
        /// Enable/disable the artillery engine. This allows the user to use the artillery computer on mortar/artillery, and for AI to use it for indirect fire.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableEngineArtillery(GameValue rightInstance)
        {
            return new GameValue(enableengineartillery(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable/disable environmental effects: ambient life and/or ambient sound. This command has to be executed after mission start: be sure to use e.g sleep 0.1; for it to take effect. Influenced sounds among others are: bird sounds insect sounds waves wind rain sounds produced by air conditioners and similar 2.06 thunder (an already started sound will not be cut but future ones will be prevented)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableEnvironment(GameValue rightInstance)
        {
            return new GameValue(enableenvironment(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables/Disables the person's fatigue.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableFatigue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablefatigue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggles the target group's gun light(s).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableGunLights(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablegunlights(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Controls availability of component to given object info panel.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue EnableInfoPanelComponent(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableinfopanelcomponent(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Allows the AI to use IR lasers. Units should be in "Combat" behaviour.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableIRLasers(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableirlasers(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables/disables mimics on a given unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableMimics(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablemimics(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables firing from a vehicle cargo position. To get the turret path use assignedVehicleRole or getCargoIndex command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnablePersonTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablepersonturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable and disable radio messages to be heard and shown in the left lower corner of the screen - the order-giving unit can still be heard direct-talking when in its vicinity. The AI will still follow orders. This command can be helpful during cutscenes.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableRadio(GameValue rightInstance)
        {
            return new GameValue(enableradio(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable / disable reload when magazine is empty.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableReload(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablereload(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables the ability to be attached to a rope end for the given entity.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableRopeAttach(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableropeattach(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables/Disables satellite normal map or detail maps.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableSatNormalOnDetail(GameValue rightInstance)
        {
            return new GameValue(enablesatnormalondetail(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable / disable saving of the game with an optional autosave.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableSaving(GameValue rightInstance)
        {
            return new GameValue(enablesaving(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables radio transmissions to be heard and seen on screen. It does not affect KBTell conversations.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableSentences(GameValue rightInstance)
        {
            return new GameValue(enablesentences(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables / disables simulation for the given entity, e.g its animation and physics; it will still be able to take damage and report enemies. This command will affect entity simulation only locally. For a global and JIP enabled alternative, see enableSimulationGlobal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableSimulation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablesimulation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable or disable simulation for given entity, globally. Has the same effect as enableSimulation when used in singleplayer.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableSimulationGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablesimulationglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable/disable stamina system
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableStamina(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablestamina(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggles stress damage in  Advanced Flight Model, which otherwise could be manually toggles in game setting: Options > Game > Helicopter Flight Model > Advanced > Stress Damage. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableStressDamage(GameValue rightInstance)
        {
            return new GameValue(enablestressdamage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable / disable Team Switch. The default setting is enabled.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableTeamSwitch(GameValue rightInstance)
        {
            return new GameValue(enableteamswitch(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable ambient traffic. This command does nothing in Arma 3.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableTraffic(GameValue rightInstance)
        {
            return new GameValue(enabletraffic(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables unit's AV terminal(s) connecting to UAV.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableUAVConnectability(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableuavconnectability(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables/disables the option for player to set waypoints for UAV in AV terminal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableUAVWaypoints(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableuavwaypoints(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable/disable option to transport other vehicles (if configured) or be transported.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableVehicleCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablevehiclecargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable/disable given sensor
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableVehicleSensor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enablevehiclesensor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables disassembly of static weapons. Could be applied to local player, to another unit or to static weapon directly.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EnableWeaponDisassembly(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(enableweapondisassembly(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a string containing a line break, similar to lineBreak for text. The name is inspired by c++ std::endl (end line). The command returns "\r", which contains control characters rather than printable characters: hint str count "\r";	// 4 hint str count endl;	// 2 The line break works for diag_log and ctrlSetText. It does not work with the hint because hint interprets printable "" as line break instead. Alternatively one can use toString command to get other characters.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue Endl()
        {
            return new GameValue(endl());
        }

        /// <summary>
        /// Finishes loading screen started by startLoadingScreen. Use BIS_fnc_endLoadingScreen to prevent potential usage conflicts.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue EndLoadingScreen()
        {
            return new GameValue(endloadingscreen());
        }

        /// <summary>
        /// Finish the mission. Mission saves are deleted. Use failMission if they should not be. To maintain Arma 3 visual style, it is recommended to use BIS_fnc_endMission instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EndMission(GameValue rightInstance)
        {
            return new GameValue(endmission(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Activates and deactivates the engine of a vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EngineOn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(engineon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns which engines are producing some work. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EnginesIsOnRTD(GameValue rightInstance)
        {
            return new GameValue(enginesisonrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns power produced by engines in Watts. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EnginesPowerRTD(GameValue rightInstance)
        {
            return new GameValue(enginespowerrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all engines RPM.For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EnginesRpmRTD(GameValue rightInstance)
        {
            return new GameValue(enginesrpmrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Torque produced by engines in N·m (Newton × meter). For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EnginesTorqueRTD(GameValue rightInstance)
        {
            return new GameValue(enginestorquertd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of all alive and dead entities of the given type or deriving from the given type. Units in vehicles are ignored with the primary syntax. Optimisation tip: Keep number of types in both includeTypes and excludeTypes arrays to a minimum by possibly using parent/base classes.If you have to use several types, arrange them in order so that the more common types go at the beginning of the array.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Entities(GameValue rightInstance)
        {
            return new GameValue(entities(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns status of enableEnvironment command
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue EnvironmentEnabled()
        {
            return new GameValue(environmentenabled());
        }

        /// <summary>
        /// Returns the current environment volume (set by fadeEnvironment)
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue EnvironmentVolume()
        {
            return new GameValue(environmentvolume());
        }

        /// <summary>
        /// Returns current state for NVG and TI equipment availability.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EquipmentDisabled(GameValue rightInstance)
        {
            return new GameValue(equipmentdisabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Estimated end of MP game in seconds converted to serverTime.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue EstimatedEndServerTime()
        {
            return new GameValue(estimatedendservertime());
        }

        /// <summary>
        /// Sets the estimated time left in the game that is shown in the "Game in progress" screen or in the master browser. This command will force the server to broadcast serverTime to all clients without waiting for the next broadcast window (usually every 5 minutes).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue EstimatedTimeLeft(GameValue rightInstance)
        {
            return new GameValue(estimatedtimeleft(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return argument in mission editor of a given object.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue EvalObjectArgument(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(evalobjectargument(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of backpacks stored in given crate or vehicle. Used for accessing backpack content of a backpack on ground.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EveryBackpack(GameValue rightInstance)
        {
            return new GameValue(everybackpack(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of all containers (uniforms, vests, backpacks) stored in given crate or vehicle. Used for accessing containers content stored in ammo box or ground holder.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EveryContainer(GameValue rightInstance)
        {
            return new GameValue(everycontainer(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Execute a script using (the deprecated but still available) SQS Syntax. SQF Syntax (and execVM) is the most recent scripting language. The magic variable _time used within the script contains the elapsed time in seconds since the script started. To see the active SQS scripts currently in the scheduler, use diag_activeSQSScripts command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Exec(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(exec(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Execute an editor script for the specified object. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue ExecEditorScript(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(execeditorscript(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Execute scripted FSM and return the FSM handle or 0 when failed. The FSM file is first searched in the mission folder, then in the campaign scripts folder and finally in the global scripts folder. Argument (if any) are available in _this variable inside FSM. Variables set inside FSMs can be read/modified externally, using setFSMVariable and getFSMVariable commands. The return value is the FSM handle; it can be used to determine (via completedFSM) when the FSM has finished. In Arma 3, the FSM handle is also available within the FSM through the _thisFSM variable. Scripted FSMs are added into the scheduler just like exec scripts, execVM scripts and spawn scripts. To see what FSMs are currently in the scheduler, use diag_activeMissionFSMs command. ⚠While the code placed into any of the sections of FSM cannot be suspended (canSuspend is false), the FSM itself is suspended every simulation between the state's init and precondition (exception is the init state). This is the only place where scripted FSM is suspended/resumed. The usual difference between the state's init and precondition is 1 frame but if the scheduler is busy it can take longer. See FSM for more information about FSM's structure.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue ExecFSM(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(execfsm(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compiles and adds an SQF script to the scheduler queue and returns script handle (see also Example 4). The script does not execute immediately upon running execVM command but with some delay depending on the VM's scripts queue and engine load. If the same script is to be executed more than one time, declaring it as a Function is recommended to avoid recompiling and wasting performance with every execution. The script is searched for in the following directories in that order: mission directory campaign scripts directory global scripts directory. To see what VM scripts are currently in the scheduler, use diag_activeSQFScripts command. ⚠ The .sqf file extension is not mandatory but is strongly recommended as using non-standard extensions may cause problems during binarisation If the script file is not prepared using UTF-8 encoding and contains some characters with codes > 127, they might convert incorrectly.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue script</returns>
        public static GameValue ExecVM(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(execvm(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Stops the execution of a SQS script. It is ignored in SQF Scripts.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue Exit()
        {
            return new GameValue(exit());
        }

        /// <summary>
        /// Exits the current code scope. Often used for exiting do, for, count, forEach or the whole script. See Variables - Local Variables Scope for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue ExitWith(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(exitwith(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Exponential function with the base e. Equal to e^x.  See how green and blue are identical except for the offset
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Exp(GameValue rightInstance)
        {
            return new GameValue(exp(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return expected destination of unit as an array.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ExpectedDestination(GameValue rightInstance)
        {
            return new GameValue(expecteddestination(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Export list of JIP to a file. Special: BattlEye's RCON variant of this command is #exportJIPqueue (see also Multiplayer_Server_Commands)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ExportJIPMessages(GameValue rightInstance)
        {
            return new GameValue(exportjipmessages(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the direction object is watching (eyes, or a vehicle primary observer).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EyeDirection(GameValue rightInstance)
        {
            return new GameValue(eyedirection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object's eyes / main turret position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue EyePos(GameValue rightInstance)
        {
            return new GameValue(eyepos(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the face of a person.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Face(GameValue rightInstance)
        {
            return new GameValue(face(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets unit faction. Factions were introduced in Arma 2 and are defined under CfgFactionClasses. Side 1.00 1.50 1.96 west/blufor USMC CDF BIS_US BIS_CZ BIS_GER BIS_BAF (BAF DLC) BLU_F (NATO) BLU_G_F (FIA) BLU_T_F (Pacific NATO, Apex Expansion) BLU_CTRG_F (Pacific CTRG, Apex Expansion) BLU_GEN_F (Gendarmerie, Apex Expansion) BLU_W_F (Woodland NATO, Contact Expansion) east/opfor INS (ChDKZ) RU (Russia) BIS_TK (Takistan army) BIS_TK_INS (TK insurgents) OPF_F (Iranian CSAT) OPF_G_F (FIA) OPF_T_F (Chinese CSAT, Apex Expansion) OPF_R_F (Spetznatz, Contact Expansion) resistance/independent GUE (Guerilla) BIS_TK_GUE BIS_UN (United Nations) PMC_BAF (PMC DLC) IND_F (AAF) IND_G_F (FIA) IND_C_F (Syndikat, Apex Expansion) IND_E_F (LDF, Contact Expansion) IND_L_F (Looters, Contact Expansion) civilian CIV CIV_RU BIS_TK_CIV BIS_CIV_special CIV_F CIV_IDAP_F (Laws of War DLC) If a unit's faction is not defined in its config, an empty string is returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Faction(GameValue rightInstance)
        {
            return new GameValue(faction(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the master environment volume smoothly within the given time and is different from enableEnvironment global mute option. The default volume is 1. Influenced sounds, among others, are: forest sounds (birds, crickets, ...) waves wind rain object sounds (air conditioners, ...) 2.06 thunder
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FadeEnvironment(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(fadeenvironment(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the current music volume to the given value smoothly within the given time. The player's in-game setting is not changed by this command: Final Volume = Client Setting * Scripted Volume.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FadeMusic(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(fademusic(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the radio volume smoothly within the given time. The player's in-game setting is not changed by this command: Final Volume = Client Setting * Scripted Volume.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FadeRadio(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(faderadio(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the sound volume smoothly within the given time. The player's in-game setting is not changed by this command: Final Volume = Client Setting * Scripted Volume.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FadeSound(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(fadesound(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the master speech volume smoothly within the given time. The default volume is 1.0. Some of the sounds that play through speech channel are:  Tactical Ping sound playSound when isSpeech argument is true say3D when isSpeech argument is true
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FadeSpeech(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(fadespeech(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Finish the mission. If the server is set to run persistent mission, failMission will not end the mission when last player gets kicked to the lobby. Use endMission to end the mission. The end type can be: "CONTINUE" - this is default type, basically an alias to do nothing "KILLED" "LOSER" "END1" "END2" "END3" "END4" "END5" "END6" Mission saves won't be deleted. To maintain Arma 3 visual style, it is recommended to use BIS_fnc_endMission instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FailMission(GameValue rightInstance)
        {
            return new GameValue(failmission(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if file on given path exists. Uses same path resolve code as loadFile. Absolute paths are not supported, such as those generated using getMissionPath. Attempting to check an absolute path will result in this error in RPT logs: Invalid path (only relative paths supported): 'C:\...'
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue FileExists(GameValue rightInstance)
        {
            return new GameValue(fileexists(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds magazines from the campaign pool to the given unit, depending on his weapons. Available in campaigns only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FillWeaponsFromPool(GameValue rightInstance)
        {
            return new GameValue(fillweaponsfrompool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Searches for an array element within an array or an ANSI string within an ANSI string. If Unicode support is desired, see forceUnicode. ⚠Search is cASe-seNsItiVE!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Find(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(find(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the zero-based index of the first element in array A that also exists in array B. If no common elements exist it returns -1. Similar in functionality as find's first syntax, but the second parameter is an array of elements to find.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue FindAny(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(findany(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object around where the unit finds cover. The minDist, visibilityPosition and ignoreObject parameters are optional. ⚠Not implemented in Arma 2 and later titles (always returns objNull).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue FindCover(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(findcover(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Finds a display by its IDD which can either be defined in missionConfigFile (description.ext) or configFile (config.cpp) or by its UI On Texture's unique name (see displayUniqueName). If the specified display cannot be found, displayNull is returned. ⚠Dedicated servers and headless clients do not have a primary display (e.g findDisplay 46 will return displayNull). Detect both with the hasInterface command. For a list of (almost) all Arma 3's IDDs, see Arma 3: IDD List.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue display</returns>
        public static GameValue FindDisplay(GameValue rightInstance)
        {
            return new GameValue(finddisplay(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return object that matches the provided reference.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue FindEditorObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(findeditorobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Searches for an empty area around the specified position, starting from the center looking for an empty areaRadius and looks as far away as areaRadius + maxDistance. This command ignores moving objects present within the search area. The search area can be preloaded with findEmptyPositionReady command. This command does not work outside of world dimensions and will always return the provided center. Objects outside the world dimensions will not be considered in the detection either.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue FindEmptyPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(findemptyposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Preloads area to be used with findEmptyPosition command and returns true when area is ready. The size of the area preloaded is from center - radius - maxDistance to center + radius + maxDistance ⚠Preloading large areas may take a long time, we are talking minutes. However once preloaded, it stays preloaded even after mission restart.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue FindEmptyPositionReady(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(findemptypositionready(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Searches for an element within array for which the code evaluates to true. Returns the zero-based index on success or -1 if not found. Code on the right side of the command is evaluated for each element of the array, processed element can be referenced in code as _x. findIf terminates as soon as it finds an element that fulfills the condition, thus it is more efficient than count in scenarios where a check for presence / absence of at least one element should be done (See Example 2).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue FindIf(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(findif(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Finds the nearest enemy to the specified position. Returns a null object if the object's group does not know about any enemies. This command will return nearest object that is known to the unit and is considered enemy. An empty vehicle that is part of enemy group assets (see addVehicle) can be returned as valid nearest target.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue FindNearestEnemy(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(findnearestenemy(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Finish world initialization before mission is launched.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue FinishMissionInit()
        {
            return new GameValue(finishmissioninit());
        }

        /// <summary>
        /// Returns true if the provided number is finite (not infinite and a valid number).  Maximum finite Number : 3.40282e+38 Minimum finite Number : -3.40282e+38
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Finite(GameValue rightInstance)
        {
            return new GameValue(finite(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces a unit to fire the given weapon. Just like with forceWeaponFire it is possible to pass remote unit as argument, but this could be unreliable. Considering this command might need to be used in combination with selectWeapon, which takes only local arguments, it would make sense to execute the fire command where the unit is local as well.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Fire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(fire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remotely forces a unit to fire the given weapon. See also BIS_fnc_fire.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue FireAtTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(fireattarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the first stored backpack.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue FirstBackpack(GameValue rightInstance)
        {
            return new GameValue(firstbackpack(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the original flag pole of the flag the unit is carrying.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue Flag(GameValue rightInstance)
        {
            return new GameValue(flag(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns flag position on the flag pole.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue FlagAnimationPhase(GameValue rightInstance)
        {
            return new GameValue(flaganimationphase(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the global owner of a flag. A getter for setFlagOwner. Note that owner of a flag is Object rather than Number, as how it is usually with other owner commands
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue FlagOwner(GameValue rightInstance)
        {
            return new GameValue(flagowner(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Side of the local instance of the flag. A getter for setFlagSide.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue side</returns>
        public static GameValue FlagSide(GameValue rightInstance)
        {
            return new GameValue(flagside(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns texture of the local instance of the flag. A getter for setFlagTexture. It will not return flag textures applied using forceFlagTexture, use getForcedFlagTexture for that.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue FlagTexture(GameValue rightInstance)
        {
            return new GameValue(flagtexture(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Flattens an array.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Flatten(GameValue rightInstance)
        {
            return new GameValue(flatten(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if a unit is fleeing. Notes: Fleeing only affects AI led groups. Only the group as a whole can flee (or not). The courage of the AI group is based on the group's leader courage subskill. Each group has a max strength (summed "armor" of all infantry units - plus armor when inside vehicles). If the group losses by injury/damage or death/destruction are higher than the max strength, multiplied by leader's courage or allowFleeing level , then the group will start fleeing. As result primarily the AI flees to a nearby "supply point" (some friendly units - preferably with medic or engineer, or a vehicle with repair/ammo/fuel cargo). Alternatively it will try to find a safe position within a 600m radius from the initial waypoint (danger, distance, amount of cover positions are taken into account). After the fleeing has been finished the group's initial strength is reset. Fleeing units in combatMode red, will be set to yellow when fleeing to avoid engaging enemies while doing so. While fleeing, the group leader will be set to green, to avoid giving engage or fire orders, unless in combatMode blue already. Also speedMode is set to full. When reaching their flee point/destination, they will change to combatMode yellow and speedMode normal. With allowFleeing one can make unit's flee earlier (or essentially never flee). Apply it, overrides the courage subskill influence.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Fleeing(GameValue rightInstance)
        {
            return new GameValue(fleeing(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the next lowest integer in relation to the provided number.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Floor(GameValue rightInstance)
        {
            return new GameValue(floor(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the flying altitude for aircraft relatively to the ground surface. Avoid too low altitudes, as helicopters and planes won't evade trees and obstacles on the ground. The default flying altitude is 100 meters.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FlyInHeight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(flyinheight(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the minimal ASL height. Final height is flyInHeight max flyInHeightASL - the higher altitude has priority.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue FlyInHeightASL(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(flyinheightasl(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns display's focused control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue control</returns>
        public static GameValue FocusedCtrl(GameValue rightInstance)
        {
            return new GameValue(focusedctrl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for setFog. Returns the current value of the fog in range 0..1.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Fog()
        {
            return new GameValue(fog());
        }

        /// <summary>
        /// Returns the forecast fog value. A value of 0 means no fog, 1 means maximum fog.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue FogForecast()
        {
            return new GameValue(fogforecast());
        }

        /// <summary>
        /// A getter for setFog (Alt Syntax). Returns extended params for the fog
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue FogParams()
        {
            return new GameValue(fogparams());
        }

        /// <summary>
        /// Create a new uniform and hard link it into slot (without any restrictions).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceAddUniform(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(forceadduniform(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds force generator to world. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ForceAtPositionRTD(GameValue rightInstance)
        {
            return new GameValue(forceatpositionrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces showCadetHints and showCadetWP global Cadet Arma 3 difficulty, returns previous settings.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ForceCadetDifficulty(GameValue rightInstance)
        {
            return new GameValue(forcecadetdifficulty(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if map was forced by using forceMap command or openMap command with force option
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue ForcedMap()
        {
            return new GameValue(forcedmap());
        }

        /// <summary>
        /// Forces mission ending (set with endMission) even if a camera effect or any another condition delays the endMission (mostly in Operation Flashpoint).
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceEnd()
        {
            return new GameValue(forceend());
        }

        /// <summary>
        /// Forces a flag texture onto a flag carrier (unit, vehicle or flag pole). No flag holder is required. If "" is used as texture, the texture is removed. This will override regularly owned flags. This type of flag texture cannot be retrieved using flagTexture, but getForcedFlagTexture. ⚠Forced flag texture is an additional flag texture, which visually overrides original flag texture and therefore is very expensive to simulate, so use the functionality sparingly.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceFlagTexture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(forceflagtexture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces the vehicle to stay on road.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceFollowRoad(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(forcefollowroad(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds force generator to world. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ForceGeneratorRTD(GameValue rightInstance)
        {
            return new GameValue(forcegeneratorrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Opens non-interactive main map in background that overrides user screen. To force open interactive map use openMap command. ⚠When the map is forced open with this command, the user is still able to fire but cannot see the world, just the map. The map cannot be closed manually and the user can get stuck requiring a game restart. Make sure you provide scripted mechanics to de-force the map at a later stage.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceMap(GameValue rightInstance)
        {
            return new GameValue(forcemap(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces the unit to respawn. The effect is as if the player pressed the RESPAWN button in the game pause menu; the unit is killed but there is no "X was killed" message and no score adjustment.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceRespawn(GameValue rightInstance)
        {
            return new GameValue(forcerespawn(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Force the speed limit on given object (object will never attempt to move faster than given by forceSpeed). Use negative value to return to default behaviour.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceSpeed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(forcespeed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// List of the commands that work with forceUnicode: copyFromClipboard copyToClipboard count find in insert reverse select splitString trim regexFind regexMatch regexReplace Sets the Unicode flag which forces some of the string manipulation commands to switch to Unicode. The Unicode flag is always set right after forceUnicode command execution, but is reset depending on the command mode:  1 - the Unicode flag is reset right after any of the supported commands executed or the end of script, whichever comes earlier. 0 - the Unicode flag is reset at the end of the script. When the flag is set it will also affect all scopes within the script including child scopes (see diag_scope). There are many other string manipulation commands like ctrlSetText, getTextWidth, etc. that support Unicode by design so no additional forcing is needed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceUnicode(GameValue rightInstance)
        {
            return new GameValue(forceunicode(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces unit to walk even if run or sprint is selected.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceWalk(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(forcewalk(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// The unit will be forced to fire weapon from the given muzzle. The weapon will not fire if firemode passed as parameter is not supported by the given muzzle. The muzzle could belong to a vehicle weapon and unit in this case will be the unit operating this weapon. Doesnt't seem to work for units in FFV positions. Works on player. See also: BIS_fnc_fire
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceWeaponFire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(forceweaponfire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Will force-apply previously set settings. This might cause lag. To prevent the engine from overwriting custom weather settings, enable the Manual Control settings in Eden Editor's intel section.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForceWeatherChange()
        {
            return new GameValue(forceweatherchange());
        }

        /// <summary>
        /// Executes the given command recursively for both teams and agents that are members of the given team. For teams only use forEachMemberTeam. For agents only use forEachMemberAgent.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForEachMember(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(foreachmember(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Executes the given command recursively for each agent that is a member of the given team. For just teams use forEachMemberTeam. For both teams and agents use forEachMember.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForEachMemberAgent(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(foreachmemberagent(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Executes the given command recursively for each team that is a member of the given team. For just agents use forEachMemberAgent. For both teams and agents use forEachMember.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForEachMemberTeam(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(foreachmemberteam(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Resets the info a group has about a target, forcing knowsAbout value to 0.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ForgetTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(forgettarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Composes a string containing other variables or other variable types. Converts any variable type to a string. If you want to convert a string back to a number, use parseNumber. ⚠The output of this command is limited to ~8Kb. joinString on the other hand doesn't have such limit and is a bit faster.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Format(GameValue rightInstance)
        {
            return new GameValue(format(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current formation of a group.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Formation(GameValue rightInstance)
        {
            return new GameValue(formation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the direction in degrees of the 'unit' watching in formation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue FormationDirection(GameValue rightInstance)
        {
            return new GameValue(formationdirection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return leader of the formation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue FormationLeader(GameValue rightInstance)
        {
            return new GameValue(formationleader(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return list of units (drivers) in the formation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue FormationMembers(GameValue rightInstance)
        {
            return new GameValue(formationmembers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return position of unit in the formation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue FormationPosition(GameValue rightInstance)
        {
            return new GameValue(formationposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the current task of the unit in the formation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue FormationTask(GameValue rightInstance)
        {
            return new GameValue(formationtask(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a Structured Text similar to format command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue text</returns>
        public static GameValue FormatText(GameValue rightInstance)
        {
            return new GameValue(formattext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the formation leader of a given unit. This is often the same as the group leader, but not always, for example in cases when a unit is ordered to follow another unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue FormLeader(GameValue rightInstance)
        {
            return new GameValue(formleader(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unloads given extension loaded previously with callExtension so that extension developer could rapidly tweak developed extension without restarting the game. ⚠This command was introduced in Arma 3 dev v2.11.149751 and is only effective in DevBranch; it does nothing in stable branch.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool_nothing</returns>
        public static GameValue FreeExtension(GameValue rightInstance)
        {
            return new GameValue(freeextension(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if freelook is active on the current machine's controlled character.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue FreeLook()
        {
            return new GameValue(freelook());
        }

        /// <summary>
        /// Continue sequence of for construct. It sets the start value of the index variable.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue for</returns>
        public static GameValue From(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(from(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return if given team was inserted directly from mission editor. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue FromEditor(GameValue rightInstance)
        {
            return new GameValue(fromeditor(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks how much fuel is left in the gas tank of a vehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Fuel(GameValue rightInstance)
        {
            return new GameValue(fuel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array with all crew inside given vehicle, with or without empty seats. ⚠With the introduction of person turrets (FFV), the returned cargoIndex works with moveInCargo but does not with actions such as "GetInCargo" and "MoveToCargo". To find out indexes for actions, use the "cargo" filter (See Example 3).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue FullCrew(GameValue rightInstance)
        {
            return new GameValue(fullcrew(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns ammo count of assigned magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GearIDCAmmoCount(GameValue rightInstance)
        {
            return new GameValue(gearidcammocount(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns ammo count of assigned magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GearSlotAmmoCount(GameValue rightInstance)
        {
            return new GameValue(gearslotammocount(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns gear slot item name.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GearSlotData(GameValue rightInstance)
        {
            return new GameValue(gearslotdata(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of a unit's current gesture. Seems to be forced to lower case in Arma 3. This command is only for a man unit, other units such as animals cannot use this command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GestureState(GameValue rightInstance)
        {
            return new GameValue(gesturestate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Retrieves a value out of a HashMap after looking it up by its key.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue Get(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(get(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns state of given Eden Editor action.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Get3DENActionState(GameValue rightInstance)
        {
            return new GameValue(get3denactionstate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the value of the given entity's attribute in Eden Editor. An attribute is identified by its property (data when it is engine-drive attribute) value in config. For the list of all attributes with their properties, see Setting Attributes. ⚠Attributes are available only within the Eden Editor workspace. You cannot access them in scenario preview or exported scenario!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Get3DENAttribute(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(get3denattribute(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the camera Object used by the Eden Editor.
        /// </summary>
        /// <returns>GameValue object</returns>
        public static GameValue Get3DENCamera()
        {
            return new GameValue(get3dencamera());
        }

        /// <summary>
        /// Returns all connections currently present on an entity.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Get3DENConnections(GameValue rightInstance)
        {
            return new GameValue(get3denconnections(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Eden Entity based on its Eden ID.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue Get3DENEntity(GameValue rightInstance)
        {
            return new GameValue(get3denentity(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns unique index of an Eden Entity. This number remains the same even after saving and loading the scenario. This ID is only available in Eden Editor.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Get3DENEntityID(GameValue rightInstance)
        {
            return new GameValue(get3denentityid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the grid increment for the given transformation type.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Get3DENGrid(GameValue rightInstance)
        {
            return new GameValue(get3dengrid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets visibility state of Eden Editor icons.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Get3DENIconsVisible()
        {
            return new GameValue(get3deniconsvisible());
        }

        /// <summary>
        /// Return all entities and sub-layer in Eden Entity layer. In order to get all layer entities during a scenario use getMissionLayerEntities.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Get3DENLayerEntities(GameValue rightInstance)
        {
            return new GameValue(get3denlayerentities(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get visibility state of Eden Editor lines.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Get3DENLinesVisible()
        {
            return new GameValue(get3denlinesvisible());
        }

        /// <summary>
        /// Return value of scenario attribute. For a list of all available mission attributes see Mission Attributes. ⚠Attributes are available only within the Eden Editor workspace. You cannot access them in scenario preview or exported scenario!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue Get3DENMissionAttribute(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(get3denmissionattribute(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the Eden Entity the mouse is hovering over in Eden Editor.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Get3DENMouseOver()
        {
            return new GameValue(get3denmouseover());
        }

        /// <summary>
        /// Returns an array of all selected Eden Editor Entities of the given type. If a wrong type is provided, [[], [], [], [], [], []] is returned and an error message is shown.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Get3DENSelected(GameValue rightInstance)
        {
            return new GameValue(get3denselected(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get current aiming coefficient (higher ~ less precise, default is 1)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetAimingCoef(GameValue rightInstance)
        {
            return new GameValue(getaimingcoef(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array containing the names and values of environmental 2D sound controllers, variables that can be used in simple expressions when configuring sounds. ⚠ Controller names are case sensitive Wind param difference: wind is for 3D controller windy is for 2D controller (getAllEnvSoundControllers)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetAllEnv3DSoundControllers(GameValue rightInstance)
        {
            return new GameValue(getallenv3dsoundcontrollers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array containing the names and values of environmental 2D sound controllers, variables that can be used in simple expressions when configuring sounds. ⚠ Controller names are case sensitive Please note that the name for the wind param for 2D controller is 'windy', 'wind' being the name for the 3D controller getAllEnv3DSoundControllers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetAllEnvSoundControllers(GameValue rightInstance)
        {
            return new GameValue(getallenvsoundcontrollers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns 3 arrays for easy cross reference: 1st - array of hit point names, 2nd - array of hit selection names, 3rd - array of damage values. All values in all arrays are ordered accordingly to hit part index for convenience and for use in setHitIndex and getHitIndex. Levels of damage are: 0: no damage 1: full damage
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetAllHitPointsDamage(GameValue rightInstance)
        {
            return new GameValue(getallhitpointsdamage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets all mine objects this unit has ownership over.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetAllOwnedMines(GameValue rightInstance)
        {
            return new GameValue(getallownedmines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return an array with the vehicle's all pylons info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetAllPylonsInfo(GameValue rightInstance)
        {
            return new GameValue(getallpylonsinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array containing names and values of the sound controllers that can be used in simple expressions when configuring sounds.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetAllSoundControllers(GameValue rightInstance)
        {
            return new GameValue(getallsoundcontrollers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns unit traits, native or set by setUnitTrait.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetAllUnitTraits(GameValue rightInstance)
        {
            return new GameValue(getallunittraits(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the amount (1 is full) of ammo resources in the cargo space of a rearm vehicle. Since Arma 3 v1.96 the return value for vehicles that are not configured to have ability to rearm other vehicles is -1. (Prior to that the value was negative infinity)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetAmmoCargo(GameValue rightInstance)
        {
            return new GameValue(getammocargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns aim precision for current animation
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetAnimAimPrecision(GameValue rightInstance)
        {
            return new GameValue(getanimaimprecision(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get coefficient for animation speed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetAnimSpeedCoef(GameValue rightInstance)
        {
            return new GameValue(getanimspeedcoef(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Extract array from config entry.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetArray(GameValue rightInstance)
        {
            return new GameValue(getarray(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get list of all available magazines of artillery units on the list. Command returns only unique magazine types and doesn't contain any information about which unit has which magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetArtilleryAmmo(GameValue rightInstance)
        {
            return new GameValue(getartilleryammo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns settings from artillery computer currently opened by player.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetArtilleryComputerSettings()
        {
            return new GameValue(getartillerycomputersettings());
        }

        /// <summary>
        /// Returns ETA to the target in seconds for given artillery unit based on target position and used magazine, -1 if target can't be hit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetArtilleryETA(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getartilleryeta(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns DLC information about given object or model.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetAssetDLCInfo(GameValue rightInstance)
        {
            return new GameValue(getassetdlcinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns curator logic to which given player has access.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetAssignedCuratorLogic(GameValue rightInstance)
        {
            return new GameValue(getassignedcuratorlogic(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns unit assigned to curator logic.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetAssignedCuratorUnit(GameValue rightInstance)
        {
            return new GameValue(getassignedcuratorunit(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the target given unit is engaging.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetAttackTarget(GameValue rightInstance)
        {
            return new GameValue(getattacktarget(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns profile audio volumes.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetAudioOptionVolumes()
        {
            return new GameValue(getaudiooptionvolumes());
        }

        /// <summary>
        /// Returns all backpack types and count from the cargo space.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetBackpackCargo(GameValue rightInstance)
        {
            return new GameValue(getbackpackcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns how many seconds injured unit will continue leaving blood trail. If unit damage is < 0.1, the return value is 0 and unit doesn't leave any blood trail. Use setBleedingRemaining to set different remaining time.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetBleedingRemaining(GameValue rightInstance)
        {
            return new GameValue(getbleedingremaining(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns how much the unit is exposed to fire damage.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetBurningValue(GameValue rightInstance)
        {
            return new GameValue(getburningvalue(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if visibility of player by friendly units is calculated.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue GetCalculatePlayerVisibilityByFriendly()
        {
            return new GameValue(getcalculateplayervisibilitybyfriendly());
        }

        /// <summary>
        /// Returns the direction unit is looking in render time scope. While for AI the origin for the view direction vector can be taken from eyePos unit, for human player the origin should be taken from player camera position positionCameraToWorld [0,0,0]
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetCameraViewDirection(GameValue rightInstance)
        {
            return new GameValue(getcameraviewdirection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns index of the unit in cargo. -1 if not in cargo.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetCargoIndex(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getcargoindex(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns center of mass of an object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetCenterOfMass(GameValue rightInstance)
        {
            return new GameValue(getcenterofmass(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns client state in network game. Works on both, client and dedicated server. The following states are possible: getClientStateNumber getClientState Description 0 "NONE" No client (or singleplayer) 1 "CREATED" Client is created 2 "CONNECTED" Client is connected to server, message formats are registered 3 "LOGGED IN" Identity is created 4 "MISSION SELECTED" Mission is selected 5 "MISSION ASKED" Server was asked to send / not send mission 6 "ROLE ASSIGNED" Role was assigned (and confirmed) 7 "MISSION RECEIVED" Mission received 8 "GAME LOADED" Island loaded, vehicles received 9 "BRIEFING SHOWN" Briefing was displayed 10 "BRIEFING READ" Ready to play mission 11 "GAME FINISHED" Game was finished 12 "DEBRIEFING READ" Debriefing read, ready to continue with next mission
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue GetClientState()
        {
            return new GameValue(getclientstate());
        }

        /// <summary>
        /// Returns client state in network game. Works on both, client and dedicated server. The following states are possible: getClientStateNumber getClientState Description 0 "NONE" No client (or singleplayer) 1 "CREATED" Client is created 2 "CONNECTED" Client is connected to server, message formats are registered 3 "LOGGED IN" Identity is created 4 "MISSION SELECTED" Mission is selected 5 "MISSION ASKED" Server was asked to send / not send mission 6 "ROLE ASSIGNED" Role was assigned (and confirmed) 7 "MISSION RECEIVED" Mission received 8 "GAME LOADED" Island loaded, vehicles received 9 "BRIEFING SHOWN" Briefing was displayed 10 "BRIEFING READ" Ready to play mission 11 "GAME FINISHED" Game was finished 12 "DEBRIEFING READ" Debriefing read, ready to continue with next mission
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue GetClientStateNumber()
        {
            return new GameValue(getclientstatenumber());
        }

        /// <summary>
        /// Get array of compatible pylon magazines
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetCompatiblePylonMagazines(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getcompatiblepylonmagazines(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns UAV/UGV vehicle if person has connection to some UAV. To return the AI unit which player controls, see getConnectedUAVUnit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetConnectedUAV(GameValue rightInstance)
        {
            return new GameValue(getconnecteduav(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns UAV/UGV AI unit, which player is controlling. To return UAV vehicle, see getConnectedUAV
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetConnectedUAVUnit(GameValue rightInstance)
        {
            return new GameValue(getconnecteduavunit(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns max load value of given uniform, vest or backpack container. For other types of containers, use maxLoad command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetContainerMaxLoad(GameValue rightInstance)
        {
            return new GameValue(getcontainermaxload(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the corpse associated with given weaponholder. When unit is killed and had a weapon, the weapon is placed inside "WeaponHolderSimulated" and dropped together with the unit. This command returns the dead body associated with this weaponholder.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetCorpse(GameValue rightInstance)
        {
            return new GameValue(getcorpse(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns cruise control settings set with setCruiseControl command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetCruiseControl(GameValue rightInstance)
        {
            return new GameValue(getcruisecontrol(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns object and named selections under cursor and distance to object's surface (to the point cursor points at). If object surface is further away than 50 meters, selections are always an empty array and distance is 1e10 (10^10).
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetCursorObjectParams()
        {
            return new GameValue(getcursorobjectparams());
        }

        /// <summary>
        /// Returns aimPrecision from animation state with custom value that will directly affects weapon sway size and speed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetCustomAimCoef(GameValue rightInstance)
        {
            return new GameValue(getcustomaimcoef(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current value set to the controller (see setCustomSoundController).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetCustomSoundController(GameValue rightInstance)
        {
            return new GameValue(getcustomsoundcontroller(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current number of custom sound controllers supported by the engine for the given vehicle (currently 32)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetCustomSoundControllerCount(GameValue rightInstance)
        {
            return new GameValue(getcustomsoundcontrollercount(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object damage in the range from 0 to 1.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetDammage(GameValue rightInstance)
        {
            return new GameValue(getdammage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for setDebriefingText.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetDebriefingText(GameValue rightInstance)
        {
            return new GameValue(getdebriefingtext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the string representation of unit as an four slots array.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetDescription(GameValue rightInstance)
        {
            return new GameValue(getdescription(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object heading in the range 0..360. The alternative syntax gets heading from one object or position to another object or position, and should be used instead of BIS_fnc_dirTo.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getdir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns object's heading in the range from 0 to 360 in render time scope. The alternative syntax gets heading from one object or position to another object or position in render time scope, and should be used instead of BIS_fnc_dirTo.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetDirVisual(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getdirvisual(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true when object is in diver state - e.g when the unit would put diving goggles on. Diving goggles remove blurriness underwater, however when assigned, they do not appear on the face of the unit until the unit steps into the water. This command allows to detect the moment when the goggles are visible. If the unit doesn't have diving goggles assigned, this command would still return true at appropriate time if the unit steps into the water.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue GetDiverState(GameValue rightInstance)
        {
            return new GameValue(getdiverstate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of the DLC usage times.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetDLCAssetsUsage()
        {
            return new GameValue(getdlcassetsusage());
        }

        /// <summary>
        /// Returns an array with the session and global time the asset has been used.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetDLCAssetsUsageByName(GameValue rightInstance)
        {
            return new GameValue(getdlcassetsusagebyname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of app IDs of DLCs.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetDLCs(GameValue rightInstance)
        {
            return new GameValue(getdlcs(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns total time the assets of the given DLC have been used. See Arma 3 DLCs & Expansions for a list of DLCs and ids.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetDLCUsageTime(GameValue rightInstance)
        {
            return new GameValue(getdlcusagetime(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Fetches a reference to the mission editor camera. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetEditorCamera(GameValue rightInstance)
        {
            return new GameValue(geteditorcamera(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current mode of the editor. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetEditorMode(GameValue rightInstance)
        {
            return new GameValue(geteditormode(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the editor object scope of the specified editor object. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetEditorObjectScope(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(geteditorobjectscope(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the map elevation offset from [map]/config.cpp. Returns 0 if there is no elevationOffset defined in the config of the current world.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetElevationOffset()
        {
            return new GameValue(getelevationoffset());
        }

        /// <summary>
        /// Returns RPM of all engines. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetEngineTargetRPMRTD(GameValue rightInstance)
        {
            return new GameValue(getenginetargetrpmrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns value of the specified 3D controller, see getAllEnv3DSoundControllers.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetEnv3DSoundController(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getenv3dsoundcontroller(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns value of the specified controller, see getAllEnvSoundControllers
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetEnvSoundController(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getenvsoundcontroller(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Queries given event handler's information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetEventHandlerInfo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(geteventhandlerinfo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns fatigue of given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetFatigue(GameValue rightInstance)
        {
            return new GameValue(getfatigue(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of the starting topic and hint the given field manual should display.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetFieldManualStartPage(GameValue rightInstance)
        {
            return new GameValue(getfieldmanualstartpage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for forceFlagTexture. Forced texture is different from your normal flag texture, which can be retrieved with flagTexture
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetForcedFlagTexture(GameValue rightInstance)
        {
            return new GameValue(getforcedflagtexture(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns forced speed set with forceSpeed or -1 if not set.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetForcedSpeed(GameValue rightInstance)
        {
            return new GameValue(getforcedspeed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if sides are friendly or hostile. For a value smaller than 0.6 it results in being enemy, otherwise it is friendly. See also Side Relations.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetFriend(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getfriend(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the value of variable in the variable space of given FSM. The FSM handle is the number returned by the execFSM command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue GetFSMVariable(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getfsmvariable(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the fuel amount (1 is full) in the cargo space of a refueling vehicle. Since Arma 3 v1.96 the return value for vehicles that are not configured to have ability to refuel other vehicles is -1. (Prior to that the value was negative infinity)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetFuelCargo(GameValue rightInstance)
        {
            return new GameValue(getfuelcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Generate graph y - coordinates of all input values within specific x and y range.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetGraphValues(GameValue rightInstance)
        {
            return new GameValue(getgraphvalues(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get group icon properties.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetGroupIcon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getgroupicon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns group icons params used for command bar drawing such as color, text, scale, visibility, waypoint visibility, waypoint color.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetGroupIconParams(GameValue rightInstance)
        {
            return new GameValue(getgroupiconparams(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all group icons. [id,icon,[offsetx,offsety],[..],..]
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetGroupIcons(GameValue rightInstance)
        {
            return new GameValue(getgroupicons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the Position where object believes the enemy to be. If there is no direct line of sight between the object and the enemy, this position is extrapolated based on the last known position and speed of the enemy. A returned position of [0,0,0] implies that object does not knowAbout enemy. If enemy is null it is some position in front of the object or enemy position.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetHideFrom(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(gethidefrom(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns selection damage. Same as getHitPointDamage, only the argument is selection part instead of hit point. Some part names are in Czech; see the translation table.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetHit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(gethit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return current level of damage for a specific Hit Point (specified by its hit part index). All hit points can be obtained with getAllHitPointsDamage command. 0: no damage 1: full damage
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetHitIndex(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(gethitindex(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return current level of damage in range 0..1 for a specific Hit Point (specified by its config class). If you need to get damage of a selection instead of hit point, use getHit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetHitPointDamage(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(gethitpointdamage(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all items names and count from ammo box (or any general weapon holder container).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetItemCargo(GameValue rightInstance)
        {
            return new GameValue(getitemcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets general environment's light settings.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetLighting()
        {
            return new GameValue(getlighting());
        }

        /// <summary>
        /// Gets provided object's lighting information. The command will use local player's night vision state to determine whether to include IR lights in the result or not. On a dedicated server, headless client or if the player is null, the night vision state will always be off.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetLightingAt(GameValue rightInstance)
        {
            return new GameValue(getlightingat(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns information about all loaded modifications. The first 7 values are equal to what is printed in RPT on game startup in the ======== mods ======= category.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetLoadedModsInfo()
        {
            return new GameValue(getloadedmodsinfo());
        }

        /// <summary>
        /// Returns all magazines types and count from the cargo space
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetMagazineCargo(GameValue rightInstance)
        {
            return new GameValue(getmagazinecargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns marker color for given marker. This command is identical to markerColor.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetMarkerColor(GameValue rightInstance)
        {
            return new GameValue(getmarkercolor(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns marker position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetMarkerPos(GameValue rightInstance)
        {
            return new GameValue(getmarkerpos(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the size of the given marker. A getter for setMarkerSize and an alias of markerSize.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetMarkerSize(GameValue rightInstance)
        {
            return new GameValue(getmarkersize(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets type of marker. See CfgMarkers for a list of standard markers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetMarkerType(GameValue rightInstance)
        {
            return new GameValue(getmarkertype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns mass of a PhysX object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetMass(GameValue rightInstance)
        {
            return new GameValue(getmass(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Config entry for the given scenario attribute from the 1st tier. The attribute can be config class or config property. If it is defined in multiple places, the command checks them in the following order: External Description.ext file Eden Editor scenario attribute So if attribute exists in both places, attribute from description.ext is used. Previously, scenario attributes were extracted from Description.ext using missionConfigFile. That still works, but it ignores attributes set directly in the editor and it should not be used anymore.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue config</returns>
        public static GameValue GetMissionConfig(GameValue rightInstance)
        {
            return new GameValue(getmissionconfig(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns value of the given scenario attribute from the 1st tier. Since only config properties have values, the attribute should be config property. If it is not found or config class is given, the return is nil. If the attribute defined in multiple places, the command checks them in the following order: External Description.ext file Eden Editor scenario attribute So if attribute exists in both places, attribute from description.ext is used. Previously, scenario attributes were extracted from Description.ext using missionConfigFile. That still works, but it ignores attributes set directly in the editor and it should not be used anymore. ⚠This command cannot force return type, it will return the value of the type given in config. Use isEqualType to additionally reaffirm the correct type if necessary to account for human error.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array_string</returns>
        public static GameValue GetMissionConfigValue(GameValue rightInstance)
        {
            return new GameValue(getmissionconfigvalue(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns list of DLCs that are used in the mission. ⚠The list is created from units listed in mission.sqm and does not detect units later created by scripts.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetMissionDLCs()
        {
            return new GameValue(getmissiondlcs());
        }

        /// <summary>
        /// Returns all entities within the specific Eden Editor layer and its sub-layers. To be used when the scenario is running, not in the editor workspace. Useful to disable/enable whole parts of the scenario if layers are used during mission design. Default layers are not returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetMissionLayerEntities(GameValue rightInstance)
        {
            return new GameValue(getmissionlayerentities(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of all layers created in Eden Editor. Designed to be used during a scenario. Default layers (BLUFOR, OPFOR...) are not returned.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetMissionLayers()
        {
            return new GameValue(getmissionlayers());
        }

        /// <summary>
        /// Returns mission root plus the filename in a form of filepath to be used with commands requiring absolute path such as playSound3D, drawIcon3D, createSimpleObject, etc. Any leading "\" in the filename will be stripped as the mission root includes one already.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetMissionPath(GameValue rightInstance)
        {
            return new GameValue(getmissionpath(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns object's model info. Model path is suitable for use with createSimpleObject command. Since Arma 3 v2.08.148608 the command also returns placing point of the model in model coordinates. Placing point is always in format [0,0,z].
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetModelInfo(GameValue rightInstance)
        {
            return new GameValue(getmodelinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns mouse position in UI coordinates.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetMousePosition()
        {
            return new GameValue(getmouseposition());
        }

        /// <summary>
        /// Returns elapsed time in seconds for currently playing music track.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetMusicPlayedTime()
        {
            return new GameValue(getmusicplayedtime());
        }

        /// <summary>
        /// Extract number from config entry.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetNumber(GameValue rightInstance)
        {
            return new GameValue(getnumber(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return name of object argument in mission editor. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetObjectArgument(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getobjectargument(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return a list of all the children of the specified object. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetObjectChildren(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getobjectchildren(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns appID of the DLC the object belongs to or nil if object is vanilla.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetObjectDLC(GameValue rightInstance)
        {
            return new GameValue(getobjectdlc(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Field of View of the given object in radians. Static objects return default value, which is 1. FOV of objNull is 0. Object FOV is indirectly connected with optics magnification or player view zoom, the narrower the angle the greater the zoom. The FOV returned by this command doesn't change if user has custom FOV set in profile. Use it in combination with getResolution to adjust for the difference if required.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetObjectFOV(GameValue rightInstance)
        {
            return new GameValue(getobjectfov(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Visitor ID of the given object. Visitor IDs of static map objects can change if map is in development and updated with new static objects.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetObjectID(GameValue rightInstance)
        {
            return new GameValue(getobjectid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets all custom materials associated with the object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetObjectMaterials(GameValue rightInstance)
        {
            return new GameValue(getobjectmaterials(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the proxy object associated with the given editor object. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetObjectProxy(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getobjectproxy(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the render scale of the object relative to the original model.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetObjectScale(GameValue rightInstance)
        {
            return new GameValue(getobjectscale(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets all custom textures (hiddenSelectionsTextures) associated with the object. ⚠It will return an empty Array when executed on simple objects.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetObjectTextures(GameValue rightInstance)
        {
            return new GameValue(getobjecttextures(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns object type as a number: 1 - Primary - Normal object placed in Visitor, part of landscape 2 - Network - Road placed in Visitor, part of landscape 4 - Temporary - Temporary object (like tracks) 8 - TypeVehicle - Some entity added by game 16 - TypeTempVehicle - Temporary entity 32 - LandDecal - Land decal
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetObjectType(GameValue rightInstance)
        {
            return new GameValue(getobjecttype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the values of rendering distances of objects and shadows.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetObjectViewDistance()
        {
            return new GameValue(getobjectviewdistance());
        }

        /// <summary>
        /// Returns the class name of the current optic mode of the current weapon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetOpticsMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getopticsmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Retrieves a value out of a HashMap after looking it up by its key. When the HashMap doesn't contain the key, the default value is returned
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue GetOrDefault(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getordefault(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Retrieves a value from the HashMap for the given 'key', executes given 'code' if key was not found and returns result. Additionally sets key to the code result value if 'set' is true.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue GetOrDefaultCall(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getordefaultcall(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns amount of remaining oxygen.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetOxygenRemaining(GameValue rightInstance)
        {
            return new GameValue(getoxygenremaining(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of all DLCs objects the unit is currently using. For example if a unit is inside a vehicle from DLC, it will return the code of that DLC.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPersonUsedDLCs(GameValue rightInstance)
        {
            return new GameValue(getpersonuseddlcs(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns model space vector of the object airplane or helicopter pilotCamera .
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPilotCameraDirection(GameValue rightInstance)
        {
            return new GameValue(getpilotcameradirection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns model space coordinates of the object airplane or helicopter pilotCamera.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPilotCameraPosition(GameValue rightInstance)
        {
            return new GameValue(getpilotcameraposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns rotation (relative to the centered camera position) of the object airplane or helicopter pilotCamera .
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPilotCameraRotation(GameValue rightInstance)
        {
            return new GameValue(getpilotcamerarotation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the target of the object airplane or helicopter pilotCamera tracking.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPilotCameraTarget(GameValue rightInstance)
        {
            return new GameValue(getpilotcameratarget(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get the set PiP (Picture-in-Picture) view distance (that can be set by setPiPViewDistance).
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetPiPViewDistance()
        {
            return new GameValue(getpipviewdistance());
        }

        /// <summary>
        /// Get the license plates from any vehicle which has plates configured.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetPlateNumber(GameValue rightInstance)
        {
            return new GameValue(getplatenumber(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns channel number for given player, provided that player is speaking, otherwise -1. Having mic on is not enough, player has to make a sound. There are several limitations to this command: It does not work on dedicated server, the return is always -1, only client can detect other client talking. Prior to Arma 3 v2.01.146856 did not detect when someone talked on direct chat at all anywhere. The client on which command is executed has to able to receive transmission before the transmission channel can be detected. For example if a player is not in the same group as a speaker and the speaker speaks on Group Channel, the player cannot hear the speaker and therefore cannot detect what channel the speaker is on. In short, this command mimics the speaking icon from the UI. Correspondence between channel and number: channel ID number correspondence N/A Global Side Command Group Vehicle Direct Custom1 Custom2 Custom3 Custom4 Custom5 Custom6 Custom7 Custom8 Custom9 Custom10 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetPlayerChannel(GameValue rightInstance)
        {
            return new GameValue(getplayerchannel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns user DirectPlay ID, which can be used with getUserInfo, and is found in allMapMarkers results and in some mission event handlers such as PlayerConnected.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetPlayerID(GameValue rightInstance)
        {
            return new GameValue(getplayerid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// In MP: Returns the unit's table of scores (infantry kills, soft vehicle kills, armor kills, air kills, deaths, total score). In SP: Empty array []
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPlayerScores(GameValue rightInstance)
        {
            return new GameValue(getplayerscores(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return a UniqueID of the given unit (player). The returned string is the player's steamID64: private _steamProfileUrl = "http://steamcommunity.com/profiles/" + (getPlayerUID player); ⚠Prior to Arma 2: Operation Arrowhead v1.60, the result always consisted of a stringified number (see getPlayerUIDOld), but always had to be considered and processed as a String. Converting it to a Number could cause precision problems, as Number cannot accurately represent integers above 16777216 (224). Moreover, games since Arma 2: Operation Arrowhead v1.61 provide a value that is not all-numeric. Prior to Arma 3 v2.02, in some cases the identity of certain player units could fail to propagate to other clients and the server, which caused isPlayer and getPlayerUID to incorrectly return false and "" respectively, where the affected units were not local. See this bug report (GitHub) for more info. This was supposedly fixed, but you should remain vigilant toward false negatives nonetheless.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetPlayerUID(GameValue rightInstance)
        {
            return new GameValue(getplayeruid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets provided player's Voice over Network (VoN) volume.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetPlayerVoNVolume(GameValue rightInstance)
        {
            return new GameValue(getplayervonvolume(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns object or location position. If the argument is an object, the return value is in format PositionAGLS. The alternative syntax gets the position given distance and heading away from provided object or position - the command equivalent of BIS_fnc_relPos. ⚠Do not use this command to get an object's position in 3D format: the Z value from this command is relative to the surface underneath, and there is no compatible setter command to use it with;the commonly misused code: _obj1 setPos getPos _obj2 is absolutely wrong this command is significantly slower than other position commands because it has to calculate the surface below a position from objects in the (2D) area; its performance therefore suffers from areas with a high density of objects such as cities, and can easily be ~20x slower than other, simpler position commands - see this benchmark. The only correct usage of this command is to determine the altitude of an object from the surface below it (see Example 5).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object position height above sea level.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPosASL(GameValue rightInstance)
        {
            return new GameValue(getposasl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an object's rendered ASL position (z value above sea level) in render time scope.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPosASLVisual(GameValue rightInstance)
        {
            return new GameValue(getposaslvisual(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the object position height above water surface (waves and pond objects included).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPosASLW(GameValue rightInstance)
        {
            return new GameValue(getposaslw(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the position of an object relative to the terrain.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPosATL(GameValue rightInstance)
        {
            return new GameValue(getposatl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an object's rendered ATL position (z value above ground) in render time scope.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPosATLVisual(GameValue rightInstance)
        {
            return new GameValue(getposatlvisual(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an object's AGLS position in render time scope. Alias of visiblePosition. ⚠This command should not be used for actual 3D calculations. See getPos for more details.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPosVisual(GameValue rightInstance)
        {
            return new GameValue(getposvisual(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the provided object's model centre position ([0,0,0]) in PositionASL, rather than the transformed boundingCenter or LandContact vertices.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPosWorld(GameValue rightInstance)
        {
            return new GameValue(getposworld(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the provided object's, model centre position in render version in format PositionASL, rather than transformed boundingCenter or LandContact vertices.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPosWorldVisual(GameValue rightInstance)
        {
            return new GameValue(getposworldvisual(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return array of magazines on pylons.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetPylonMagazines(GameValue rightInstance)
        {
            return new GameValue(getpylonmagazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns direction, which is relative to object's current direction, from given object to another object or position in the range from 0 to 360, the equivalent of BIS_fnc_relativeDirTo. Taking the current direction of the object into account.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetRelDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getreldir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns position that is given distance and relative direction away from original object. The alternative syntax available from Arma 3 v 2.14, returns the position offset of the attached object. If the animated memory point is used for attachment, the offset is calculated in  render scope.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetRelPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getrelpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get status of disabled raycasts for remote entities. See disableRemoteSensors for detailed description.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue GetRemoteSensorsDisabled()
        {
            return new GameValue(getremotesensorsdisabled());
        }

        /// <summary>
        /// Returns the amount (1 is full) of repair resources in the cargo space of a repair vehicle. Since Arma 3 v1.96 the return value for vehicles that are not configured to have ability to repair other vehicles is -1. (Prior to that the value was negative infinity)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetRepairCargo(GameValue rightInstance)
        {
            return new GameValue(getrepaircargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array containing all information about current client screen resolution. Render resolution is not returned by this command. A sampling setting of 50% means half of native width and half of native height, resulting in a render resolution of 25% the original resolution. ⚠The engine default value for fovTop is 0.75 in case it is needed to calculate difference with custom FOV. The aspectRatio is calculated as fovLeft / fovTop and should be the same as screenW / screenH for undistorted image if the FOV is custom. Some of the common values: 16/9 16/10 5/4 4/3 16/9 triple screen 1.777777(…) 1.6 1.25 1.333333(…) 5.333333(…)
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetResolution()
        {
            return new GameValue(getresolution());
        }

        /// <summary>
        /// Returns road piece information. Bridges are special case. Only large bridges are part of Road Net. Small pedestrian bridges are not recognized as roads. Bridge "mapType" is "ROAD" so the best way to detect bridges is to check "isBridge" value. Bridges are not part of new roads and don't have the same info as other new roads, so only "mapType", "texture" (maybe "textureEnd"), "begPos", "endPos" and "isBridge" are  updated. Pedestrian roads "mapType" is usually "TRAIL". They are part of Road Net but excluded from path finding. Use roadsConnectedTo with alternative flag to find the connections between pedestrian roads.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetRoadInfo(GameValue rightInstance)
        {
            return new GameValue(getroadinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if rotor break is on. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetRotorBrakeRTD(GameValue rightInstance)
        {
            return new GameValue(getrotorbrakertd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns vehicle sensors' potential targets.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetSensorTargets(GameValue rightInstance)
        {
            return new GameValue(getsensortargets(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns vehicle sensors' threats.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetSensorThreats(GameValue rightInstance)
        {
            return new GameValue(getsensorthreats(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the shadows rendering distance.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetShadowDistance()
        {
            return new GameValue(getshadowdistance());
        }

        /// <summary>
        /// Returns shot information for the given projectile. If shot was fired by a soldier on foot or in FFV position in vehicle, the soldier is returned for the vehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetShotParents(GameValue rightInstance)
        {
            return new GameValue(getshotparents(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return object which is sling loaded by vehicle
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetSlingLoad(GameValue rightInstance)
        {
            return new GameValue(getslingload(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns value of the given sound controller.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetSoundController(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getsoundcontroller(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the calculated value of simple expression defined in config. Config could be any config entry, even  mission config entry. It is more important that the vehicle is a transport and not any object. If the expression contains sound controllers, the controller values will be taken from the given vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetSoundControllerResult(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getsoundcontrollerresult(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get the speed for the given speed mode. SpeedMode can be: "AUTO" "SLOW" "NORMAL" "FAST"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetSpeed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getspeed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get current stamina (~ seconds until depletion)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetStamina(GameValue rightInstance)
        {
            return new GameValue(getstamina(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns value of the given stat. A list of possible StatNames can be found here: Arma 3: Stat Names
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetStatValue(GameValue rightInstance)
        {
            return new GameValue(getstatvalue(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns servers information of Steam friends currently playing the game.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetSteamFriendsServers()
        {
            return new GameValue(getsteamfriendsservers());
        }

        /// <summary>
        /// Returns subtitles settings.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetSubtitleOptions()
        {
            return new GameValue(getsubtitleoptions());
        }

        /// <summary>
        /// Gets the suppression value for the given unit. Returns varying Number between 0 and 1, or -1 if suppression is disabled (disableAI "SUPPRESSION") or the suppression value is not available. Suppression is not calculated for player entities and is always 0, unless it is set with setSuppression. In this case the return value is the set value. Before Arma 3 v1.92 this command could return nil. ⚠The unit must not be objNull, must be local and alive
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetSuppression(GameValue rightInstance)
        {
            return new GameValue(getsuppression(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for setTerrainGrid, returns the current terrain grid.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetTerrainGrid()
        {
            return new GameValue(getterraingrid());
        }

        /// <summary>
        /// Returns terrain height at the specified location. Unlike getTerrainHeightASL which returns the exact position's height, this command returns the height at the closest terrain grid pixel to the provided position: private _cellWidth = getTerrainInfo # 2; getTerrainHeightASL (_pos apply { _cellWidth * round (_x / _cellWidth) });
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetTerrainHeight(GameValue rightInstance)
        {
            return new GameValue(getterrainheight(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the terrain height above the sea for the given position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetTerrainHeightASL(GameValue rightInstance)
        {
            return new GameValue(getterrainheightasl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the terrain heightmap information, as well as sea level offset (due to tides, if available).
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GetTerrainInfo()
        {
            return new GameValue(getterraininfo());
        }

        /// <summary>
        /// Extracts localized text from config entry, if entry is subject to localization, otherwise returns text value. To obtain the translation key itself, see getTextRaw.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetText(GameValue rightInstance)
        {
            return new GameValue(gettext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns raw text from config entry. If entry is subject to  localization, the translation key is returned. To obtain the  localized text, see getText.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue GetTextRaw(GameValue rightInstance)
        {
            return new GameValue(gettextraw(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return texture information - resolution in pixels (mipmap level 0) and average colour. Multiply the pixel values by pixelW and pixelH to get screen coordinates.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetTextureInfo(GameValue rightInstance)
        {
            return new GameValue(gettextureinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns estimated width of the text based on font type and size. Similar to ctrlTextWidth but does not require a control and can be used to estimate text width for any control including buttons. Result does not include left and right margins (hardcoded at 0.008 each). This command always uses unicode (see also forceUnicode).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetTextWidth(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(gettextwidth(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// There is currently no text in this page
        /// </summary>
        /// <returns>GameValue hashmap</returns>
        public static GameValue GetTiParameters()
        {
            return new GameValue(gettiparameters());
        }

        /// <summary>
        /// Returns total DLC usage time in this game session
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetTotalDLCUsageTime()
        {
            return new GameValue(gettotaldlcusagetime());
        }

        /// <summary>
        /// Get the vehicle towing the provided one.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue GetTowParent(GameValue rightInstance)
        {
            return new GameValue(gettowparent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns controls trim offset.For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetTrimOffsetRTD(GameValue rightInstance)
        {
            return new GameValue(gettrimoffsetrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the rotation and elevation limits for the given turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetTurretLimits(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getturretlimits(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get the current optics mode of the optics in the turret occupied by the specified unit. The alternative syntax allows a vehicle and turret path to be specified without needing a unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue GetTurretOpticsMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getturretopticsmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a unit's freefall information.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetUnitFreefallInfo(GameValue rightInstance)
        {
            return new GameValue(getunitfreefallinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a Unit Loadout Array with all assigned items, weapons, containers and their stored items. The config should contain the following standard entries: Show text class MyLoadout { 	uniformClass = "U_B_CombatUniform_mcam"; 	backpack = "B_AssaultPack_mcamo"; 	linkedItems[] = { "V_PlateCarrier1_rgr", "H_HelmetB", "ItemCompass", "ItemWatch", "ItemRadio", "NVGoggles" }; 	weapons[] = { "arifle_MX_ACO_pointer_F", "hgun_P07_F" }; 	items[] = { "FirstAidKit", "FirstAidKit", "FirstAidKit" }; 	magazines[] = { 		"30Rnd_65x39_caseless_mag", "16Rnd_9x21_Mag", 		"SmokeShell", 		"HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", 		"HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", 		"HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade", "HandGrenade" 	}; };
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetUnitLoadout(GameValue rightInstance)
        {
            return new GameValue(getunitloadout(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the current value of a trait of the given unit. For the default values please visit setUnitTrait.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing_bool</returns>
        public static GameValue GetUnitTrait(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getunittrait(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for setUnloadInCombat. To return global config value see canUnloadInCombat
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetUnloadInCombat(GameValue rightInstance)
        {
            return new GameValue(getunloadincombat(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns extended information about given server user.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetUserInfo(GameValue rightInstance)
        {
            return new GameValue(getuserinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of user text variables used in MFD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetUserMFDText(GameValue rightInstance)
        {
            return new GameValue(getusermfdtext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of user text variables used in MFD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetUserMFDValue(GameValue rightInstance)
        {
            return new GameValue(getusermfdvalue(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the value of variable in the variable space assigned to various data types. All available data types combinations: Primary syntax (String) Alternative syntax (Array) Code Since Code Since Namespace getVariable String - Namespace getVariable Array Arma 2: Operation Arrowhead v1.60 Object getVariable String - Object getVariable Array - Group getVariable String - Group getVariable Array - Team Member getVariable String - Team Member getVariable Array - Task getVariable String - Task getVariable Array Arma 3 v1.68 Location getVariable String - Location getVariable Array Arma 3 v1.68 Control getVariable String - Control getVariable Array Arma 3 v1.56 Display getVariable String Arma 3 v1.56 Display getVariable Array Arma 3 v1.56 ⚠When variable is set on a Task, it is not actually set on the task itself, but on the FSM attached to the task. If there is no FSM, getVariable will not work. In the case of Alt Syntax usage in Arma 3, defaultValue will be returned if: Requested variable is either undefined or nil Variable namespace is null (objNull, grpNull, etc.)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue GetVariable(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(getvariable(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get a list of vehicles loaded as cargo inside this vehicle. The returned array is in the order the cargo vehicles were added to containing vehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetVehicleCargo(GameValue rightInstance)
        {
            return new GameValue(getvehiclecargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// There is currently no text in this page
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetVehicleTiPars(GameValue rightInstance)
        {
            return new GameValue(getvehicletipars(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Obtain the current system's video settings.
        /// </summary>
        /// <returns>GameValue hashmap</returns>
        public static GameValue GetVideoOptions()
        {
            return new GameValue(getvideooptions());
        }

        /// <summary>
        /// Returns all weapons types and count from the cargo space
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetWeaponCargo(GameValue rightInstance)
        {
            return new GameValue(getweaponcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current size of weapon sway of a given unit, in radians.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetWeaponSway(GameValue rightInstance)
        {
            return new GameValue(getweaponsway(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns orientation of horizontal stabilizers.For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetWingsOrientationRTD(GameValue rightInstance)
        {
            return new GameValue(getwingsorientationrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns position of stabilizers.For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GetWingsPositionRTD(GameValue rightInstance)
        {
            return new GameValue(getwingspositionrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the position of a selected waypoint of a given group. Waypoints include only those which were placed in the mission editor.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GetWPPos(GameValue rightInstance)
        {
            return new GameValue(getwppos(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Control what the unit(s) is/are glancing at (target or Position). If target is used, it will get revealed fully. How frequently the unit(s) is/are glancing there depends on behaviour.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue GlanceAt(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(glanceat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Types text to the global radio channel. The text will be visible only on the PC where command was executed. If you need the message to show on all computers, you have to execute it globally (see remoteExec).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue GlobalChat(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(globalchat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sends the audio message to the global radio channel. The message is defined in CfgRadio in the description.ext file or config radio protocol. The transmission will play only on the PC where command was executed. If you need the transmission to play on all computers, you have to execute it globally (see remoteExec). When transmitting unit gets killed, transmission will be interrupted. However when receiving unit gets killed, the transmission continues to play.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue GlobalRadio(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(globalradio(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns name of currently used goggles (for NVGoggles use hmd).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Goggles(GameValue rightInstance)
        {
            return new GameValue(goggles(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the group a unit is assigned to.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue group</returns>
        public static GameValue Group(GameValue rightInstance)
        {
            return new GameValue(group(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Types text to the group radio channel. The text will be visible only on the PC where command was executed. If you need the message to show on all computers, you have to execute it globally (see remoteExec). ⚠The unit must have an assigned radio item (such as "ItemRadio") to see or transmit the messages. A radio item must have the property simulation = "ItemRadio"; in its CfgWeapons config.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue GroupChat(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(groupchat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get group with given unique ID. For objects use objectFromNetId. As this command is MP only, you can use BIS_fnc_groupFromNetId, which extends the use to SP as well.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue group</returns>
        public static GameValue GroupFromNetId(GameValue rightInstance)
        {
            return new GameValue(groupfromnetid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether or not group icons raise onGroupIconClick, onGroupIconOverEnter and onGroupIconOverLeave events.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue GroupIconSelectable()
        {
            return new GameValue(groupiconselectable());
        }

        /// <summary>
        /// Returns array with group icons visibility. A getter for setGroupIconsVisible
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue GroupIconsVisible()
        {
            return new GameValue(groupiconsvisible());
        }

        /// <summary>
        /// Returns a group's name or a unit's group ID number.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GroupID(GameValue rightInstance)
        {
            return new GameValue(groupid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the  machine network ID of the client to which the group is local. This command only works when called from the server. When called from a client, it always returns 0.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue GroupOwner(GameValue rightInstance)
        {
            return new GameValue(groupowner(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sends the audio message to the group radio channel. The message is defined in CfgRadio in the description.ext file or config radio protocol.  ⚠The unit must have an assigned radio item (such as "ItemRadio") to see or transmit the messages. A radio item must have the property simulation = "ItemRadio"; in its CfgWeapons config. When transmitting unit gets killed, transmission will be interrupted. However when receiving unit gets killed, the transmission continues to play.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue GroupRadio(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(groupradio(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array with all groups of given side.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Groups(GameValue rightInstance)
        {
            return new GameValue(groups(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns selected units in source group for normal commanding mode (individual units). For the High Command equivalent, see hcSelected.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue GroupSelectedUnits(GameValue rightInstance)
        {
            return new GameValue(groupselectedunits(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects a unit from player's group. If player is the leader, the effect of this command is similar to player pressing F1, F2, F3 etc to highlight units in his squad, after which the unit command menu is shown. If leader is AI, player will get usual communication menu to interact with the leader.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue GroupSelectUnit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(groupselectunit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// A non-existing Group. To compare non-existent groups use isNull or isEqualTo: grpNull == grpNull;			// false isNull grpNull;				// true grpNull isEqualTo grpNull;	// true
        /// </summary>
        /// <returns>GameValue group</returns>
        public static GameValue GrpNull()
        {
            return new GameValue(grpnull());
        }

        /// <summary>
        /// Returns the gunner of a vehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue Gunner(GameValue rightInstance)
        {
            return new GameValue(gunner(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the current gusts value. Scale is 0 to 1.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Gusts()
        {
            return new GameValue(gusts());
        }

        /// <summary>
        /// This command was meant to break the script into debugger, however currently it does not do anything except displaying and logging the following error: Error Debugger breakpoint hit.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue Halt()
        {
            return new GameValue(halt());
        }

        /// <summary>
        /// Returns array with all items assigned to the handgunWeapon except magazines. Use handgunMagazine command for the latter. This command is used for infantry weapons only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue HandgunItems(GameValue rightInstance)
        {
            return new GameValue(handgunitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Collects all loaded magazines from all handgunWeapon muzzles and returns them in Array, otherwise it returns []. This command is used for infantry weapons only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue HandgunMagazine(GameValue rightInstance)
        {
            return new GameValue(handgunmagazine(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of a unit's handgun (an empty string if there is none).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue HandgunWeapon(GameValue rightInstance)
        {
            return new GameValue(handgunweapon(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if a soldier's hands are hit, which results in inaccurate aiming.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue HandsHit(GameValue rightInstance)
        {
            return new GameValue(handshit(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Processes provided value's hash, and encodes it using Base64. The hash algorithm is FNV-1A 64bit. A hash value remains the same between game restarts but for Object and Group type, their hash being based on their netId.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue HashValue(GameValue rightInstance)
        {
            return new GameValue(hashvalue(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the computer has an interface (a real player). False for a dedicated server or for a headless client.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue HasInterface()
        {
            return new GameValue(hasinterface());
        }

        /// <summary>
        /// Returns true if the object airplane or helicopter has a pilotCamera.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue HasPilotCamera(GameValue rightInstance)
        {
            return new GameValue(haspilotcamera(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if a unit has the given weapon in hands or on back/in holster. Weapons inside unit containers such as vest and backpack are not counted.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue HasWeapon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hasweapon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns selected groups in high command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue HcAllGroups(GameValue rightInstance)
        {
            return new GameValue(hcallgroups(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns parameters describing group in high command bar. Return value is array in format [groupName, teamName] or [] if error. Possible values for team name: "teammain" (default) "teamred" "teamgreen" "teamblue" "teamyellow"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue HcGroupParams(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hcgroupparams(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns group's high command commander.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue HcLeader(GameValue rightInstance)
        {
            return new GameValue(hcleader(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove all groups from unit's high command bar.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HcRemoveAllGroups(GameValue rightInstance)
        {
            return new GameValue(hcremoveallgroups(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes group from unit's high command bar.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HcRemoveGroup(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hcremovegroup(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns selected groups in high command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue HcSelected(GameValue rightInstance)
        {
            return new GameValue(hcselected(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Select given group in high command bar.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HcSelectGroup(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hcselectgroup(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add group to unit's high command bar. The previous HC leader should be removed before adding the new one (see Example 3).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HcSetGroup(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hcsetgroup(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows or hides high command bar. There must be some groups under HC command to show HC bar.Since Arma 3 v1.94 this command returns Nothing as it should
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HcShowBar(GameValue rightInstance)
        {
            return new GameValue(hcshowbar(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return whether the High Command bar is shown/active.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue HcShownBar()
        {
            return new GameValue(hcshownbar());
        }

        /// <summary>
        /// Returns headgear of unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Headgear(GameValue rightInstance)
        {
            return new GameValue(headgear(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Hides dead body of the given unit. After a short delay, the body slowly sinks into the ground. After awhile, when group of the unit becomes grpNull, the body gets deleted and becomes objNull. If applied to alive unit, nothing happens until unit dies, then the unit's body gets hidden. If a dead unit is human player, the body is hidden but not deleted until player respawns.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HideBody(GameValue rightInstance)
        {
            return new GameValue(hidebody(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Hide entity. Can be used on soldiers and vehicles, also on static objects.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HideObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hideobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// This command is designed for MP. Hides object on all connected clients as well as JIP. Can be used on static objects. In singleplayer this command behaves just like hideObject.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HideObjectGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hideobjectglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Hides or shows the  simple object's provided selection.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HideSelection(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hideselection(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Outputs a hint message to the right of the screen (left of the screen in Operation Flashpoint) with a sound (except in Armed Assault). To split message in multiple lines either use Structured Text or  (in lower case). Armed Assault hints are silent. For later titles, see hintSilent.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Hint(GameValue rightInstance)
        {
            return new GameValue(hint(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Displays a very basic message dialog in the center of the screen. Player control is taken away until "Continue" is pressed. The message dialog can be dragged around on the screen. After "Continue" has been pressed, the content of the hintC is repeated in a normal hint. In Singleplayer, the game is paused while the message dialog is visible.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HintC(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(hintc(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows a text hint only when in cadetMode. The text can contain several lines.  is used to indicate the end of a line.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HintCadet(GameValue rightInstance)
        {
            return new GameValue(hintcadet(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Same as hint, but without a sound.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HintSilent(GameValue rightInstance)
        {
            return new GameValue(hintsilent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns class name of currently used Head Mounted Display. Returns an empty string if the slot is empty.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Hmd(GameValue rightInstance)
        {
            return new GameValue(hmd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Host the multiplayer mission defined in the config class and opens the lobby with the scenario loaded. Must be called in UI action from a dialog.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HostMission(GameValue rightInstance)
        {
            return new GameValue(hostmission(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Load HTML from file or URI using given control. File path is relative to current mission dir or an absolute path (with drive letter etc.). The command is subject to restrictions, imposed by CfgCommands class. Since 2.10 the 'title' attribute is supported within <img> and <a> html tags ⚠For unknown reasons, URL's length is limited to 255 characters.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue HtmlLoad(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(htmlload(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns movement borders for HUD [min speed, max speed, min alt, max alt, min dir, max dir, position[x,y,z] or target]
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue HUDMovementLevels()
        {
            return new GameValue(hudmovementlevels());
        }

        /// <summary>
        /// Returns the current humidity value. 0 is no humidity and 1 is 100% humidity. Humidity value quickly changes from 0 to 1 when rain starts, then slowly changes from 1 to 0 when rain stops.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Humidity()
        {
            return new GameValue(humidity());
        }

        /// <summary>
        /// Creates a structured text containing the given image. Use setAttributes to set additional  attributes on the image.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue text</returns>
        public static GameValue Image(GameValue rightInstance)
        {
            return new GameValue(image(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Imports all groups into the RTE.  Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ImportAllGroups(GameValue rightInstance)
        {
            return new GameValue(importallgroups(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a location's importance value.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Importance(GameValue rightInstance)
        {
            return new GameValue(importance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether given position or object is inside given area. Use inAreaArray to check multiple positions/objects within area. This command also supports hexagon area which can be created from ellipse when both a and b are negative. Hexagon ellipses are also supported by both marker creation and drawEllipse.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue InArea(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(inarea(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns given list of Objects and/or Positions that are in the given area, area defined by a trigger, marker, location or array.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue InAreaArray(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(inareaarray(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the incapacitated sub-state of the given unit, when the lifeState of the unit is "INCAPACITATED". Could be one of: "UNCONSCIOUS" "MOVING" "SHOOTING"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue IncapacitatedState(GameValue rightInstance)
        {
            return new GameValue(incapacitatedstate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Pre-defined variable for the independent side.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue Independent()
        {
            return new GameValue(independent());
        }

        /// <summary>
        /// Sets the state of a fireplace.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Inflame(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(inflame(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if fireplace is inflamed (burning) or not. To check if a unit is receiving damage from fire, use isBurning command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Inflamed(GameValue rightInstance)
        {
            return new GameValue(inflamed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns information about what is currently displayed on given player's info panel. Returns ["EmptyDisplay","EmptyDisplayComponent"] when no panel is open.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue InfoPanel(GameValue rightInstance)
        {
            return new GameValue(infopanel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Controls availability of component to given object info panel.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue InfoPanelComponentEnabled(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(infopanelcomponentenabled(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of all components available to given object info panel.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue InfoPanelComponents(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(infopanelcomponents(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array all info panels configured for given object or object and turret path.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue InfoPanels(GameValue rightInstance)
        {
            return new GameValue(infopanels(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets given event handler of in-game UI. If EH function returns true, performed action is overridden. Event handlers available are: "PrevAction" - mouse scroll up "Action" - action key press "NextAction" - mouse scroll down In order to remove a previously added event handler, set it again with an empty code string "". ⚠This is a "set" command, which means event handlers are not stackable and will replace previously set event handlers of the same type. Since Arma 3 v1.50 the event handler receives an array of the selected/activated action's arguments in _this variable: params ["_target", "_caller", "_index", "_engineName", "_text", "_priority", "_showWindow", "_hideOnUse", "_shortcut", "_visibleMenu", "_eventName"]; _target: Object - target object to which action is attached _caller: Object - caller object, basically player _index: Number - index of the action in action menu (0 - top most) _engineName: String - engine based action name ("User" for user added actions) _text: String - localized action plain text as seen by the caller _priority: Number - action priority value _showWindow: Boolean - action showWindow value _hideOnUse: Boolean - action hideOnUse value _shortcut: String - action shortcut name or "" _visibleMenu: Boolean - action menu visibility - on first scroll or action press the menu is still invisible, the menu is shown but no action is performed _eventName: String - event name
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue InGameUISetEventHandler(GameValue rightInstance)
        {
            return new GameValue(ingameuiseteventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns base entry of config entry.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue config</returns>
        public static GameValue InheritsFrom(GameValue rightInstance)
        {
            return new GameValue(inheritsfrom(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Initialises the ambient life on local client from CfgWorlds >> worldName >> AmbientA3. Has no effect on dedicated server or headless client.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue InitAmbientLife()
        {
            return new GameValue(initambientlife());
        }

        /// <summary>
        /// Checks whether position is inside given polygon. The polygon is only checked in 2 dimensions, i.e. the value of Z is ignored.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue InPolygon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(inpolygon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the state of input devices mapped to given input action. For Arma 3 inputActions and its bindings see: inputAction/actions. For earlier Arma editions  see Key Actions.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue InputAction(GameValue rightInstance)
        {
            return new GameValue(inputaction(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the state of controller inputs. The controller is a standard XBOX controller which is selected with Windows XBOX controller scheme. The input can be: XBOX_A 0 XBOX_B 1 XBOX_X 2 XBOX_Y 3 XBOX_Up 4 XBOX_Down 5 XBOX_Left 6 XBOX_Right 7 XBOX_Start 8 XBOX_Back 9 XBOX_LeftBumper 10 XBOX_RightBumper 11 XBOX_LeftTrigger 12 XBOX_RightTrigger 13 XBOX_LeftThumb 14 XBOX_RightThumb 15 XBOX_LeftThumbXRight 16 XBOX_LeftThumbYUp 17 XBOX_RightThumbXRight 18 XBOX_RightThumbYUp 19 XBOX_LeftThumbXLeft 20 XBOX_LeftThumbYDown 21 XBOX_RightThumbXLeft 22 XBOX_RightThumbYDown 23
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue InputController(GameValue rightInstance)
        {
            return new GameValue(inputcontroller(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the state of mouse button action, alone or in combination with key presses. For more information on codes and combos see Arma 3: Modded Keybinding and DIK_KeyCodes but here are some examples of how codes could be hand constructed: KEYBOARD_COMBO 16777216 (0x1000000) DEVICE_MOUSE 65536 (0x10000) HOLD_OFFSET 0 CLICK_OFFSET 128 (0x80) DOUBLE_CLICK_OFFSET 256 (0x100) SPECIAL_COMBINATIONS 1114112 (0x110000) Click + Hold: BUTTON + DEVICE_MOUSE + HOLD_OFFSET = BUTTON + 65536 + 0 Click: BUTTON + DEVICE_MOUSE + CLICK_OFFSET = BUTTON + 65536 + 128  Double Click: BUTTON + DEVICE_MOUSE + DOUBLE_CLICK_OFFSET = BUTTON + 65536 + 256 RMB Click + Hold:  1 + 65536 + 0 = 65537 RMB Click: 1 + 65536 + 128 = 65665 RMB Double Click: 1 + 65536 + 256 = 65793 Combo + Click + Hold: DIK * KEYBOARD_COMBO + SPECIAL_COMBINATIONS + BUTTON + HOLD_OFFSET = DIK * 16777216 + 1114112 + BUTTON + 0 Combo + Click: DIK * KEYBOARD_COMBO + SPECIAL_COMBINATIONS + BUTTON + CLICK_OFFSET = DIK * 16777216 + 1114112 + BUTTON + 128 Combo + Double Click: DIK * KEYBOARD_COMBO + SPECIAL_COMBINATIONS + BUTTON + DOUBLE_CLICK_OFFSET = DIK * 16777216 + 1114112 + BUTTON + 256 LShift + RMB Click + Hold: 42 * 16777216 + 1114112 + 1 + 0 = 705757185 LShift + RMB Click: 42 * 16777216 + 1114112 + 1 + 128 = 705757313 LShift + RMB Double Click: 42 * 16777216 + 1114112 + 1 + 256 = 705757441
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue InputMouse(GameValue rightInstance)
        {
            return new GameValue(inputmouse(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if all given units are able to fire at given position with given magazineType.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue InRangeOfArtillery(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(inrangeofartillery(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Inserts multiple values into Array/String/HashMap. The String variant also supports forceUnicode.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Insert(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(insert(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Insert an object to the editor and assign arguments. Create script is,not called. Returns the ID of the new EditorObject. Subtype class is,optional. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue InsertEditorObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(inserteditorobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns how much a man is inside a building. The value is the same as normally returned by weapons/ammo sound controller "interior". It is possible to modify an individual object to use sound interior with enableAudioFeature. The sound is considered internal when the corresponding surface sound name starts with "int_". An object placed inside a building that does not have model CfgSurfaces' soundEvironsic parameter named this way would generate external sound inside the building, and insideBuilding on top of this object would return 0.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue InsideBuilding(GameValue rightInstance)
        {
            return new GameValue(insidebuilding(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Finds named selections in object which are in specified LOD, intersected by given section of a line. Return value is in the form of [selection, distance]. Multiple returned arrays are nested within a single array. No intersection returns []. lodName could be one of the following:  "FIRE" "VIEW" "GEOM" "IFIRE" - ("I" stands for Indirect, almost the same as FIRE) 2.02 "PHYSX" - PhysX geometry LOD
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Intersect(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(intersect(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the Eden Editor is currently being used.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue Is3DEN()
        {
            return new GameValue(is3den());
        }

        /// <summary>
        /// Returns true if the Eden Editor is in multiplayer mode.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue Is3DENMultiplayer()
        {
            return new GameValue(is3denmultiplayer());
        }

        /// <summary>
        /// Returns true if the Eden Editor is currently in mission preview mode, single player or multiplayer. (see also is3DEN, is3DENMultiplayer)
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue Is3DENPreview()
        {
            return new GameValue(is3denpreview());
        }

        /// <summary>
        /// If unit is diving and doesn't have a re-breather, it returns false. Diving means the unit's head is underwater. If unit is underwater and has a re-breather, the command returns true.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAbleToBreathe(GameValue rightInstance)
        {
            return new GameValue(isabletobreathe(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if scroll menu is visible.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsActionMenuVisible()
        {
            return new GameValue(isactionmenuvisible());
        }

        /// <summary>
        /// Check if team member is an agent.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAgent(GameValue rightInstance)
        {
            return new GameValue(isagent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if procedural aiming precision affects weapon sway.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAimPrecisionEnabled(GameValue rightInstance)
        {
            return new GameValue(isaimprecisionenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Whether or not units can be in a vehicle with broken tracks/wheels.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAllowedCrewInImmobile(GameValue rightInstance)
        {
            return new GameValue(isallowedcrewinimmobile(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if config entry represents array.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsArray(GameValue rightInstance)
        {
            return new GameValue(isarray(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return true if vehicle has enabled auto hover. (always returns false if the vehicle can't set auto hover)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAutoHoverOn(GameValue rightInstance)
        {
            return new GameValue(isautohoveron(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether the UAV is in autonomous mode or not.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAutonomous(GameValue rightInstance)
        {
            return new GameValue(isautonomous(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns state of automatic start up action. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue IsAutoStartUpEnabledRTD(GameValue rightInstance)
        {
            return new GameValue(isautostartupenabledrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if game was started with autotest parameter
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAutotest()
        {
            return new GameValue(isautotest());
        }

        /// <summary>
        /// Returns state of auto trim functionality. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAutoTrimOnRTD(GameValue rightInstance)
        {
            return new GameValue(isautotrimonrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns resting state of a PhysX (EPE) object. Some EPE objects are deliberately put to sleep by the engine to save resources. This command returns true when object is simulating and false when it is put to sleep. With units of type Man the behaviour is slightly different. As units never get put to sleep, the command outputs ragdoll state of a unit instead. There are 6 states for the output of the command: EPE object is simulaing - true EPE object is put to sleep - false Unit is alive, ragdoll is active - false Unit is alive, ragdoll is NOT active - true 2.10 Unit is NOT alive, ragdoll is active - true 2.10 Unit is NOT alive, ragdoll is NOT active - false It may look counter-intuitive but there is a simple formula to return ragdoll state of a unit (since 2.10): private _unitIsInRagdoll = alive _unit != isAwake _unit;
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsAwake(GameValue rightInstance)
        {
            return new GameValue(isawake(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether the unit is bleeding.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsBleeding(GameValue rightInstance)
        {
            return new GameValue(isbleeding(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether the unit is burning. This returns true only if unit is damaged by nearby fire, it does not check whether a fireplace is burning, use inflamed command for that.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsBurning(GameValue rightInstance)
        {
            return new GameValue(isburning(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if config entry represents config class.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsClass(GameValue rightInstance)
        {
            return new GameValue(isclass(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if vehicle collision lights are on otherwise false.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsCollisionLightOn(GameValue rightInstance)
        {
            return new GameValue(iscollisionlighton(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if copilots actions are enabled.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsCopilotEnabled(GameValue rightInstance)
        {
            return new GameValue(iscopilotenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for allowDamage command. The command indicates if damage is allowed at current locality, hence local effect of the command. For complete solution for being able to tell whether or not an object can be damaged at current locality see Example 1.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsDamageAllowed(GameValue rightInstance)
        {
            return new GameValue(isdamageallowed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the machine executing the command is a dedicated multiplayer server. Returns false in single player.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsDedicated()
        {
            return new GameValue(isdedicated());
        }

        /// <summary>
        /// Returns true if the DLC (CDLC included) is marked as available on Steam. Official and Creator DLC appIds can be found on Arma 3: DLCs & Expansions and Arma 3: CDLCs pages. ⚠This command will return true if the DLC is owned, even if it is not installed!
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsDLCAvailable(GameValue rightInstance)
        {
            return new GameValue(isdlcavailable(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if engine is on, false if it is off.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsEngineOn(GameValue rightInstance)
        {
            return new GameValue(isengineon(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compares two values by reference, returns true if equal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsEqualRef(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isequalref(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Performs strict comparison between var1 and var2 and returns true if equal, otherwise false. Strict means that it would check that both arguments are of the same data type and then compare the values. Some differences between isEqualTo and ==: It performs case sensitive comparison on Strings It doesn't throw error when comparing different types, i.e. ("eleven" isEqualTo 11) It can compare Arrays, Script Handles and Booleans (alive player isEqualTo true) It can compare non-existent game objects (grpNull isEqualTo grpNull) It is slightly faster than ==, especially when comparing Strings 1.48 It can compare Namespaces A compiled code is not equal to the same compiled code made final: _a = compile "123"; _b = compileFinal "123"; _a isEqualTo _b; // false ⚠When comparing Arrays, if an array contains nil element, the comparison will return false. For example: private _array1 = [1, nil, 2]; private _array2 = [1, nil, 2]; _array1 isEqualTo _array2; // false UNLESS the compared arrays are the same array: private _array1 = [1, nil, 2]; private _array2 = _array1; _array1 isEqualTo _array2; // true See: isEqualRef and BIS_fnc_areEqual vs BIS_fnc_areEqualNotNil
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsEqualTo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isequalto(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compares two values' types. A much faster alternative to typeName a == typeName b.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsEqualType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isequaltype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compares types of all elements of an array to the type of a single value. Since Arma 3 v2.09.149634 no additional check is needed to make sure the first argument is an Array. ⚠An empty array will return false (see Example 2).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsEqualTypeAll(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isequaltypeall(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compares type of given value to every type in the given array and if match is found, true is returned.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsEqualTypeAny(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isequaltypeany(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compares types of all elements of one array to types of all elements of another array. Since Arma 3 v2.09.149634 no additional check is needed to make sure the first argument is an Array.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsEqualTypeArray(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isequaltypearray(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compares types of all elements of input array to types of all elements of template array. Similar to isEqualTypeArray however this command is designed for fast validation of functions params, so there are differences: Input can be anything but will be expected to be an Array, otherwise false is returned Input array can be longer but not shorter than template array, will return false if shorter nil could be used in template type array as a wild card to allow any type match
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsEqualTypeParams(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isequaltypeparams(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if file patching is enabled otherwise false
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsFilePatchingEnabled()
        {
            return new GameValue(isfilepatchingenabled());
        }

        /// <summary>
        /// Checks if Code or a variable was compiled final with compileFinal.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsFinal(GameValue rightInstance)
        {
            return new GameValue(isfinal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if there is a linked and enabled flashlight on a given weapon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsFlashlightOn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isflashlighton(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks given position against given filter params. Filter includes checks for: If there are any objects closer than given distance from given position (in 2D) If the area around position is flat enough to match given gradient If the given position is over water or land If the given position is over shore line The gradient seems to correlate with general hill steepness: 0.1 (10%) ~6°, 0.5 (50%) ~27°, 1.0 (100%) ~45°, etc. See also BIS_fnc_findSafePos.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue IsFlatEmpty(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isflatempty(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if player is forced to walk with forceWalk.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsForcedWalk(GameValue rightInstance)
        {
            return new GameValue(isforcedwalk(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the specified unit is subgroup leader.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsFormationLeader(GameValue rightInstance)
        {
            return new GameValue(isformationleader(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the state of game focus changed by pressing ALT + ↹ Tab or similar action.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsGameFocused()
        {
            return new GameValue(isgamefocused());
        }

        /// <summary>
        /// Returns the state of game simulation. Simulation can get paused by pressing Alt + ↹ Tab or a system dialog opening (e.g. Esc menu). Simulation will not get paused if -noPause startup parameter is used. onEachFrame event and "EachFrame" event handler continue to execute when the simulation is paused, which could result in undesired backlog. Use isGamePaused to skip loop if needed.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsGamePaused()
        {
            return new GameValue(isgamepaused());
        }

        /// <summary>
        /// Checks if the given group marked for auto-deletion when empty. See deleteGroupWhenEmpty. It might take up to a minute for the groups marked for auto-deletion when empty to get deleted when they become empty. ⚠This command is only a getter for the deleteWhenEmpty flag in createGroup command or deleteGroupWhenEmpty command. All it does is it shows what the flag was set to during group creation. True does not mean the group will be deleted but that it was suggested to the engine that it should be deleted. It is up to the engine how it manages groups. False does not mean that the group will not be deleted at all. It has no influence on the engine functionality whatsoever.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsGroupDeletedWhenEmpty(GameValue rightInstance)
        {
            return new GameValue(isgroupdeletedwhenempty(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether a person is hidden (reached the hiding position). ⚠Not to be confused with isObjectHidden, which is returning object visibility set with hideObject
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsHidden(GameValue rightInstance)
        {
            return new GameValue(ishidden(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if unit or vehicle is queued for disposal after death.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsInRemainsCollector(GameValue rightInstance)
        {
            return new GameValue(isinremainscollector(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the status of INSTRUCTOR FIGURE setting in UI (OPTIONS >> GAME >> GENERAL >> INSTRUCTOR FIGURE).
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsInstructorFigureEnabled()
        {
            return new GameValue(isinstructorfigureenabled());
        }

        /// <summary>
        /// Returns true if there is a linked and enabled IR on the given weapon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsIRLaserOn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isirlaseron(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the given key is active in the current user profile. See keys, keysLimit and doneKeys in the description.ext file of the missions.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsKeyActive(GameValue rightInstance)
        {
            return new GameValue(iskeyactive(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the given object or type is (a subtype) of the given type. While Syntax 1 and Syntax 2 only support CfgVehicles, 1.00CfgAmmo and CfgNonAIVehicles, Syntax 3 can be used with any config, including the mission config.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsKindOf(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(iskindof(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the vehicle has its laser turned on. Not to be confused with isIRLaserOn which is for units. Main syntax is for primary gunner turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsLaserOn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(islaseron(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if vehicle headlights are on otherwise false.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsLightOn(GameValue rightInstance)
        {
            return new GameValue(islighton(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether given stringName is localized.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsLocalized(GameValue rightInstance)
        {
            return new GameValue(islocalized(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if manual fire is on. Manual fire could either be selected in vehicle action menu (if available) or with action "ManualFire" and "ManualFireCancel". Always returns false for a soldier.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsManualFire(GameValue rightInstance)
        {
            return new GameValue(ismanualfire(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the object is marked for weapons collection.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsMarkedForCollection(GameValue rightInstance)
        {
            return new GameValue(ismarkedforcollection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// The missionProfileNamespace variables are loaded at the start of a mission, before 'init.sqf' is executed. If the file with saved variables for current mission exists in user profile and is loaded, the command returns true. It also will return true after the first execution of saveMissionProfileNamespace command, which also creates the file.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsMissionProfileNamespaceLoaded()
        {
            return new GameValue(ismissionprofilenamespaceloaded());
        }

        /// <summary>
        /// Return true if multiPlayer.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsMultiplayer()
        {
            return new GameValue(ismultiplayer());
        }

        /// <summary>
        /// Returns true when playing a game in solo multiplayer (for example Apex coop campaign PLAY SOLO option).
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsMultiplayerSolo()
        {
            return new GameValue(ismultiplayersolo());
        }

        /// <summary>
        /// Tests whether a variable is nil or undefined from its identifier, or whether the given expression evaluates to nil or Nothing. This command does not exist in Operation Flashpoint/Arma: Cold War Assault but can be emulated (see Example 5).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsNil(GameValue rightInstance)
        {
            return new GameValue(isnil(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Compares two values by reference, returns true if not equal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsNotEqualRef(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isnotequalref(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Performs strict comparison between var1 and var2 and returns false if equal, otherwise true.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsNotEqualTo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isnotequalto(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the tested item is null. Which null type the item has to be equal to depends on the type of game entity tested: Type Object Group Control Display Location Task Script Config Diary Record Team Member Null value objNull grpNull controlNull displayNull locationNull taskNull scriptNull configNull diaryRecordNull teamMemberNull Since 1.00 1.00 1.00 1.00 1.00 1.00 1.30 1.54 2.00 2.10 ⚠A test via == does not work because a null value is not equal to anything, not even itself (configNull being the exception). See also isEqualTo.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsNull(GameValue rightInstance)
        {
            return new GameValue(isnull(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if config entry represents number.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsNumber(GameValue rightInstance)
        {
            return new GameValue(isnumber(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks visibility of a given object on the local machine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsObjectHidden(GameValue rightInstance)
        {
            return new GameValue(isobjecthidden(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if RTD model is loaded.For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsObjectRTD(GameValue rightInstance)
        {
            return new GameValue(isobjectrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if given position is inside road segment. Same as roadAt, only return is boolean instead of road object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsOnRoad(GameValue rightInstance)
        {
            return new GameValue(isonroad(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether Picture-In-Picture video option (Render to Texture) is enabled or not.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsPiPEnabled()
        {
            return new GameValue(ispipenabled());
        }

        /// <summary>
        /// Checks if given person is a player. Returns true for headless clients as well. Prior to Arma 3 v2.02, in some cases the identity of certain player units could fail to propagate to other clients and the server, which caused isPlayer and getPlayerUID to incorrectly return false and "" respectively, where the affected units were not local. See this GitHub bug report for more info. Remain vigilant toward potential false negatives.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsPlayer(GameValue rightInstance)
        {
            return new GameValue(isplayer(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the mission editor is operating in real time mode.  Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsRealTime(GameValue rightInstance)
        {
            return new GameValue(isrealtime(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the code context is being remote executed by remoteExec or remoteExecCall. In SP always returns false. See also isRemoteExecutedJIP
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsRemoteExecuted()
        {
            return new GameValue(isremoteexecuted());
        }

        /// <summary>
        /// Returns true if the code context is being remote executed from the JIP queue by remoteExec or remoteExecCall (when JIP param was set). It is a subset of isRemoteExecuted: Normal remote execution: isRemoteExecuted - true isRemoteExecutedJIP - false Remote execution from JIP queue: isRemoteExecuted - true isRemoteExecutedJIP - true In SP always returns false.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsRemoteExecutedJIP()
        {
            return new GameValue(isremoteexecutedjip());
        }

        /// <summary>
        /// Returns the status of autosave request, made when saveGame command is executed. When request is made, the command immediately returns true. The engine then handles the saving and when it is done, the command returns false.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsSaving()
        {
            return new GameValue(issaving());
        }

        /// <summary>
        /// Returns if given unit is confirmed target for given side.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsSensorTargetConfirmed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(issensortargetconfirmed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the machine executing the command is the server in a multiplayer game or is running single player. It will return true for both dedicated and player-hosted server. See also Multiplayer Scripting/machines.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsServer()
        {
            return new GameValue(isserver());
        }

        /// <summary>
        /// Returns true if the editor is set to draw 3D icons. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsShowing3DIcons(GameValue rightInstance)
        {
            return new GameValue(isshowing3dicons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if given object is simple object
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsSimpleObject(GameValue rightInstance)
        {
            return new GameValue(issimpleobject(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if player is allowed to sprint
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsSprintAllowed(GameValue rightInstance)
        {
            return new GameValue(issprintallowed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if stamina depletion is enabled.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsStaminaEnabled(GameValue rightInstance)
        {
            return new GameValue(isstaminaenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the current mission is a Steam Workshop mission.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsSteamMission()
        {
            return new GameValue(issteammission());
        }

        /// <summary>
        /// Returns true if Steam overlay is enabled, otherwise false.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsSteamOverlayEnabled()
        {
            return new GameValue(issteamoverlayenabled());
        }

        /// <summary>
        /// Returns the status of STREAM FRIENDLY UI setting in UI (OPTIONS >> GAME >> GENERAL >> STREAM FRIENDLY UI).
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsStreamFriendlyUIEnabled()
        {
            return new GameValue(isstreamfriendlyuienabled());
        }

        /// <summary>
        /// Returns true if stress damage is enabled in the game settings. A getter for enableStressDamage. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsStressDamageEnabled()
        {
            return new GameValue(isstressdamageenabled());
        }

        /// <summary>
        /// Checks if config entry represents a text value.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsText(GameValue rightInstance)
        {
            return new GameValue(istext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if object is touching the ground.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsTouchingGround(GameValue rightInstance)
        {
            return new GameValue(istouchingground(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if given unit is turned out, otherwise false. The output changes to true after unit finished turning out, however will change to false almost immediately after unit is ordered to turn in.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsTurnedOut(GameValue rightInstance)
        {
            return new GameValue(isturnedout(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the status of TUTORIAL HINTS setting in UI (OPTIONS >> GAME >> GENERAL >> TUTORIAL HINTS).
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsTutHintsEnabled()
        {
            return new GameValue(istuthintsenabled());
        }

        /// <summary>
        /// Returns true if UAV is connectable by AV terminal(s).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsUAVConnectable(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isuavconnectable(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if UAV is connected to some terminal.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsUAVConnected(GameValue rightInstance)
        {
            return new GameValue(isuavconnected(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the script originated from some UI control event, for example from "onButtonDown" EH. Exists within parent scope and immediate child scopes.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue IsUIContext()
        {
            return new GameValue(isuicontext());
        }

        /// <summary>
        /// Check whether given uniform can be dressed by target soldier.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsUniformAllowed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isuniformallowed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Despite a misleading name, returns the vehicle that is transporting given vehicle in cargo. If the given vehicle is not in vehicle cargo, objNull is returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue IsVehicleCargo(GameValue rightInstance)
        {
            return new GameValue(isvehiclecargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if vehicle has active sensors on.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsVehicleRadarOn(GameValue rightInstance)
        {
            return new GameValue(isvehicleradaron(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns class name (to identify list based on component name) and info if given sensor is enabled.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue IsVehicleSensorEnabled(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(isvehiclesensorenabled(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if walk is toggled (default W+S in Arma 3). This command can still return true when the unit is sprinting or stopped; it only returns the toggle value of walking, not if the unit is walking right now.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsWalking(GameValue rightInstance)
        {
            return new GameValue(iswalking(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if weapon is currently deployed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsWeaponDeployed(GameValue rightInstance)
        {
            return new GameValue(isweapondeployed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if weapon is currently rested.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue IsWeaponRested(GameValue rightInstance)
        {
            return new GameValue(isweaponrested(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with items from ammo box (or any general weapon holder container).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ItemCargo(GameValue rightInstance)
        {
            return new GameValue(itemcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of names of all unit's stored items, including weapons but excluding magazines (see itemsWithMagazines) and assignedItems.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Items(GameValue rightInstance)
        {
            return new GameValue(items(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns combined array including all unit's stored items and all unit's stored magazines and all unit's stored weapons. Loaded magazines such as currentMagazine, primaryWeaponMagazine, secondaryWeaponMagazine, handgunMagazine, binocularMagazine as well as assignedItems are excluded.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ItemsWithMagazines(GameValue rightInstance)
        {
            return new GameValue(itemswithmagazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Maximum number ofunits per group Operation Flashpoint 12 Later titles 10000+ Joins units into a given Group. To make a unit leave its current group, join it into grpNull (e.g. [MyUnit] join grpNull) - but beware: A new group is created for the leaving unit; this could result in the number of groups growing out of control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Join(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(join(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Joins the unit to the given group, if position id is available, this one is used.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue JoinAs(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(joinas(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Joins the unit to the given group, if position id is available, this one is used. Avoid any radio communication related to joining.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue JoinAsSilent(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(joinassilent(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Join all units in the array to given group silently (without radio message). To have a group member leave a group, join him with the grpNull group (e.g. [guy1] joinSilent grpNull), but beware, as brand new group is created for the leaving unit and this could result in the number of groups in a mission growing out of control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue JoinSilent(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(joinsilent(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Joins array into String with provided separator. Array can be of mixed types, all elements will be converted to String prior to joining, but the fastest operation is on the array of Strings.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue JoinString(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(joinstring(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Register knowledge base database to given person. See Conversations for more details. ⚠This command is no longer available in Arma 2 and Arma 3.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue KbAddDatabase(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(kbadddatabase(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Register target list knowledge base database to given person. See Conversations for more details. ⚠This command is no longer available in Arma 2 and Arma 3.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue KbAddDatabaseTargets(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(kbadddatabasetargets(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Register conversation topic to given person. See Conversations for more details. Only the speaker(s) need to have the topic added.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue KbAddTopic(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(kbaddtopic(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if conversation topic was registered to given person. See Conversations for more details.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue KbHasTopic(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(kbhastopic(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Pass a non-verbal communication to the receiver. This command does as if the sentence was said and triggers the reaction scripts (AI FSM or player's conversation EH). See Conversations for more details.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue KbReact(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(kbreact(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unregister conversation topic from given person. See Conversations for more details.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue KbRemoveTopic(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(kbremovetopic(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Make the person tell to the receiver the sentence. See Conversations for more details.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue KbTell(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(kbtell(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if given item was said by person to someone. See Conversations for more details.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue KbWasSaid(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(kbwassaid(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a structured text, containing an image or name (if no image is found) of the button, on the keyboard, mouse or joystick, with the given code.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue text</returns>
        public static GameValue KeyImage(GameValue rightInstance)
        {
            return new GameValue(keyimage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of a button with extra quotation marks (on the keyboard, mouse or joystick) with the given code.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue KeyName(GameValue rightInstance)
        {
            return new GameValue(keyname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Retrieves a list of all keys in a HashMap.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Keys(GameValue rightInstance)
        {
            return new GameValue(keys(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if a group or a side knows about target. Enemy knowledge is instantly shared among the group units Units in the same group always perfectly know about each others AI knowledge cannot check beyond current viewDistance and it resets to zero as soon as the target's distance is over itNote: neither fog nor daylight affect this behaviour Losing sight of a target for more than 120 seconds resets its knowsAbout to zero as well Magic number is the value that must be reached for a unit to shoot at an enemy (used by "Detected by" triggers as well): Game 1.46 1.96 1.18 1.11 1.62 1.82 Magic value 0.7 0.105 ? ? ? ?
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue KnowsAbout(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(knowsabout(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces a helicopter landing.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Land(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(land(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Order an AI airplane to land at a given airport. ID is the number to identify which map airport you want the airplane to land at. See Arma: Airport IDs for more information. Since Arma 3 v1.68 it is possible to also make the airplane land at a dynamic airport object (e.g. aircraft carrier, makeshift runway...) – see Example 2. ⚠To make a helicopter land see land command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LandAt(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(landat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the result of helicopter landing position searching (performed, after land command).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LandResult(GameValue rightInstance)
        {
            return new GameValue(landresult(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current game language.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue Language()
        {
            return new GameValue(language());
        }

        /// <summary>
        /// Returns the laser target object created by given unit (vehicle or soldier) when using a laser targeting device. The main syntax targets the primary gunner turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue LaserTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lasertarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds an item with the given text to the CT_LISTBOX or CT_COMBO or CT_TOOLBOX. If using RscToolBox as template with ctrlCreate, clear it first with lbClear
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LbAdd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbadd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Clear all items from a CT_LISTBOX or CT_COMBO control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbClear(GameValue rightInstance)
        {
            return new GameValue(lbclear(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the text color of the item with the given index of the CT_LISTBOX or CT_COMBO with IDC of the topmost user dialog.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LbColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the text color of the item (right) with the given index of the listbox or combobox with id idc of the topmost user dialog.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LbColorRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbcolorright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the index of the selected item of the CT_LISTBOX, CT_LISTNBOX, CT_COMBO or CT_TOOLBOX. For CT_LISTBOX with multi selection enabled use lbSelection.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LbCurSel(GameValue rightInstance)
        {
            return new GameValue(lbcursel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the data set in given index of the CT_LISTBOX or CT_COMBO.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LbData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes the item with the given index from the CT_LISTBOX, CT_COMBO or CT_TOOLBOX.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbDelete(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbdelete(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether or not given row of the given listbox is selected.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LbIsSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbisselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the picture name of the item with the given index of the listbox or combobox with id idc of the topmost user dialog.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LbPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbpicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the right picture name of the item with the given index of the listbox or combobox with id idc of the topmost user dialog.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LbPictureRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbpictureright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Array of selected rows indices in the given listbox. If listbox is of style LB_MULTI (multi-selection) the array will contain multiple elements, otherwise only a single element. For single selection listbox one can also use lbCurSel. See also lbIsSelected, lbSetSelected
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LbSelection(GameValue rightInstance)
        {
            return new GameValue(lbselection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of the item (left) with the given index of the listbox or combobox with id idc of the topmost user Dialog to color.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of the item (right) with the given index of the listbox or combobox with id idc of the topmost user dialog to color.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetColorRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetcolorright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects the item with the given index in the listbox, listnbox, combobox, xcombobox, xlistbox ⚠The following only applies to the Alternative Syntax when used with CT_LISTBOX and CT_LISTNBOX. To deselect all entries, use -1: _ctrl lbSetCurSel -1; For listbox of style LB_MULTI use lbSetSelected instead. CT_COMBO does not allow deselecting entries, it will instead select the first one as it is not a combobox usual behaviour. If you really need to deselect a combobox, see DreadedEntity's note.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetCurSel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetcursel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the additional text (invisible) in the item with the given index of the listbox or combobox with id idc of the topmost user dialog to the given data. See more information on the CT_LISTBOX command family here.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the left picture in the row with given index of CT_LISTBOX or CT_COMBO. The picture is searched for in the mission directory, the dtaExt subdirectory of the campaign directory and the dtaExt directory and the data bank (or directory). In Arma 3 it might be necessary to set the color of the picture as well with lbSetPictureColor as default color [0,0,0,0] makes the picture invisible.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetpicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of item's picture (left) with the given index of the listbox with id idc of the topmost user dialog to the given color. Color is in format Color (RGBA). Color which consists from only zeros means disable this override.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetPictureColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetpicturecolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the disabled color of item's picture (left) with the given index of the listbox with id idc of the topmost user dialog to the given color. Color is in format Color (RGBA). Color which consists from only zeros means disable this override.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetPictureColorDisabled(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetpicturecolordisabled(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the selected color of item's picture (left) with the given index of the listbox with id idc of the topmost user dialog to the given color. Color is in format Color (RGBA). Color which consists from only zeros means disable this override.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetPictureColorSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetpicturecolorselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the second (right aligned) picture in the item with the given index of the listbox or combobox with id idc of the topmost user dialog. Name is the picture name. The picture is searched for in the mission directory, the dtaExt subdirectory of the campaign directory and the dtaExt directory and the data bank (or directory). In Arma 3 it might be necessary to set the color of the picture as well with lbSetPictureRightColor as default [0,0,0,0] color makes the picture invisible. When trying to select a listBox entry by clicking at the right picture, the control in the background is focused. It seems the width of the control is not extended by adding a right picture.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetPictureRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetpictureright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of the second (right aligned) picture of the given index of the listbox with id idc of the topmost user dialog to the given color. Color which consists from only zeros means disable this override.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetPictureRightColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetpicturerightcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the disabled color of second (right aligned) picture of the item with the given index of the listbox with id idc of the topmost user dialog to the given color. Color which consists from only zeros means disable this override.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetPictureRightColorDisabled(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetpicturerightcolordisabled(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the selected color of the second (right aligned) picture of the item with the given index of the listbox with id idc of the topmost user dialog to the given color. Color which consists from only zeros means disable this override.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetPictureRightColorSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetpicturerightcolorselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the select color of the item with the given index of the listbox or combobox with id idc of the topmost user dialog to color.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetSelectColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetselectcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the select color of the of the secondary text (right aligned) of the item with the given index of the listbox or combobox with id idc of the topmost user dialog to color.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetSelectColorRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetselectcolorright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the selection state of the given row of the given listbox of style LB_MULTI. The command has to be called for every row which is needed to be selected in multi-selection listbox. Use negative index -1 to select/deselect all rows (since 2.12). For single selection listbox use lbSetCurSel instead.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text on the left side of the item with the given index of the listbox or combobox with id idc of the topmost user dialog.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsettext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text on the right side of the item with the given row index of the listbox or combobox with id idc of the topmost user dialog.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetTextRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsettextright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets tooltip for item with given index of the listbox or combobox with id idc of the topmost user dialog to the given data.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetTooltip(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsettooltip(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the additional value in the row with the given index of a CT_LISTBOX or CT_COMBO control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSetValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsetvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the number of items in a CT_LISTBOX or CT_COMBO control. For CT_TOOLBOX size see lnbSize.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LbSize(GameValue rightInstance)
        {
            return new GameValue(lbsize(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts listbox entries alphabetically ascending by their lbText.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSort(GameValue rightInstance)
        {
            return new GameValue(lbsort(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts given ListBox by either lbText, lbValue or lbData in normal or reversed order, using case-sensitive or case-insensitive comparison. This command supports UNICODE characters. When sorting by "VALUE", the rows with the same lbValue will additionally be sorted by lbText in the order specified by `reversedOrder` flag, text specified by `useTextRight` flag and case-sensitivity specified by `caseSensitive` flag. ⚠ This command supports referencing control via IDC as well, but as with any use of IDC in UI Control commands, a dialog should be present, i.e. UI user interaction is created with createDialog rather than createDisplay. As this command supports UNICODE by default, which may result in slower sorting, you can switch it off with unicodeOff param.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSortBy(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbsortby(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts the ListBox entries by lbValue. The entries are sorted in ascending order. Also note that this command will mix up the entries randomly if multiple entries have the same value. In Arma 3 use lbSortBy to avoid this problem.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LbSortByValue(GameValue rightInstance)
        {
            return new GameValue(lbsortbyvalue(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the shown text of the item with the given index of the CT_LISTBOX or CT_COMBO.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LbText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbtext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the shown right text in the item with the given index of the listbox or combobox with id idc of the topmost user dialog.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LbTextRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbtextright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns tooltip for ListBox, ComboBox and Toolbox
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LbTooltip(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbtooltip(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the additional integer value of the item with the given index of the CT_LISTBOX or CT_COMBO.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LbValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lbvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the group leader for the given unit or group. For dead units, objNull is returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue team_member</returns>
        public static GameValue Leader(GameValue rightInstance)
        {
            return new GameValue(leader(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes internal class for the leaderboard with given name. Returns true if the board has been found and deinitialized.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LeaderboardDeInit(GameValue rightInstance)
        {
            return new GameValue(leaderboarddeinit(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns values for the given leaderboard; this can be called after the one of the row request function has been called and successfully finished!
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LeaderboardGetRows(GameValue rightInstance)
        {
            return new GameValue(leaderboardgetrows(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Initialize the leaderboard structure for board with given name. Returns true if board is already initialized.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LeaderboardInit(GameValue rightInstance)
        {
            return new GameValue(leaderboardinit(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Requests given leaderboard to download friends rows from the given leaderboard
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LeaderboardRequestRowsFriends(GameValue rightInstance)
        {
            return new GameValue(leaderboardrequestrowsfriends(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Requests given leaderboard to download values from global table.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LeaderboardRequestRowsGlobal(GameValue rightInstance)
        {
            return new GameValue(leaderboardrequestrowsglobal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Requests given leaderboard to download values around the user position in the table.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LeaderboardRequestRowsGlobalAroundUser(GameValue rightInstance)
        {
            return new GameValue(leaderboardrequestrowsglobalarounduser(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Starts async. operation to upload score to board with given name, value always overwrite the current value in the board. The board has to be initialized before the call.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LeaderboardsRequestUploadScore(GameValue rightInstance)
        {
            return new GameValue(leaderboardsrequestuploadscore(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Starts async. operation to upload score to board with given name, value is only stored to board if it is better than one already in the board. The board has to be initialised before the call.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LeaderboardsRequestUploadScoreKeepBest(GameValue rightInstance)
        {
            return new GameValue(leaderboardsrequestuploadscorekeepbest(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the state of the board with the given name.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LeaderboardState(GameValue rightInstance)
        {
            return new GameValue(leaderboardstate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Ceases the using of the vehicle by a group and unassigns vehicle from the group. If the argument is a single unit, the vehicle will be unassigned from unit's group. After vehicle is unassigned from the group, each individual crew member then unassigned from the vehicle. In short the command could be hypothetically presented as: leaveVehicle = un-addVehicle + unassignVehicle forEach crew However, to make it more reliable, it is best to move unit out of the vehicle manually with moveOut and force unassign the vehicle with unassignVehicle. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LeaveVehicle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(leavevehicle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the credits for the libraries used by the game.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue LibraryCredits()
        {
            return new GameValue(librarycredits());
        }

        /// <summary>
        /// Returns the library disclaimers.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue LibraryDisclaimers()
        {
            return new GameValue(librarydisclaimers());
        }

        /// <summary>
        /// Returns the life state of the given unit. Arma 2 Arma 3 "ALIVE" "DEAD" "DEAD-RESPAWN" "DEAD-SWITCHING" "ASLEEP" "UNCONSCIOUS" "HEALTHY" "DEAD" "DEAD-RESPAWN" "DEAD-SWITCHING" "INCAPACITATED" "INJURED" In Arma 3, lifeState seems to change to "INJURED" when damage aliveUnit >= 0.1 (0.1 seeming to be the value defined in config under "InjuredTreshold"sic). When the state is "INCAPACITATED", a sub-state is available via incapacitatedState command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LifeState(GameValue rightInstance)
        {
            return new GameValue(lifestate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attach light to given object at given position on object.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LightAttachObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lightattachobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Detach light from object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LightDetachObject(GameValue rightInstance)
        {
            return new GameValue(lightdetachobject(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if lampost is on (shining). A lamp state is local to each client (see switchLight). This command was originally designed to only work with CfgNonAIVehicles class "StreetLamp" only; since Arma 3 v1.92 this command was extended to work with street lights.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LightIsOn(GameValue rightInstance)
        {
            return new GameValue(lightison(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the current lightnings value.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Lightnings()
        {
            return new GameValue(lightnings());
        }

        /// <summary>
        /// Limit the speed of an AI-driven vehicle or AI person to given value. It has continuous effect and AI will not break through the speed limitation until one is contacted, engaged or regrouped.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LimitSpeed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(limitspeed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts given value from given "from" range to wanted "to" range. If clipping is set to true, the resulting value is guaranteed to be within "to" range no matter what. Faster alternative to BIS_fnc_linearConversion.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LinearConversion(GameValue rightInstance)
        {
            return new GameValue(linearconversion(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a structured text containing a line break.
        /// </summary>
        /// <returns>GameValue text</returns>
        public static GameValue LineBreak()
        {
            return new GameValue(linebreak());
        }

        /// <summary>
        /// Checks for object intersection with a virtual line between two positions. Does not work under water. Max harcoded distance is 1000m.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LineIntersects(GameValue rightInstance)
        {
            return new GameValue(lineintersects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of objects intersected by the line from begPos to endPos.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LineIntersectsObjs(GameValue rightInstance)
        {
            return new GameValue(lineintersectsobjs(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of intersections with surfaces and ground from begPosASL to endPosASL. Doesn't return intersection with sea surface. Works underwater, unlike lineIntersects. Hardcoded max distance: 5000m. ⚠ if begPosASL is under the ground and endPosASL is above it, the command will only return intersection with the ground, this is an engine limitation and none of the intersectXXX commands will work when initiated from under the ground. only a single LOD is checked for intersection. LOD2 will only be checked if LOD1 is unavailable.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LineIntersectsSurfaces(GameValue rightInstance)
        {
            return new GameValue(lineintersectssurfaces(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns objects intersecting with the virtual line from begPos to endPos. By default, the resulting array of intersecting objects is unsorted (see sortByDistance). Does not work under water. Max hardcoded distance is 1000m.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LineIntersectsWith(GameValue rightInstance)
        {
            return new GameValue(lineintersectswith(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create and assign item to the correct slot. If there is an item in the targeted slot, it gets replaced. See also assignItem.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LinkItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(linkitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// List of units that would activate given Trigger. It returns nothing before the simulation started, i.e. in (undelayed) init.sqf files. Returns a pointer to the trigger's list after the simulation started. Since this is just a reference this means that the value in your local variable will change as the content of the trigger area changes. To permanently copy the returned list to a different variable, use _mylist = +(list triggerOne). The second example can be used inside the trigger (in that case, no need to name your trigger). The list returned for trigger of type "Not present" is the same as that returned for type "present".  ⚠While the command can query any trigger, local or remote, the result will be only for the trigger condition set on the local client. See createTrigger for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue List(GameValue rightInstance)
        {
            return new GameValue(list(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the list of all objects of given type. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ListObjects(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(listobjects(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return list of datalink targets and time for which they will be/were known.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ListRemoteTargets(GameValue rightInstance)
        {
            return new GameValue(listremotetargets(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of the sensors in the given vehicle's config (configFile >> "CfgVehicles" >> vehicle >> "Components" >> "SensorsManagerComponent" >> "Components").
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ListVehicleSensors(GameValue rightInstance)
        {
            return new GameValue(listvehiclesensors(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the natural logarithm of x.   ln(x) and ln(e)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Ln(GameValue rightInstance)
        {
            return new GameValue(ln(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds list of rows of strings.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LnbAddArray(GameValue rightInstance)
        {
            return new GameValue(lnbaddarray(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a column at given position.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LnbAddColumn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbaddcolumn(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds a row of strings.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LnbAddRow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbaddrow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Clears all items in the given listbox or combobox.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbClear(GameValue rightInstance)
        {
            return new GameValue(lnbclear(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the text color of the item with the given position of the 2D listbox. The color is returned in format Color (RGBA).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LnbColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the right color of given row.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LnbColorRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbcolorright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the index of the selected row id 2D listbox.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LnbCurSelRow(GameValue rightInstance)
        {
            return new GameValue(lnbcurselrow(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the additional text (invisible) in an item with the given position of the 2D listbox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LnbData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes column with given index from ListNBox control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbDeleteColumn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbdeletecolumn(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes row with the given index from the given listbox or combobox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbDeleteRow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbdeleterow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns relative screen X of ListNBox control columns position [0.1,0.3,0.6...]. Use lnbSetColumnsPos to set positions.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LnbGetColumnsPosition(GameValue rightInstance)
        {
            return new GameValue(lnbgetcolumnsposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the picture name or path of the item with the given position of the 2D listbox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LnbPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbpicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the right picture of given row. The column parameter does not matter.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LnbPictureRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbpictureright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of the item with the given position of the 2D listbox. Color is in format Color (RGBA).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the right color.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetColorRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetcolorright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets relative screen X for ListNBox control columns positions. Setter for lnbGetColumnsPosition.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetColumnsPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetcolumnspos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects the row with the given index of the 2D listbox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetCurSelRow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetcurselrow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the additional text (invisible) on the item with the given position of the 2D listbox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the picture in the item with the given position of the 2D listbox.The picture is searched in the mission, directory, the dtaExt subdirectory of the campaign directory, and the dtaExt directory and the data bank (or directory).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetpicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the cell picture's colour.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetPictureColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetpicturecolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets color of the right picture in a CT_LISTNBOX.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetPictureColorRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetpicturecolorright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the cell picture's colour on cell selection.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetPictureColorSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetpicturecolorselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of the right picture when it is selected.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetPictureColorSelectedRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetpicturecolorselectedright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the cell's right-picture. The picture is set to the end of the row, the column parameter does not matter. The picture is searched in the mission, directory, the campaign directory's dtaExt subdirectory, and the data bank (or directory).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetPictureRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetpictureright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text in the item with the given position of the 2D listbox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsettext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets cell's right-aligned text. Does not replace cell's text.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetTextRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsettextright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets tooltip on the item with the given row and column of CT_LISTNBOX. ⚠By default, tooltips are added for all columns no matter what column index is provided. This behaviour can be overwritten since 2.02 by setting the control's property tooltipPerColumn to true. See CT_LISTNBOX documentation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetTooltip(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsettooltip(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the additional integer value in the item with the position index of the 2D listbox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSetValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsetvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns size of CT_LISTNBOX. This command supports CT_TOOLBOX control since Arma 3 v2.06. For CT_COMBO or CT_LISTBOX see lbSize.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LnbSize(GameValue rightInstance)
        {
            return new GameValue(lnbsize(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts given multicolumn listbox by lnbText in given column in ascending or descending order. ⚠This command does not support UNICODE, use lnbSortBy if it is needed instead
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSort(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsort(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts given multi-column ListNBox in the given column by either lnbText, lnbValue or lnbData in normal or reversed order, using case-sensitive or case-insensitive comparison. Unlike the older lnbSortXXX commands, this command supports UNICODE characters out of the box. When sorting by "VALUE", the rows with the same lnbValue will additionally be sorted by lnbText in the order specified by the reversedOrder flag, text specified by `useTextRight` flag and case-sensitivity specified by `caseSensitive` flag. ⚠ This command supports referencing control via IDC as well, but as with any use of IDC in UI Control commands, a dialog should be present, i.e. UI user interaction is created with createDialog rather than createDisplay. As this command supports UNICODE by default, which may result in slower sorting, you can switch it off with unicodeOff param.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSortBy(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsortby(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts given multicolumn listbox by lnbValue in given column in ascending or descending order.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LnbSortByValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbsortbyvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the shown text in the item with the given position of the given 2D listbox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LnbText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbtext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns CT_LISTNBOX's right aligned cell text.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LnbTextRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbtextright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the additional integer value in the item with the given position of the 2D listbox.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LnbValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lnbvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the percentage of fullness of a unit's cargo. Output is usually in range 0..1, but can be higher after using certain scripting commands (like addWeaponWithAttachmentsCargoGlobal) which ignore load values when adding items. See Example 2 for load calculation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Load(GameValue rightInstance)
        {
            return new GameValue(load(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current sum of mass from items stored in all unit's containers, linked items and weapons.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LoadAbs(GameValue rightInstance)
        {
            return new GameValue(loadabs(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current percentage of mass from items stored in a backpack relative to the maximum capacity of the backpack. It is equivalent to this formula: _loadBackpack = massOfAllItemsInBackpack / getContainerMaxLoad backpack player;
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LoadBackpack(GameValue rightInstance)
        {
            return new GameValue(loadbackpack(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Loads the given file as a Config, allowing easy processing of the config file contents using commands such as configClasses, configProperties, >>, etc. It can load .rvmat, .bisurf, .cpp, .bin, .sqm, and description.ext files (both binarized and unbinarized configs are supported). ⚠ Config loading can be very slow; the config should only be loaded once and cached, e.g in a HashMap of File Path → Config pairs (see Example 3). It is advised to store the generated config in a variable, otherwise it will get destroyed if it is not being referenced directly (see Example 2).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue config</returns>
        public static GameValue LoadConfig(GameValue rightInstance)
        {
            return new GameValue(loadconfig(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the content of given files. If you plan to compile said string, be aware that the file should not contain comments or compile will throw an error. If there are comments, use preprocessFile/preprocessFileLineNumbers instead. ⚠If the file is not prepared using UTF-8 encoding and contains some characters with codes > 127, they might convert incorrectly.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue LoadFile(GameValue rightInstance)
        {
            return new GameValue(loadfile(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Loads game from the last autosave made with saveGame. If no autosave exists, restarts the mission. When used in campaign it will also deduct 1 life, defined in: campaignConfigFile >> "Campaign" / <battle> / <mission> / "lives" A  "Loaded" mission event handler is available and it is important that it is added in preInit in order for it to fire on load from save.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue LoadGame()
        {
            return new GameValue(loadgame());
        }

        /// <summary>
        /// Loads person's identity from Objects.sav file in campaign directory (from entry name).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LoadIdentity(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(loadidentity(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Initiates the loading action on given weapon of the turret of a transport. So the new magazine is not available instantly, yet according to the reloadTime. The turret has to be manned. One can also change the magazine if its respective weapon is not selected.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LoadMagazine(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(loadmagazine(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates the load overlay dialog for the specified type of overlay. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LoadOverlay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(loadoverlay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Loads object's properties from Objects.sav file in campaign directory (from entry name).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LoadStatus(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(loadstatus(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current percentage of mass from items stored in a uniform relative to the maximum capacity of the uniform. It is equivalent to this formula: private _loadUniform = massOfAllItemsInUniform / getContainerMaxLoad uniform player;
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LoadUniform(GameValue rightInstance)
        {
            return new GameValue(loaduniform(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current percentage of mass from items stored in a vest relative to the maximum capacity of the vest.  It is equivalent to this formula: _loadVest = massOfAllItemsInVest / getContainerMaxLoad vest player;
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LoadVest(GameValue rightInstance)
        {
            return new GameValue(loadvest(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if given unit is local on the computer in multiplayer games - see Multiplayer Scripting - Locality. This can be used to determine on which computer some code must be run. In single player all objects are local.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Local(GameValue rightInstance)
        {
            return new GameValue(local(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Used to internationalise text messages. The provided translation key is looked up in Stringtable.xml (or Stringtable.csv).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Localize(GameValue rightInstance)
        {
            return new GameValue(localize(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns local Namespace attached to the mission. Has the same lifetime as missionNamespace but variables cannot be broadcasted out of or into this namespace in multiplayer and will not be serialized when game is saved. UI variables can be safely stored in this namespace. Use allVariables command to save the variables elsewhere if required.
        /// </summary>
        /// <returns>GameValue namespace</returns>
        public static GameValue LocalNamespace()
        {
            return new GameValue(localnamespace());
        }

        /// <summary>
        /// A non-existing Location. To compare non-existent locations use isNull or isEqualTo: locationNull == locationNull;			// false isNull locationNull;					// true locationNull isEqualTo locationNull;	// true
        /// </summary>
        /// <returns>GameValue location</returns>
        public static GameValue LocationNull()
        {
            return new GameValue(locationnull());
        }

        /// <summary>
        /// Returns the position of a location. If the location is attached to an object, that object's position is returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue LocationPosition(GameValue rightInstance)
        {
            return new GameValue(locationposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Lock vehicle (disable mounting / dismounting) for player. This command will remove user get in/get out actions but will not stop player getting into or out of vehicle via script commands (e.g moveInCargo). Alternative syntax is similar to setVehicleLock but with numbers.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Lock(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(Lock(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Lock/Unlock stabilized camera to target. Works only on turrets which have optic mode selected with direction stabilization enabled. Since 2.08 the command also works with non-stabilized turrets (such as main turret of a tank). See syntax 2. The command is local to the turret gunner, not the vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LockCameraTo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockcamerato(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Lock all cargo positions of a vehicle or lock by index. This command will remove user "get in" action (not get out) but will also stop player getting into vehicle via script commands (e.g moveInCargo) unlike lock command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LockCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockcargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Lock the driver position of the vehicle. This command must be executed where vehicle is local. This command will remove user get in action (not get out) but will also stop player getting into vehicle via script commands unlike lock command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LockDriver(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockdriver(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if vehicle is locked. If it is locked, Persons cannot mount / dismount without order.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Locked(GameValue rightInstance)
        {
            return new GameValue(locked(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the turret lock target. The command is local to the turret, not the vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing_object</returns>
        public static GameValue LockedCameraTo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockedcamerato(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check whether cargo position of the vehicle is locked.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LockedCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockedcargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check whether driver position of the vehicle turret is locked.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LockedDriver(GameValue rightInstance)
        {
            return new GameValue(lockeddriver(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get a vehicle's inventory lock state. Can also be used on a unit's backback (see lockInventory).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LockedInventory(GameValue rightInstance)
        {
            return new GameValue(lockedinventory(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check whether gunner position of the vehicle turret is locked.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LockedTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockedturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Locks the identity of a person. This will disable default identity.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue LockIdentity(GameValue rightInstance)
        {
            return new GameValue(lockidentity(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Lock or unlock a vehicle's inventory access. This command can also lock backpack a unit is wearing to prevent access by a third party. If set to true (locked), the inventory cannot be accessed via hotkey or action menu.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LockInventory(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockinventory(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Lock the gunner position of the vehicle turret. This command will remove user "get in" action (not "get out") but will also stop player getting into vehicle via script commands unlike lock command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LockTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Disable switching to next waypoint (current waypoint will never complete while lockwp is used). Sometimes used during cut-scenes.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LockWp(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lockwp(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a log file containing the list of all game entities in scene.  File is created in the same directory as .rpt file.  Special: BattlEye's RCON variant of this command is #logEntities (see also Multiplayer_Server_Commands)
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue LogEntities()
        {
            return new GameValue(logentities());
        }

        /// <summary>
        /// Registers new log file recording a network traffic and returns handle of the log. The log file is saved inside the Arma 3 root folder. ⚠logNetwork can potentially create a large log file.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue LogNetwork(GameValue rightInstance)
        {
            return new GameValue(lognetwork(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Terminates a network log file started with logNetwork with the given handle
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LogNetworkTerminate(GameValue rightInstance)
        {
            return new GameValue(lognetworkterminate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Control what the unit(s) is/are looking at (target or Position). If target is used, it will get revealed fully.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LookAt(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lookat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Point the camera and center the map on the position. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue LookAtPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(lookatpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with magazines from ammo box (or any general weapon holder container).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazineCargo(GameValue rightInstance)
        {
            return new GameValue(magazinecargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of type names of all vehicle's magazines. When applied to a unit, the command behaves differently and will omit magazines already loaded into unit's weapons. Use currentMagazine to get this information for a currently loaded magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Magazines(GameValue rightInstance)
        {
            return new GameValue(magazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all magazines (including empty) from all vehicle turrets (including driver turret [-1]) and their ammo counts. Since Arma 3 v2.08.148327 it is possible to exclude person turrets from returned results.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesAllTurrets(GameValue rightInstance)
        {
            return new GameValue(magazinesallturrets(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all vehicle's magazines and their ammo count (also works on supply boxes). When applied to a unit (soldier), the command behaves differently and will omit magazines already loaded into unit's weapons. Use magazinesAmmoFull to return all magazines.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesAmmo(GameValue rightInstance)
        {
            return new GameValue(magazinesammo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of subarrays with the type names and ammo left of all the vehicle's cargo or container magazines.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesAmmoCargo(GameValue rightInstance)
        {
            return new GameValue(magazinesammocargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of arrays of all unit's or vehicle's magazines with extended information about them. The magazines returned are for primary gunner. If you need magazines for all turrets, see magazinesAllTurrets. ⚠This command does not return empty magazines from containers, only from the weapon. Use magazinesAmmoCargo instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesAmmoFull(GameValue rightInstance)
        {
            return new GameValue(magazinesammofull(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of strings with description of all vehicle's magazines, their ammo count (current/default) and their ids for the primary gunner.  When applied to a unit (soldier), the command behaves differently and will omit magazines already loaded into unit's weapons. Use currentMagazineDetail to get this information for a currently loaded magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesDetail(GameValue rightInstance)
        {
            return new GameValue(magazinesdetail(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array with the type names of all the unit's backpack magazines.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesDetailBackpack(GameValue rightInstance)
        {
            return new GameValue(magazinesdetailbackpack(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array with the type names of all the unit's uniform magazines.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesDetailUniform(GameValue rightInstance)
        {
            return new GameValue(magazinesdetailuniform(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array with the type names of all the unit's vest magazines.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesDetailVest(GameValue rightInstance)
        {
            return new GameValue(magazinesdetailvest(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all magazines of given turret. Use turret path [-1] for driver's turret. Alternatively, use magazinesAllTurrets. When main syntax is used, command excludes empty magazines for driver turret [-1] but returns empty magazines for all the other turrets.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MagazinesTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(magazinesturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns ammo count of given type from given turret  ⚠Broken when vehicle has multiple magazines of the same type.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MagazineTurretAmmo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(magazineturretammo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add next frame to map animation.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MapAnimAdd(GameValue rightInstance)
        {
            return new GameValue(mapanimadd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Clear map animation.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue MapAnimClear()
        {
            return new GameValue(mapanimclear());
        }

        /// <summary>
        /// Play map animation.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue MapAnimCommit()
        {
            return new GameValue(mapanimcommit());
        }

        /// <summary>
        /// Check if map animation is finished.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue MapAnimDone()
        {
            return new GameValue(mapanimdone());
        }

        /// <summary>
        /// ctrl mapCenterOnCamera enable syntax enables/disables continuous centering of the main map type control on the camera position. Needs to be executed once. mapCenterOnCamera ctrl syntax centers mini map type control on camera. The command returns world position of the camera. Needs to be executed each frame (preferably inside onDraw EH).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MapCenterOnCamera(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(mapcenteroncamera(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the map grid position of an object or position. The format is determined by the Grid format specified in the CfgWorlds for the current world. Eg: "024577" or "De82" or similar.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MapGridPosition(GameValue rightInstance)
        {
            return new GameValue(mapgridposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Marks current mission as finished on Steam. Returns true if Steam query is successfully started or false otherwise.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue MarkAsFinishedOnSteam()
        {
            return new GameValue(markasfinishedonsteam());
        }

        /// <summary>
        /// Gets the marker alpha. See setMarkerAlpha.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MarkerAlpha(GameValue rightInstance)
        {
            return new GameValue(markeralpha(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the marker brush. See setMarkerBrush.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MarkerBrush(GameValue rightInstance)
        {
            return new GameValue(markerbrush(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the channel that a marker belongs to.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MarkerChannel(GameValue rightInstance)
        {
            return new GameValue(markerchannel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns marker color for given marker. See also setMarkerColor.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MarkerColor(GameValue rightInstance)
        {
            return new GameValue(markercolor(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get marker direction.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MarkerDir(GameValue rightInstance)
        {
            return new GameValue(markerdir(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a polyline marker's path data.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MarkerPolyline(GameValue rightInstance)
        {
            return new GameValue(markerpolyline(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns marker position. See also setMarkerPos.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MarkerPos(GameValue rightInstance)
        {
            return new GameValue(markerpos(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if the marker is drawn with shadow enabled.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue MarkerShadow(GameValue rightInstance)
        {
            return new GameValue(markershadow(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the shape of given marker.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MarkerShape(GameValue rightInstance)
        {
            return new GameValue(markershape(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns marker size. This command is identical to getMarkerSize.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MarkerSize(GameValue rightInstance)
        {
            return new GameValue(markersize(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get marker text.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MarkerText(GameValue rightInstance)
        {
            return new GameValue(markertext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets type of marker. See CfgMarkers for a list of standard markers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MarkerType(GameValue rightInstance)
        {
            return new GameValue(markertype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns resulting matrix from the multiplication of two matrices. First matrix must be of the size n × k, while the second must be of the size k × m, i.e columns matrix1 == rows matrix2. The resulting matrix will be of the size n × m. If the shapes do not match, empty array [] will be returned.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MatrixMultiply(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(matrixmultiply(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        ///  Matrix transposition Returns transposed version of the given matrix. The matrix is an Array of rows. Each row is an Array of corresponding column values for the row. The minimum number of rows is 1.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MatrixTranspose(GameValue rightInstance)
        {
            return new GameValue(matrixtranspose(rightInstance._internalGameValue));
        }

        /// <summary>
        /// The greater value of a and b.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Max(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(max(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns maximum load limit for a unit, uniform/vest/backpack containers, vehicle cargo, supply boxes and weapon holders.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MaxLoad(GameValue rightInstance)
        {
            return new GameValue(maxload(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return a list of members in given team.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Members(GameValue rightInstance)
        {
            return new GameValue(members(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns action stored in item on given path in CT_MENU_STRIP control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MenuAction(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuaction(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds new submenu entry into item on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MenuAdd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuadd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if item on given path is checked or not.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue MenuChecked(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuchecked(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all entries from given menu strip.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuClear(GameValue rightInstance)
        {
            return new GameValue(menuclear(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Collapses item on given path and all its children.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuCollapse(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menucollapse(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns data stored in menu entry on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MenuData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menudata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Deletes menu entry on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuDelete(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menudelete(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables menu entry on given path. ⚠The old alternative syntax control menuEnable path is still in use and left for backward compatibility.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuEnable(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuenable(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if menu entry on given path is enabled or not.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue MenuEnabled(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuenabled(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Expands given menu entry on given path and all its parents so entry is visible.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuExpand(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuexpand(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns path to menu entry mouse is currently hovering over.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MenuHover(GameValue rightInstance)
        {
            return new GameValue(menuhover(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns picture set into item on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MenuPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menupicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets new action into menu entry on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSetAction(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusetaction(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets item on given path to be checked or not. By default menu strip entries are not checkable. Once this command was executed, an entry can become checked and unchecked. If an entry is checked is indicated by a tick to the left of the entry's text. Setting an entry to be checkable will overwrite set picture with menuSetPicture.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSetCheck(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusetcheck(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets data into menu entry on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSetData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusetdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets new picture into menu entry on given path. The picture will be replaced by a tick if the entry was set to checkable with menuSetCheck.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSetPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusetpicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets shortcut of given menu strip entry.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSetShortcut(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusetshortcut(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets text of given menu strip entry.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSetText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusettext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets weblink (URL) of given menu strip entry, subject to allowedHTMLLoadURIs[] whitelisting in CfgCommands config.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSetURL(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuseturl(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets new value into menu entry on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSetValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusetvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns shortcut related to menu entry on given path in form of a bitflag. To get the shortcut text use menuShortcutText.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MenuShortcut(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menushortcut(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a string containing shortcut text for menu item on the given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MenuShortcutText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menushortcuttext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns how many sub entries is in item on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MenuSize(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusize(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts subentries of item on given path by their text.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MenuSort(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menusort(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current text set in menu entry on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MenuText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menutext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current URL set in entry on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue MenuURL(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuurl(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current value set in menu entry on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MenuValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(menuvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Merges two HashMaps.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Merge(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(merge(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if the given mine is active.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue MineActive(GameValue rightInstance)
        {
            return new GameValue(mineactive(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if mine has been detected by a given side
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue MineDetectedBy(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(minedetectedby(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a guided missile's target.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue MissileTarget(GameValue rightInstance)
        {
            return new GameValue(missiletarget(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a guided missile's target position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue MissileTargetPos(GameValue rightInstance)
        {
            return new GameValue(missiletargetpos(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return root of mission Description.ext entries hierarchy. ⚠Since the introduction of the Eden Editor, scenario attributes can be configured in the editor itself, not only in the external Description.ext file. To access desired value independently on where it is stored, use the following commands: getMissionConfigValue getMissionConfig
        /// </summary>
        /// <returns>GameValue config</returns>
        public static GameValue MissionConfigFile()
        {
            return new GameValue(missionconfigfile());
        }

        /// <summary>
        /// Return difficulty that has been forced for this mission, returns -1 if difficulty is not forced and it is used one from player's options.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue MissionDifficulty()
        {
            return new GameValue(missiondifficulty());
        }

        /// <summary>
        /// Returns mission end type and how it was ended or an empty array [] is mission was not ended.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue MissionEnd()
        {
            return new GameValue(missionend());
        }

        /// <summary>
        /// Return currently loaded mission file (path to mission.pbo, relative to game exe).
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue MissionName()
        {
            return new GameValue(missionname());
        }

        /// <summary>
        /// Return workshop-compatible currently loaded mission file (path to mission.pbo, relative to game exe). missionName will return the Workshop user-friendly mission name, whereas missionNameSource will take the information from mission.sqm. pre-v2.02 missions may return an empty string.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue MissionNameSource()
        {
            return new GameValue(missionnamesource());
        }

        /// <summary>
        /// Returns the global namespace attached to mission.
        /// </summary>
        /// <returns>GameValue namespace</returns>
        public static GameValue MissionNamespace()
        {
            return new GameValue(missionnamespace());
        }

        /// <summary>
        /// This namespace has the same lifetime as profileNamespace but is also connected to the mission it is saved from. See saveMissionProfileNamespace for more details.
        /// </summary>
        /// <returns>GameValue namespace</returns>
        public static GameValue MissionProfileNamespace()
        {
            return new GameValue(missionprofilenamespace());
        }

        /// <summary>
        /// Returns date and time when mission started. Because this command returns the time of the actual start of the mission, it might not be available in pre-init or init, but is guaranteed to be available in post-init when time > 0.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue MissionStart()
        {
            return new GameValue(missionstart());
        }

        /// <summary>
        /// Returns the version of the current mission. Mission from the 2D Editor: 12 Mission from the Eden Editor: 15 and higher (for example current version for Eden Editor mission in Arma 3 v1.57 is 51)
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue MissionVersion()
        {
            return new GameValue(missionversion());
        }

        /// <summary>
        /// Remainder of a divided by b.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Mod(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(mod(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Translates relative position from object model space to world space in PositionAGL format. This command will take into account vectorUp of the object when calculating relative coordinates. For the PositionASL version of this command, see modelToWorldWorld. ⚠For scaled objects, the relative position will first be multiplied by the object scale. For example, if the object scale is 2, _obj modelToWorld [0,1,0] will be offset 2 meters from the model center ([0,0,0]).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ModelToWorld(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(modeltoworld(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts position from object model space to world space in render time scope. For ASL version see modelToWorldVisualWorld. ⚠For scaled objects, the relative position will first be multiplied by the object scale. For example, if the object scale is 2, _obj modelToWorldVisual [0,1,0] will be offset 2 meters from the model center ([0,0,0]).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ModelToWorldVisual(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(modeltoworldvisual(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts position from object model space to world space in render time scope. For the PositionAGL version see modelToWorldVisual. ⚠For scaled objects, the relative position will first be multiplied by the object scale. For example, if the object's scale is 2, _obj modelToWorldVisualWorld [0,1,0] will be offset 2 meters from the model center ([0,0,0]).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ModelToWorldVisualWorld(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(modeltoworldvisualworld(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts position from object model space to world space in PositionASL format from the object's centre position. ⚠For scaled objects, the relative position will first be multiplied by the object scale. For example, if the object scale is 2, _obj modelToWorldWorld [0,1,0] will be offset 2 meters from the model center ([0,0,0]).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ModelToWorldWorld(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(modeltoworldworld(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns list of mod parameters according to given options, values are in same order as the given options.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ModParams(GameValue rightInstance)
        {
            return new GameValue(modparams(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the intensity of the moon's brightness in range 0...1.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue MoonIntensity()
        {
            return new GameValue(moonintensity());
        }

        /// <summary>
        /// Returns the phase of the in-game Moon on the given date in range 0...1, where 0 - new Moon, 1 - full Moon. According to this command the fullest Moon in Arma 3 at midnight is on setDate [4804,7,13,0,0]; Use Moon Phase Utility to find out date for a mission with desired moon.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MoonPhase(GameValue rightInstance)
        {
            return new GameValue(moonphase(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get the provided unit's current morale level.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Morale(GameValue rightInstance)
        {
            return new GameValue(morale(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Let group move to given position. Active waypoints will be ignored when command is used.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Move(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(move(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves the Eden Editor camera.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Move3DENCamera(GameValue rightInstance)
        {
            return new GameValue(move3dencamera(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves unit to the first available seat in the specified vehicle. The order of priorities is the same order used in squad command when you order subordinates to get in vehicle to any position and is the same order used in Zeus when you drag units to a vehicle. Seat assignment seems to use the following priority logic: driver (moveInDriver) → commander (moveInCommander) → gunner (moveInGunner) → turrets (moveInTurret) → cargo (moveInCargo). ⚠If the unit is already in a vehicle, nothing will happen. You should use moveOut to move the unit out of his vehicle before trying to move him into a new (or same) vehicle. This command will move player into the locked vehicle or seat just as well.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue MoveInAny(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveinany(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves a unit into a vehicle cargo position (immediately and without animation). See AI Group Vehicle Management for more information. ⚠If the unit is already in a vehicle, nothing will happen. You should use moveOut to move the unit out of his vehicle before trying to move him into a new (or same) vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MoveInCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveincargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Move soldier into vehicle commander position (Immediate, no animation). ⚠If the unit is already in a vehicle, nothing will happen. You should use moveOut to move the unit out of his vehicle before trying to move him into a new (or same) vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MoveInCommander(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveincommander(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves soldier into vehicle driver position (immediate, no animation). See AI Group Vehicle Management for more information. ⚠If the unit is already in a vehicle, nothing will happen. You should use moveOut to move the unit out of his vehicle before trying to move him into a new (or same) vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MoveInDriver(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveindriver(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Move soldier into vehicle gunner position (Immediate, no animation). See AI Group Vehicle Management for more information. ⚠If the unit is already in a vehicle, nothing will happen. You should use moveOut to move the unit out of his vehicle before trying to move him into a new (or same) vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MoveInGunner(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveingunner(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves the soldier into the vehicle's turret. (Immediately, without animation). See AI Group Vehicle Management for more information. ⚠If the unit is already in a vehicle, nothing will happen. You should use moveOut to move the unit out of his vehicle before trying to move him into a new (or same) vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MoveInTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveinturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shifts an editor object to the end of the objects array. This means,that the object will be drawn last (after all other objects).  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MoveObjectToEnd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveobjecttoend(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves the soldier out of the vehicle. Notes: Works for both AI and player entities AI unit gets back in - unless is under player command or combined with other sqf commands (orderGetIn false, allowGetIn false or leaveVehicle) Respects the vehicle's lock state (same as action "Eject") - unlike doGetOut, commandGetOut. It will work for player entities regardless though Still executes when the vehicle is moving/flying (same as action "Eject") - unlike doGetOut, commandGetOut Without vehicle's position's get out animation - unlike action eject, doGetOut, commandGetOut Immediately - unlike action eject, doGetOut, commandGetOut Works also on dead units (same as action "Eject" (but one after another)) - unlike doGetOut, commandGetOut Does not work for UAV crew Does not work for remoteControlled units Works on unconscious (same as action "Eject" (but one after another)) - unlike doGetOut, commandGetOut (unless AI under player command)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MoveOut(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveout(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current time of the most important RTM animation currently being played on the soldier.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue MoveTime(GameValue rightInstance)
        {
            return new GameValue(movetime(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Low level command to person to move to given position.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue MoveTo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(moveto(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if latest low level moveTo command is finished.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue MoveToCompleted(GameValue rightInstance)
        {
            return new GameValue(movetocompleted(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if latest low level moveTo command failed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue MoveToFailed(GameValue rightInstance)
        {
            return new GameValue(movetofailed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current music volume (set by fadeMusic)
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue MusicVolume()
        {
            return new GameValue(musicvolume());
        }

        /// <summary>
        /// When argument is Object, the command returns the name given to a unit using the setIdentity instruction or selected randomly by the game engine if setIdentity has not been used on the unit. If used on vehicle, name of first crew member (in order commander, driver, gunner). If used on an object, "Error: No unit" is being returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Name(GameValue rightInstance)
        {
            return new GameValue(name(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of named properties on Geometry LOD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NamedProperties(GameValue rightInstance)
        {
            return new GameValue(namedproperties(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the nameSound of a person.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue NameSound(GameValue rightInstance)
        {
            return new GameValue(namesound(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Finds entities inside a sphere with the given radius. If the alternative syntax is used, only entities of given types or subtypes are listed. Entities returned are not sorted by distance. This command doesn't return dead entities or entities inside vehicles. If you need to return those, use entities command.This command is much  faster than nearestObjects for on-foot soldier and vehicle detection.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearEntities(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(nearentities(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Finds the nearest building to a given object or position. A "building" is defined as an object that is of class "House" and contains a path LOD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue NearestBuilding(GameValue rightInstance)
        {
            return new GameValue(nearestbuilding(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the closest location of specified class to a given position. Checked range is unlimited (i.e. covers the whole map).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue location</returns>
        public static GameValue NearestLocation(GameValue rightInstance)
        {
            return new GameValue(nearestlocation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of locations of chosen type(s) within the given radius of the given position, sorted from nearest to farthest. Although locations can be placed in 3D with setPosition, nearestLocations search result is sorted in 2D.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearestLocations(GameValue rightInstance)
        {
            return new GameValue(nearestlocations(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Find the nearest location having a non-empty speech. No locations are dubbed in Arma 3.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue location</returns>
        public static GameValue NearestLocationWithDubbing(GameValue rightInstance)
        {
            return new GameValue(nearestlocationwithdubbing(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of nearest mines of the given types to the given position or object, within the specified distance. If more than one mine are found they will be ordered by proximity by default, the closest one will be first in the array. The sorting can be turned off.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearestMines(GameValue rightInstance)
        {
            return new GameValue(nearestmines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the nearest object of given type (or inherited classes) to given position within a sphere. Hardcoded radius is 50 meters. Unlike with nearestObjects, where distance is measured in 2D space, nearestObject will be closest object in 3D space. in Operation Flashpoint, only objects of the exact provided class are found. if an object ID is used (Syntax 4, see Example 2) the search range is unlimited
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue NearestObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(nearestobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of nearest objects of the given types to the given position or object, within the specified distance. If more than one object is found they will be ordered by proximity, the closest one will be first in the array. If an object is given as the center and the filter criteria applies to it, it will be the first result in the list. Alternatively, you can use nearObjects command, which doesn't sort results. A list of ClassName types (e.g Tank) can be found in CfgVehicles. ⚠This command matches objects using isKindOf comparison instead of direct class name == comparison. As a result, if a class type is a parent, the search will return all objects that inherit from the parent as well as parent itself. This command also only finds objects that are entities. If you are looking for non-entity objects, see nearObjects, nearestObject. ⚠Because of map object streaming, using nearestObjects or similar object finding commands over long distance from player camera may not find what you are looking for, as some objects might not exist at the time of command execution. Use nearestTerrainObjects instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearestObjects(GameValue rightInstance)
        {
            return new GameValue(nearestobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of nearest terrain objects of the given types to the given position or object, within the specified distance. If more than one object is found they will be ordered according to 3D distance to the object (i.e. the closest one will be first in the array).  In contrast to nearestObjects this command returns terrain placed objects like trees, rocks and buildings which don't necessarily need an associated config class. Possible type names: "BUILDING" "BUNKER" "BUSH" "BUSSTOP" "CHAPEL" "CHURCH" "CROSS" "FENCE" "FOREST BORDER" "FOREST SQUARE" "FOREST TRIANGLE" "FOREST" "FORTRESS" "FOUNTAIN" "FUELSTATION" "HIDE" "HOSPITAL" "HOUSE" "LIGHTHOUSE" "MAIN ROAD" "POWER LINES" "POWERSOLAR" "POWERWAVE" "POWERWIND" "QUAY" "RAILWAY" "ROAD" "ROCK" "ROCKS" "RUIN" "SHIPWRECK" "SMALL TREE" "STACK" "TOURISM" "TRACK" "TRAIL" "TRANSMITTER" "TREE" "VIEW-TOWER" "WALL" "WATERTOWER" ⚠The names are / The filter is based on the named property map - not on the named property class or any config definition! Terrain object counts Types which are missing are not present in the given world. Virtual Reality has no terrain objects. Last updated 1.99 Stratis BUSH: 47974 CHAPEL: 2 CROSS: 1 FENCE: 1728 FUELSTATION: 3 HIDE: 70975 HOUSE: 684 LIGHTHOUSE: 3 ROAD: 143 ROCK: 820 SHIPWRECK: 11 TRACK: 2063 TRANSMITTER: 11 TREE: 40110 WALL: 1355 WATERTOWER: 1 Altis BUSH: 747193 CHAPEL: 165 CHURCH: 54 CROSS: 48 FENCE: 47940 FUELSTATION: 32 HIDE: 655958 HOSPITAL: 1 HOUSE: 17472 LIGHTHOUSE: 7 MAIN ROAD: 2061 POWER LINES: 2224 POWERSOLAR: 10 POWERWAVE: 51 POWERWIND: 128 ROAD: 4849 ROCK: 5483 RUIN: 3 SHIPWRECK: 43 TOURISM: 1 TRACK: 26823 TRANSMITTER: 23 TREE: 263630 WALL: 38943 WATERTOWER: 10 Malden 2035 BUSH: 288461 BUSSTOP: 45 CHAPEL: 14 CHURCH: 14 CROSS: 16 FENCE: 11189 FUELSTATION: 24 HIDE: 192553 HOUSE: 4062 LIGHTHOUSE: 15 MAIN ROAD: 1050 POWER LINES: 3427 POWERSOLAR: 1 ROAD: 1442 ROCK: 3513 SHIPWRECK: 23 TRACK: 3489 TRANSMITTER: 7 TREE: 101960 WALL: 14189 WATERTOWER: 63 Tanoa BUSH: 754347 CHURCH: 21 FENCE: 2912 FUELSTATION: 85 HIDE: 356904 HOUSE: 13389 MAIN ROAD: 2921 POWER LINES: 3985 POWERSOLAR: 2 POWERWIND: 19 RAILWAY: 2138 ROAD: 1485 ROCK: 8909 SHIPWRECK: 58 TOURISM: 35 TRACK: 9419 TRAIL: 6936 TRANSMITTER: 16 TREE: 506993 WALL: 20526 WATERTOWER: 73 Livonia BUILDING: 1262 BUNKER: 40 BUSH: 473543 BUSSTOP: 73 CHAPEL: 8 CHURCH: 17 FENCE: 48426 FOUNTAIN: 36 FUELSTATION: 7 HIDE: 474123 HOUSE: 6762 MAIN ROAD: 2118 POWER LINES: 2671 POWERSOLAR: 2 POWERWIND: 1 RAILWAY: 843 ROAD: 5378 ROCK: 744 SHIPWRECK: 4 STACK: 11 TRACK: 12834 TRANSMITTER: 15 TREE: 1881630 VIEW-TOWER: 239 WALL: 4418 WATERTOWER: 7 Weferlingen BUILDING: 5072 BUSH: 731315 BUSSTOP: 106 CHAPEL: 13 CHURCH: 21 FENCE: 83908 FUELSTATION: 9 HIDE: 231818 HOUSE: 4562 MAIN ROAD: 1535 POWER LINES: 1958 RAILWAY: 2324 ROAD: 8740 STACK: 18 TRACK: 24372 TRANSMITTER: 1 TREE: 829449 VIEW-TOWER: 34 Weferlingen (Winter) BUILDING: 5072 BUSH: 519827 BUSSTOP: 106 CHAPEL: 13 CHURCH: 21 FENCE: 83908 FUELSTATION: 9 HIDE: 229792 HOUSE: 4562 MAIN ROAD: 1535 POWER LINES: 1958 RAILWAY: 2324 ROAD: 8740 STACK: 18 TRACK: 24372 TRANSMITTER: 1 TREE: 829449 VIEW-TOWER: 34 Extraction script can be found on the Biki Export Scripts page.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearestTerrainObjects(GameValue rightInstance)
        {
            return new GameValue(nearestterrainobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Find objects (Units, Vehicles, Dead, Map Objects) in a sphere with given radius. The first object in the returned array is not necessarily the closest one. If you need returned objects to be sorted by distance, use nearestObjects. If typeName is given, only objects of given type (or its subtype) are listed.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearObjects(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(nearobjects(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check whether all data are loaded to nearObjects will return in reasonable time.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue NearObjectsReady(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(nearobjectsready(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Find the road segments within the circle of given radius.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearRoads(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(nearroads(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Find supplies (weapon holders, ammo crates, fuel feeds, other units) in the sphere with given radius.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearSupplies(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(nearsupplies(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of targets within the defined range. "Targets" are not restricted to enemy units.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NearTargets(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(neartargets(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns how much vehicle wants to reload its weapons.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue NeedReload(GameValue rightInstance)
        {
            return new GameValue(needreload(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with how much vehicle needs repairing, refueling and rearming.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NeedService(GameValue rightInstance)
        {
            return new GameValue(needservice(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unique ID of object or group.  As this command is MP only, you can use BIS_fnc_netId, which extends the use to SP as well. See also: BIS_fnc_objectVar
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue NetId(GameValue rightInstance)
        {
            return new GameValue(netid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates the new overlay dialog for the specified type of overlay.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue NewOverlay(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(newoverlay(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the next available menu item index. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue NextMenuItemIndex(GameValue rightInstance)
        {
            return new GameValue(nextmenuitemindex(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the remaining time (in seconds) over which the current weather change will occur. When a weather change finishes, the game engine will automatically generate a new random weather change over a realistic time period (minimum of 90 minutes).
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue NextWeatherChange()
        {
            return new GameValue(nextweatherchange());
        }

        /// <summary>
        /// Nil value. This value can be used to undefine existing variables.
        /// </summary>
        /// <returns>GameValue any</returns>
        public static GameValue Nil()
        {
            return new GameValue(nil());
        }

        /// <summary>
        /// Returns the total number of user-added menu items belonging to the given menu. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue NMenuItems(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(nmenuitems(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// not a is exactly the same as ! a.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Not(GameValue rightInstance)
        {
            return new GameValue(not(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the number of engines a helicopter has. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue NumberOfEnginesRTD(GameValue rightInstance)
        {
            return new GameValue(numberofenginesrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Convert float number to a date.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue NumberToDate(GameValue rightInstance)
        {
            return new GameValue(numbertodate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all curators which can edit given object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ObjectCurators(GameValue rightInstance)
        {
            return new GameValue(objectcurators(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get object with given unique ID. If object is a group use groupFromNetId. As this command is MP only, you can use BIS_fnc_objectFromNetId, which extends the use to SP as well.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue ObjectFromNetId(GameValue rightInstance)
        {
            return new GameValue(objectfromnetid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the parent of an object if said object is a proxy. ⚠Use objectParent instead of vehicle to get a soldier's vehicle. Apart from being faster it is also more reliable, as when used on dead crew, vehicle command may surprisingly return the unit itself. To delete a unit which is in a vehicle, execute: objectParent _unit deleteVehicleCrew _unit;
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue ObjectParent(GameValue rightInstance)
        {
            return new GameValue(objectparent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A non-existent Object. To compare non-existent objects use isNull or isEqualTo: objNull == objNull;			// false isNull objNull;				// true objNull isEqualTo objNull;	// true
        /// </summary>
        /// <returns>GameValue object</returns>
        public static GameValue ObjNull()
        {
            return new GameValue(objnull());
        }

        /// <summary>
        /// Sets the status of an objective that was defined in briefing.html. Status may be one of: "ACTIVE" "FAILED" "DONE" "HIDDEN" To refer to an objective that is named "OBJ_1", for example, use only the index number in this command (i.e. "1" objStatus "HIDDEN").
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ObjStatus(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(objstatus(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Select a sound declared in the Description.ext of the mission to be played the first time the Group tab is selected in the briefing.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnBriefingGroup(GameValue rightInstance)
        {
            return new GameValue(onbriefinggroup(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Select a sound declared in the Description.ext of the mission to be played the first time the Notes tab is selected in the briefing.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnBriefingNotes(GameValue rightInstance)
        {
            return new GameValue(onbriefingnotes(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Select a sound declared in the Description.ext of the mission to be played the first time the Plan tab is selected in the briefing.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnBriefingPlan(GameValue rightInstance)
        {
            return new GameValue(onbriefingplan(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Select a sound defined in the CfgSounds of the mission to be played the first time the TeamSwitch tab is selected in the briefing.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnBriefingTeamSwitch(GameValue rightInstance)
        {
            return new GameValue(onbriefingteamswitch(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines code performed when hc command mode changes either because of (Left Ctrl + Space) shortcut or hcShowBar scripting command. Groups hc mode must contain at least one group for this command to work (see High Command). Attached code receives _isHighCommand boolean.  Since Arma 3 v1.57 a stackable version of this EH is available: CommandModeChanged
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnCommandModeChanged(GameValue rightInstance)
        {
            return new GameValue(oncommandmodechanged(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed when the user double clicks on the map. Command receives:,_pos array position,_units array selected units,_shift,_alt bool key state Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue OnDoubleClick(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ondoubleclick(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Runs given statement every frame in an unscheduled environment. In order to keep compatibility between official and community content: Since Arma 3 v1.57 a stackable version of this EH is available: EachFrame Mission Event Handler Before that, the scripted version of the event handler should be used instead (using BIS_fnc_addStackedEventHandler and BIS_fnc_removeStackedEventHandler).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnEachFrame(GameValue rightInstance)
        {
            return new GameValue(oneachframe(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed when player clicked on group marker (3D or in a map). The code executed once. This EH, unlike onGroupIconOverEnter and onGroupIconOverLeave, has one more param which returns 1 if RMB was pressed, 0 otherwise. Since Arma 3 v1.58 a Mission Event Handler exists and should be used.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnGroupIconClick(GameValue rightInstance)
        {
            return new GameValue(ongroupiconclick(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed when player moves pointer over group marker (3D or in a map). The code will execute continuously while pointer is over icon. Since Arma 3 v1.58 a Mission Event Handler exists and should be used.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnGroupIconOverEnter(GameValue rightInstance)
        {
            return new GameValue(ongroupiconoverenter(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed when pointer, previously positioned over icon, is moved away from it (3D or in a map). The code is executed once. Since Arma 3 v1.58 a Mission Event Handler exists and should be used.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnGroupIconOverLeave(GameValue rightInstance)
        {
            return new GameValue(ongroupiconoverleave(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed when high command group selection has been changed. Command receives 2 variables: _group: Group - last selected/deselected group _isSelected: Boolean - new selection state of the specific group The code is executed on every hc group selection change until it is replaced or removed (see Example 3). ⚠Using the command again will overwrite the previously set code. Since Arma 3 v1.58 a stackable version of this EH is available: HCGroupSelectionChanged
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnHCGroupSelectionChanged(GameValue rightInstance)
        {
            return new GameValue(onhcgroupselectionchanged(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines the action performed when user clicks in map by executing command string. The code is executed on every click, until the command is  removed via onMapSingleClick "", or replaced by onMapSingleClick "SomeOtherCommand(s)" In Arma 3 the code should return true only if you wish to override default engine handling of the mouse click on map (see Example 4). For older games, when click is processed, code should ultimately return true back to the engine. If false is returned, default processing by the game engine is done. Return value of any other type (including Nothing) is an error. In such case default processing by the game engine is done, and error message may be displayed. Since 1.58 the stackable MapSingleClick Mission Event Handler is available and should be used instead.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnMapSingleClick(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(onmapsingleclick(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// This command will execute the provided code on the server whenever a player connects to a multiplayer session. Since Arma 3 v1.57 a stackable MissionEventHandler is available and should be used: PlayerConnected.Before that, the functions BIS_fnc_addStackedEventHandler and BIS_fnc_removeStackedEventHandler should be used instead in order to keep compatibility between official and community content.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnPlayerConnected(GameValue rightInstance)
        {
            return new GameValue(onplayerconnected(rightInstance._internalGameValue));
        }

        /// <summary>
        /// This command will execute attached code whenever a player is leaving an MP session. The code will receive a number of special variables:
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnPlayerDisconnected(GameValue rightInstance)
        {
            return new GameValue(onplayerdisconnected(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed after the preload screen finished. Preload event occurs after briefing screen on mission start. ⚠This event handler also fires on client after user closes the main map. Since Arma 3 v1.57 a stackable version of this EH is available: PreloadFinished Before that, the BIS_fnc_addStackedEventHandler and BIS_fnc_removeStackedEventHandler functions should be used instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnPreloadFinished(GameValue rightInstance)
        {
            return new GameValue(onpreloadfinished(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed just before the preload screen started. Preload event occurs after briefing screen on mission start.⚠This event handler also fires on client after user closes the main map. Since Arma 3 v1.57 a stackable version of this EH is available: PreloadStarted In order to keep compatibility between official and community content the functions BIS_fnc_addStackedEventHandler and BIS_fnc_removeStackedEventHandler should be used instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnPreloadStarted(GameValue rightInstance)
        {
            return new GameValue(onpreloadstarted(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed when the user right clicks on the map and,selects New Object. Set to empty for default behavior. Command receives:,_pos array position,  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue OnShowNewObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(onshownewobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines an action performed when the team switch is finished. Commandset receives the following special variables: _from object previous unit, _to object current unit. Consecutive use of onTeamSwitch command will overwrite previously set commandset.  ⚠This command is deprecated. Since Arma 3 v1.57 a stackable version of this EH is available: TeamSwitch When player switches and leaves behind AI unit, you need to enable "TeamSwitch" AI on it (with onTeamSwitch { _from enableAI "TeamSwitch" };) so that the unit continues with waypoints.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OnTeamSwitch(GameValue rightInstance)
        {
            return new GameValue(onteamswitch(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Force opens curator interface.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue OpenCuratorInterface()
        {
            return new GameValue(opencuratorinterface());
        }

        /// <summary>
        /// Opens a Steam page of the app with given appId. Only works for known appId (game + linked DLCs)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue OpenDLCPage(GameValue rightInstance)
        {
            return new GameValue(opendlcpage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Opens or closes minimap if player has "ItemGPS" linked in inventory and "MinimapDisplayComponent" is not disabled with enableInfoPanelComponent. Returns true on success. If more than one minimap is open (see infoPanels, infoPanel) each call to the command will close only 1 minimap. Visibility of minimap can be checked with visibleGPS command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue OpenGPS(GameValue rightInstance)
        {
            return new GameValue(opengps(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Opens or closes in-game map.⚠If forced param is set to true and map is set to open, when the map is opened it cannot be closed manually and the user can get stuck requiring the game restart. Make sure you provide scripted mechanics to resolve this, should you need to force the map. Useful when you wish to keep user for example on respawn screen, where they could still interact with the map but cannot enter the game until the time is up Since Arma 3 v2.06.147984 the alternative syntax has the following functionality: openMap [true, false] - opens map normally openMap [false, false] - closes opened map normally openMap [true, true] - force opens map and keeps open (the user cannot close it on their own) New openMap [false, true] - prevents map from opening, closes open map and forces it to stay close (the user cannot open it on their own)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue OpenMap(GameValue rightInstance)
        {
            return new GameValue(openmap(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Opens a Steam application, returns false if it was not possible to run the application.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue OpenSteamApp(GameValue rightInstance)
        {
            return new GameValue(opensteamapp(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Opens Steam overlay with given YT video. Video URL is the end part of the YT URL, starting with watch?v=.... If the user has Steam overlay disabled, the command will display appropriate message to the user and return false.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue OpenYoutubeVideo(GameValue rightInstance)
        {
            return new GameValue(openyoutubevideo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Pre-defined variable for the opfor side.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue Opfor()
        {
            return new GameValue(opfor());
        }

        /// <summary>
        /// Returns true if one or both conditions are true. In case of the alternative syntax, lazy evaluation is used. That means that if left operand is true, evaluation of the right side is skipped completely.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Or(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(or(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Force all units in the array to get in or out of their assigned vehicles. Units must be assigned to a vehicle before this command will do anything. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue OrderGetIn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ordergetin(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the current overcast level. Zero is clear skies, one is maximum cloud cover.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Overcast()
        {
            return new GameValue(overcast());
        }

        /// <summary>
        /// Return the overcast forecast.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue OvercastForecast()
        {
            return new GameValue(overcastforecast());
        }

        /// <summary>
        /// On server machine, returns the  machine network ID of the client to which the object is local. Otherwise returns 0. For use on clients clientOwner command is available. To find out the owner of a Group, use groupOwner.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Owner(GameValue rightInstance)
        {
            return new GameValue(owner(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Extracts a single value with given index from input argument, similar to BIS_fnc_param.  When used without argument, as shown in main syntax, internal variable _this, which is usually available inside functions and event handlers, is used as argument. If input argument is not an array, it will be converted to 1 element array. If extracted item of input with given index is undefined, of the wrong type or of the wrong length (if the item is an array), default value is used instead. Since Arma 3 v1.54, onscreen errors are displayed for when the input is of the wrong type or size.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue Param(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(param(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Parses the string, interpreting its content as a floating point number. ⚠This command does not work with strings representing hexadecimal numbers (e.g "0xCF"). Starting whitespaces are discarded, then as many valid characters are used to be interpreted as a number until an invalid character is found then the rest of the string is ignored.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue ParseNumber(GameValue rightInstance)
        {
            return new GameValue(parsenumber(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts given, formatted as simple array, String into a valid Array. Simple array is array consisting of Numbers, Strings, Booleans and Arrays of all of the above. This command is almost 4× faster than similar uncached call compile method. And because call compile is not required, it is also more secure and primarily intended for use with callExtension to parse the String output into Array. Since Arma 3 v1.96 the command will tolerate extra spaces and supports single quotes. The only recognised keywords (case insensitive) are: true - translates into true false - translates into false nil - translates into nil null - translates into nil <null> - translates into nil any - translates into nil
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ParseSimpleArray(GameValue rightInstance)
        {
            return new GameValue(parsesimplearray(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a structured text by parsing the given XML description. Do not use parseText when displaying a localized text from Stringtable.xml. A detailed explanation of all formatting possibilities can be found at Structured Text.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue text</returns>
        public static GameValue ParseText(GameValue rightInstance)
        {
            return new GameValue(parsetext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the global namespace attached to config parser.
        /// </summary>
        /// <returns>GameValue namespace</returns>
        public static GameValue ParsingNamespace()
        {
            return new GameValue(parsingnamespace());
        }

        /// <summary>
        /// Returns current user settings for particles quality (configure->video->general->particles). 0-low, 1-normal, 2-high
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue ParticlesQuality()
        {
            return new GameValue(particlesquality());
        }

        /// <summary>
        /// Returns current periscope elevation value, see also elevatePeriscope.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PeriscopeElevation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(periscopeelevation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// pi (180 degrees converted to Radians).
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Pi()
        {
            return new GameValue(pi());
        }

        /// <summary>
        /// Transfers weapons and magazines from cargo of object into the weapon pool. This is used in the campaign to transfer weapons into the next mission.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PickWeaponPool(GameValue rightInstance)
        {
            return new GameValue(pickweaponpool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the pitch of a persons voice.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Pitch(GameValue rightInstance)
        {
            return new GameValue(pitch(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns grid size based on screen resolution, UI size and configs: uiScaleFactor, uiScaleMaxGrids.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue PixelGrid()
        {
            return new GameValue(pixelgrid());
        }

        /// <summary>
        /// Returns grid size based on screen resolution.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue PixelGridBase()
        {
            return new GameValue(pixelgridbase());
        }

        /// <summary>
        /// Returns grid size based on screen resolution and configs: uiScaleFactor, uiScaleMaxGrids. As mentioned in the name of this command, the user interface scale is ignored.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue PixelGridNoUIScale()
        {
            return new GameValue(pixelgridnouiscale());
        }

        /// <summary>
        /// Returns the height of one pixel for current resolution.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue PixelH()
        {
            return new GameValue(pixelh());
        }

        /// <summary>
        /// Returns width of one pixel for current resolution.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue PixelW()
        {
            return new GameValue(pixelw());
        }

        /// <summary>
        /// Returns the number of available slots in mission per side (both empty and taken). In singleplayer mission, it returns number of playable units per side.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue PlayableSlotsNumber(GameValue rightInstance)
        {
            return new GameValue(playableslotsnumber(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of playable units in a multiplayer game (occupied by both AI or players), created on the following sides east/opfor, west/blufor, resistance/independent and civilian only. Does not contain units of sideLogic. This command returns an empty array in Singleplayer; use switchableUnits instead. ⚠This command does not include dead players awaiting for respawn.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue PlayableUnits()
        {
            return new GameValue(playableunits());
        }

        /// <summary>
        /// When used on a person, a smooth transition to the given action will be initiated. For Arma 3 actions see: playAction/actions.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlayAction(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(playaction(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// When used on a person, a smooth transition to the given action will be initiated, but all previous playAction are discarded. For Arma 3 actions see: playAction/actions.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlayActionNow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(playactionnow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// A person object controlled by user. In Intros and Outros this isn't set by default and must be assigned.
        /// </summary>
        /// <returns>GameValue object</returns>
        public static GameValue Player()
        {
            return new GameValue(player());
        }

        /// <summary>
        /// Return the player's remaining time before respawn, or -1 if it is not available (such as when the player is alive).
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue PlayerRespawnTime()
        {
            return new GameValue(playerrespawntime());
        }

        /// <summary>
        /// Returns the player's side. This is valid even when the player controlled person is dead (a difference from side player). playerSide will not change automatically if player joins a group on different side. However, selectPlayer command can and does change playerSide - see Example 3 for information.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue PlayerSide()
        {
            return new GameValue(playerside());
        }

        /// <summary>
        /// Returns count of occupied role selection slots for given side. Players who claimed a slot in the lobby but did not start the mission are counted as well. If disabledAI = 0; in description.ext or Enable AI option is checked in Eden Editor, AI bots will be treated as valid players and will be counted too.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue PlayersNumber(GameValue rightInstance)
        {
            return new GameValue(playersnumber(rightInstance._internalGameValue));
        }

        /// <summary>
        /// When used on a person,a smooth transition to the given move will be initiated. Command doesn't seem to be functional
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlayGesture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(playgesture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// The mission is launched (from the main menu). Both campaign and mission are given as their directory name. If the campaign is empty, a single mission is launched. If skipBriefing is true, the intro and briefing are skipped.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlayMission(GameValue rightInstance)
        {
            return new GameValue(playmission(rightInstance._internalGameValue));
        }

        /// <summary>
        /// When used on a person, smooth transition to given move will be done. The difference between playMove and playMoveNow is that playMove adds another move to the move queue, while playMoveNow replaces the whole move queue with new move (see Example 2). see Moves for respective games animations.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlayMove(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(playmove(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// When used on a person,a smooth transition to the given move will be initiated, but all previous playMove are discarded.  The difference between playMove and playMoveNow is that playMove adds another move to the move queue, while playMoveNow replaces the whole move queue with new move (see Example 2). see Moves for respective games animations.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlayMoveNow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(playmovenow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Plays music defined in Description.ext's CfgMusic or config.cpp. If the musicName could not be found a message is logged into the .rpt file: Music <musicName> not found. Arma 3 CfgMusic Arma 2: CfgMusic ArmA: Armed Assault: CfgMusic Operation Flashpoint: CfgMusic To stop the music, use playMusic "";.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlayMusic(GameValue rightInstance)
        {
            return new GameValue(playmusic(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Load the given world, launch an empty mission, and execute the given expression. If provided, config can reference to the config entry, replacing Description.ext for this mission.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlayScriptedMission(GameValue rightInstance)
        {
            return new GameValue(playscriptedmission(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Plays a sound from CfgSounds. Sound can be defined in missionConfigFile, configFile or campaignConfigFile.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue PlaySound(GameValue rightInstance)
        {
            return new GameValue(playsound(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Plays positional sound with given filename on every computer on network. Since Arma 2.10 the leading slash in file path will be ignored.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlaySound3D(GameValue rightInstance)
        {
            return new GameValue(playsound3d(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Plays given CfgSounds sound or a  sound file given by file path through a dedicated UI sound channel unaffected by the global mixer volumes. If the file path is given, the leading slash will be ignored.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PlaySoundUI(GameValue rightInstance)
        {
            return new GameValue(playsoundui(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the pose of the given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Pose(GameValue rightInstance)
        {
            return new GameValue(pose(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns position of an object (alias of getPos) or location (alias of locationPosition). ⚠Do not use this command to get an object's position in 3D. See getPos for an explanation and alternatives.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Position(GameValue rightInstance)
        {
            return new GameValue(position(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Transforms position from camera coordinate space to world coordinate space.  Camera axes are relative to camera orientation. x axis goes from left of the camera to right of the camera, z axis goes from underneath the camera to above the camera and y axis goes from back of the camera to where the camera is looking.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue PositionCameraToWorld(GameValue rightInstance)
        {
            return new GameValue(positioncameratoworld(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts map screen coordinates into world coordinates. Unlike ctrlMapScreenToWorld, this command returns world position is format [x, y, 0], otherwise it is identical to it.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue PosScreenToWorld(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(posscreentoworld(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts world coordinates into map screen coordinates. This command is identical to ctrlMapWorldToScreen.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue PosWorldToScreen(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(posworldtoscreen(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set post process effect parameters. The two syntaxes differ in what format of the params they accept. The syntax with PP name expects colors to be packed into arrays within main array, while the syntax with PP handle can handle both flat and packed array. Therefore it is recommended to use the universal packed format, such as shown in the examples.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PpEffectAdjust(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ppeffectadjust(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Commit post process effect in given time.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PpEffectCommit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ppeffectcommit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check whether given post process effect is committed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue PpEffectCommitted(GameValue rightInstance)
        {
            return new GameValue(ppeffectcommitted(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates Post Process Effects specified by effect name and priority. Supported effects: "RadialBlur" "ChromAberration" "WetDistortion" "ColorCorrections" "DynamicBlur" "FilmGrain" "ColorInversion"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_array</returns>
        public static GameValue PpEffectCreate(GameValue rightInstance)
        {
            return new GameValue(ppeffectcreate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Destroy Post Process Effects given by handle or array of handles.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PpEffectDestroy(GameValue rightInstance)
        {
            return new GameValue(ppeffectdestroy(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable / disable Post Process Effects ⚠If effect fails to get enabled (can check it with ppEffectEnabled) try adding a little sleep in front of it.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PpEffectEnable(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ppeffectenable(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether given post process effect is enabled
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue PpEffectEnabled(GameValue rightInstance)
        {
            return new GameValue(ppeffectenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces use of Post Process Effects in NVG.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PpEffectForceInNVG(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ppeffectforceinnvg(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the movement precision of the given entity, how is the entity able to be precise when moving to given target. See CfgVehicles Config Reference - precision.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Precision(GameValue rightInstance)
        {
            return new GameValue(precision(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Preload all textures and models around given Position to avoid visual artifacts after camera is moved. Should be used before any abrupt camera change/cut. Returns true once all data is ready. See camPreload for alternative, more flexible camera preloading.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue PreloadCamera(GameValue rightInstance)
        {
            return new GameValue(preloadcamera(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Preloads all textures, materials and proxies needed to render given object. Works with objects and classnames - note that classnames require an object instance in the mission.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue PreloadObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(preloadobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Makes sure that a sound can start playing without any delay once it is needed. Command works in Arma 3, but might not be implemented in earlier Arma installments.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue PreloadSound(GameValue rightInstance)
        {
            return new GameValue(preloadsound(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Preloads data for the given resource object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue PreloadTitleObj(GameValue rightInstance)
        {
            return new GameValue(preloadtitleobj(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Resource title - preload data. The resource can be defined in the Description.ext file.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue PreloadTitleRsc(GameValue rightInstance)
        {
            return new GameValue(preloadtitlersc(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Reads and processes the content of the specified file. Preprocessor is C-like, supports comments using // or /* and */ and PreProcessor Commands. Due to the hard-drive access this command executes and the lack of caching this command should not be used in time-critical script loops. ⚠If the file you are loading is not prepared using UTF-8 encoding and contains some characters  with codes > 127, they might convert incorrectly.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue PreprocessFile(GameValue rightInstance)
        {
            return new GameValue(preprocessfile(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the preprocessed content of the given file. The preprocessor is C-like, it supports comments using /* */ and PreProcessor Commands. The preprocessor also adds a default debug entrypoint for compiler at the begining of script: #line 1 "aFilename" The #line keyword can be used in any script that are not preprocess, or with preprocess script with extra macro to protect reserverd sharp character. The format is: #line <number> "<name>" followed by new line. <number> could be only positive integer and <name> could be any name. This will be used only if an error occurs in the script. The error will contain the line: File <filename>, line <linenumber> where <filename> will be the <name> you set and <linenumber> will be <number> + how many lines it is from the #line line. If the error happened on the line right under #line it will add 0 to <number>, if on second line, it will add 1 etc. It is possible to use more than one #line keywords, but it seems having just one at the top for little script is enough to pinpoint position of the error easily.  ⚠If the file you are loading is not prepared using UTF-8 encoding and contains some characters  with codes > 127, they might convert incorrectly
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue PreprocessFileLineNumbers(GameValue rightInstance)
        {
            return new GameValue(preprocessfilelinenumbers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns name of unit's primary weapon. This command will also return a weapon class name if the weapon is not used by the player, for example, it is on the unit's back. Use currentWeapon to get the weapon the unit is using.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue PrimaryWeapon(GameValue rightInstance)
        {
            return new GameValue(primaryweapon(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all items assigned to the primaryWeapon except magazines. Use primaryWeaponMagazine command for the latter. This command is used for infantry weapons only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue PrimaryWeaponItems(GameValue rightInstance)
        {
            return new GameValue(primaryweaponitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Collects all loaded magazines from all primaryWeapon muzzles and returns them in Array, otherwise it returns []. This command is used for infantry weapons only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue PrimaryWeaponMagazine(GameValue rightInstance)
        {
            return new GameValue(primaryweaponmagazine(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the priority of the task.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Priority(GameValue rightInstance)
        {
            return new GameValue(priority(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Opens the Diary screen on the subject/record specified by link. To get a valid link format, use createDiaryLink.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ProcessDiaryLink(GameValue rightInstance)
        {
            return new GameValue(processdiarylink(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the product's friendly name, identifier, version and build number. The command has been upgraded to also returns branch identifier, whether or not the game was launched using mods, the platform and the architecture.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue ProductVersion()
        {
            return new GameValue(productversion());
        }

        /// <summary>
        /// Returns currently chosen user profile name. For Steam profile name see profileNameSteam.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue ProfileName()
        {
            return new GameValue(profilename());
        }

        /// <summary>
        /// Returns the global namespace attached to the active user profile. Use setVariable and getVariable to save and load data to and from this Namespace. A variable can be deleted by setting its value to nil. By default the variables set in this namespace will exist while the game is running, and variables are saved persistently when the game is closed. Saving can also be forced by using saveProfileNamespace to prevent data loss on e.g game crash. The variables are stored next to the user profile in a file named myUsername.vars.GAMENAME.
        /// </summary>
        /// <returns>GameValue namespace</returns>
        public static GameValue ProfileNamespace()
        {
            return new GameValue(profilenamespace());
        }

        /// <summary>
        /// Returns name of the current Steam profile. For currently chosen user profile name see profileName
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue ProfileNameSteam()
        {
            return new GameValue(profilenamesteam());
        }

        /// <summary>
        /// If loading screen is shown, sets progress bar to the given value (interval is from 0 to 1])
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ProgressLoadingScreen(GameValue rightInstance)
        {
            return new GameValue(progressloadingscreen(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current position in the progress bar.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue ProgressPosition(GameValue rightInstance)
        {
            return new GameValue(progressposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets progress position of a progress bar.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ProgressSetPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(progresssetposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Reliably broadcasts missionNamespace variable and its current value to all computers (server/client). Variables broadcast with publicVariable during a mission will be available to JIP clients with the value they held at the time. Such variables are persistent and sent to the JIP client before the first batch of client-side Event Scripts (such as init.sqf) is run. ⚠Using publicVariable too frequently and/or with a lot of data can cause other aspects of the game to experience bandwidth problems. The following  Data Types are supported: Type Number Boolean Object Group String Text Array Code Nothing (nil) HashMap Since 1.34 1.34 1.34 1.34 1.00 1.00 1.09 1.09 1.26 2.02 ⚠It is not possible (and illogical) to transfer a local entity reference, such as scripts, displays or local objects. Also, note that Team Member is not supported.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PublicVariable(GameValue rightInstance)
        {
            return new GameValue(publicvariable(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Send the variable value to the client computer - same limitations regarding variable type as publicVariable. The Client ID is the temporary ID given to a connected client for that session. You can find out this ID with the owner command (using it on a player's character, for example, will give you that players client ID). In Arma 3 it is possible to broadcast nil value
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PublicVariableClient(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(publicvariableclient(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Send the variable value to the server - same limitations regarding variable type as publicVariable. In Arma 3 it is possible to broadcast nil value
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PublicVariableServer(GameValue rightInstance)
        {
            return new GameValue(publicvariableserver(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Insert an element to the back of the given array. This command modifies the original array. (see also: pushBackUnique)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue PushBack(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(pushback(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds element to the back of the given array but only if it is unique to the array. The index of the added element is returned upon success, otherwise -1. This command modifies the original array. Adding string elements is case sensitive.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue PushBackUnique(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(pushbackunique(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Transfers weapons and magazines from weapon pool into cargo of given object. Used in campaign to transfer weapons into next mission.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue PutWeaponPool(GameValue rightInstance)
        {
            return new GameValue(putweaponpool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the number of items of type in the weapon pool (used in campaigns to transfer weapons to the next mission).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue QueryItemsPool(GameValue rightInstance)
        {
            return new GameValue(queryitemspool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return number of magazines of type name in magazine pool (used in campaign to transfer magazines into next mission).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue QueryMagazinePool(GameValue rightInstance)
        {
            return new GameValue(querymagazinepool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return number of weapons of type name in weapon pool (used in campaign to transfer weapons into next mission).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue QueryWeaponPool(GameValue rightInstance)
        {
            return new GameValue(queryweaponpool(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts given value in degrees to radians. 1 radian equals 180 degrees divided by pi.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Rad(GameValue rightInstance)
        {
            return new GameValue(rad(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add the units to the custom channel.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RadioChannelAdd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(radiochanneladd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a custom radio channel with the given color, label, call sign and registered characters. The custom channel ID returned can be used to manipulate the created channel later. There are 10 slots for custom radio channels which would correspond to channels 6-15 (see getPlayerChannel). The command will find an unused index in this range and create it when found.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue RadioChannelCreate(GameValue rightInstance)
        {
            return new GameValue(radiochannelcreate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Obtains custom radio channel's details, set by radioChannelCreate.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RadioChannelInfo(GameValue rightInstance)
        {
            return new GameValue(radiochannelinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove the units from the custom radio channel.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RadioChannelRemove(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(radiochannelremove(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the custom radio channel's call sign.  Available special parameters: $KEY (reference to a localized text) %CHANNEL_LABEL %UNIT_SIDE %UNIT_NAME %UNIT_RANK %UNIT_ID %UNIT_REF %UNIT_GRP_NAME %UNIT_GRP_LEADER %UNIT_VEH_NAME %UNIT_VEH_POSITION
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RadioChannelSetCallSign(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(radiochannelsetcallsign(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the custom radio channel's label.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RadioChannelSetLabel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(radiochannelsetlabel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for enableRadio.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue RadioEnabled()
        {
            return new GameValue(radioenabled());
        }

        /// <summary>
        /// Returns the current radio volume (set by fadeRadio).
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue RadioVolume()
        {
            return new GameValue(radiovolume());
        }

        /// <summary>
        /// Returns the current value of rain density in range 0..1
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Rain()
        {
            return new GameValue(rain());
        }

        /// <summary>
        /// Returns the current rainbow intensity.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Rainbow()
        {
            return new GameValue(rainbow());
        }

        /// <summary>
        /// Returns currently set  RainParticles params, custom or default.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue RainParams()
        {
            return new GameValue(rainparams());
        }

        /// <summary>
        ///  Syntax 2's distribution Syntax 1 generates a random floating point value Syntax 2 generates a Gaussian Distribution[1]. It uses the same method as setTriggerTimeout command and is quite useful for e.g spawning loot, making more valuable items more rare Syntax 3 generates a seed-based random number Syntax 4 generates a seed-based random noise (not Perlin) texture based on provided seed and returning the value at supplied coordinates
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Random(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(random(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the rank of the given unit. Rank can be one of the following: "PRIVATE" "CORPORAL" "SERGEANT" "LIEUTENANT" "CAPTAIN" "MAJOR" "COLONEL"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Rank(GameValue rightInstance)
        {
            return new GameValue(rank(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the rank of the given unit for comparison. Value may be: 0 - Private 1 - Corporal 2 - Sergeant 3 - Lieutenant 4 - Captain 5 - Major 6 - Colonel
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue RankId(GameValue rightInstance)
        {
            return new GameValue(rankid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check unit rating. Rating is increased for killing enemies, decreased for killing friendlies (see Rating Values). Can be changed via addRating by the mission designer.  The rating of the player is displayed as the "score" at the end of the mission. Via Description.ext one can define how many points it takes to get a perfect score, as well as the number of stars.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Rating(GameValue rightInstance)
        {
            return new GameValue(rating(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if a location is rectangular (returns true) or elliptical (returns false).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Rectangular(GameValue rightInstance)
        {
            return new GameValue(rectangular(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Searches in a string with a regular expression. See Arma 3: Regular Expressions.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RegexFind(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(regexfind(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether the haystack matches the pattern.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue RegexMatch(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(regexmatch(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Searches given haystack with given pattern and replaces all matches with given replaceString.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue RegexReplace(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(regexreplace(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all registered task types for the given agent. The values are the names set in CfgTasks classes name property. The same names are used for unregisterTask
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RegisteredTasks(GameValue rightInstance)
        {
            return new GameValue(registeredtasks(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Registers a new task type. Parameters are defined in the given config class (subclass of CfgTasks)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue RegisterTask(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(registertask(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Old syntax: Reload first found muzzle that needs reloading (with some inconsistencies). Alternative syntax (Since Arma 3 v2.08.148609): This syntax allows to reload given muzzle with given magazine while playing proper animation. If param is omitted or is empty string, default value is used. The default behaviour is to find best matching magazine for given muzzle from the pool of available magazines. If specific magazine is requested, the reload will fail if unit has run out of this type of magazines. If empty array [] is given, the behaviour is similar to player pressing "Reload" key. The command reloads the given muzzle but doesn't select it. In case of  throwable muzzles, each throwable has own muzzle, they are autoreloaded after throw. Using reload on the trowable muzzle will just swap throwable for another one of the same type from inventory.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Reload(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(reload(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check whether magazine is reloaded whenever emptied.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue ReloadEnabled(GameValue rightInstance)
        {
            return new GameValue(reloadenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switches on remote control of the unit. Command needs to be executed locally to the player. If driver is remote it will get transferred to players PC. There is currently no getter command for remote control, but it is possible to use a trick described in Example 3.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoteControl(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(remotecontrol(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Asks the server to execute the given function or script command on the given target machine(s). Functions are executed in the scheduled environment; suspension is allowed. Script commands are executed in the unscheduled environment; suspension is not allowed (see Example 7). Read Arma 3: Remote Execution for more information about remote execution, security features and JIP techniques. remoteExec/remoteExecCall can be used in single player as well, as it is considered as player-hosted multiplayer. ⚠The direct execution of call or spawn via remoteExec (or remoteExecCall) should be avoided to prevent issues in cases where the remote execution of call or spawn is blocked by CfgRemoteExec. It is instead recommended to create a function to be itself remote-executed.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string_nothing</returns>
        public static GameValue RemoteExec(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(remoteexec(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unscheduled version of remoteExec. The only difference between remoteExec and remoteExecCall is that remoteExecCall will run functions in unscheduled environment. ⚠The "Call" in remoteExecCall only means that the remote execution will take place in unscheduled environment and does not mean it will happen right away (see Example 3).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string_nothing</returns>
        public static GameValue RemoteExecCall(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(remoteexeccall(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the  machine network ID of the client that initiated Remote Execution. ⚠Running this command in a Single Player environment outside of a remote-executed context in a remote-executed context received from a Headless Client will return 0 by design. To check if the context is remote executed, use isRemoteExecuted or isRemoteExecutedJIP.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue RemoteExecutedOwner()
        {
            return new GameValue(remoteexecutedowner());
        }

        /// <summary>
        /// Removes connection between entities.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Remove3DENConnection(GameValue rightInstance)
        {
            return new GameValue(remove3denconnection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes Eden Editor event handler of given type and ID. See the list of all Eden Editor Event Handlers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Remove3DENEventHandler(GameValue rightInstance)
        {
            return new GameValue(remove3deneventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove Eden Editor editing layer.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Remove3DENLayer(GameValue rightInstance)
        {
            return new GameValue(remove3denlayer(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes user added action with given ID. This only removes actions added with the addAction command. You cannot remove default game actions, such as reload.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAction(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeaction(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all Eden Editor event handlers of given type.  See the list of all Eden Editor Event Handlers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAll3DENEventHandlers(GameValue rightInstance)
        {
            return new GameValue(removeall3deneventhandlers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all unit's user added actions. This command's syntax was unit removeAllActions number from Arma 3 v0.50 to v1.06. ⚠Usage of this command is usually a bad practice unless justified by the situation; removing all actions in order to remove all actions that one added is not a good method as a mod or another script could have added its own actions as well and see them removed. Instead, store the action id returned by addAction either in a script variable or using setVariable.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllActions(GameValue rightInstance)
        {
            return new GameValue(removeallactions(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unassigns and deletes all linked items from inventory. The commands operates on assignedItems array, which does not include goggles or headgear but includes binoculars, which is a weapon. Use removeGoggles and removeHeadgear for those.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllAssignedItems(GameValue rightInstance)
        {
            return new GameValue(removeallassigneditems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from binocular weapon, except magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllBinocularItems(GameValue rightInstance)
        {
            return new GameValue(removeallbinocularitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all containers (vest, uniform, backpack) from the provided unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllContainers(GameValue rightInstance)
        {
            return new GameValue(removeallcontainers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Restrict access to all addons for given curator.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllCuratorAddons(GameValue rightInstance)
        {
            return new GameValue(removeallcuratoraddons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Delete all curator camera areas.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllCuratorCameraAreas(GameValue rightInstance)
        {
            return new GameValue(removeallcuratorcameraareas(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Delete all curator edit areas.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllCuratorEditingAreas(GameValue rightInstance)
        {
            return new GameValue(removeallcuratoreditingareas(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all event handlers of given type that were added by addEventHandler and resets event handler's creation index to 0.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllEventHandlers(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removealleventhandlers(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from handgunWeapon, except magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllHandgunItems(GameValue rightInstance)
        {
            return new GameValue(removeallhandgunitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all special items from the unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllItems(GameValue rightInstance)
        {
            return new GameValue(removeallitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all itemsWithMagazines from the uniform, vest and backpack. Command essentially clears all unit's containers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllItemsWithMagazines(GameValue rightInstance)
        {
            return new GameValue(removeallitemswithmagazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all mission event handlers of the given type which were added by addMissionEventHandler. ⚠Prior to 2.08 this command would also reset the Event Handler creation index to 0.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllMissionEventHandlers(GameValue rightInstance)
        {
            return new GameValue(removeallmissioneventhandlers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all MP event handlers of the given type which were added by addMPEventHandler. Command needs to be executed only on one PC for MP event handler to be removed globally.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllMPEventHandlers(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeallmpeventhandlers(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all music track event handlers of given type.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllMusicEventHandlers(GameValue rightInstance)
        {
            return new GameValue(removeallmusiceventhandlers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes ownership of all owned mines/explosive devices of the given unit
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllOwnedMines(GameValue rightInstance)
        {
            return new GameValue(removeallownedmines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from primaryWeapon, except magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllPrimaryWeaponItems(GameValue rightInstance)
        {
            return new GameValue(removeallprimaryweaponitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from secondaryWeapon, except magazine.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllSecondaryWeaponItems(GameValue rightInstance)
        {
            return new GameValue(removeallsecondaryweaponitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all UserAction event handlers of the given type which were added by addUserActionEventHandler. ⚠This command also resets the Event Handler creation index to 0.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllUserActionEventHandlers(GameValue rightInstance)
        {
            return new GameValue(removealluseractioneventhandlers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all weapons and magazines from the given unit. Does not remove items like map, compass, radio (see removeWeapon for this). Doesn't quite work with vehicles. If you need to remove all weapons from a vehicle, remove each weapon individually (see removeWeapon).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveAllWeapons(GameValue rightInstance)
        {
            return new GameValue(removeallweapons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes unit's backpack
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveBackpack(GameValue rightInstance)
        {
            return new GameValue(removebackpack(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes backpack from a unit. (even non-local)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveBackpackGlobal(GameValue rightInstance)
        {
            return new GameValue(removebackpackglobal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes given weapon item, including magazine, from the binocular weapon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveBinocularItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removebinocularitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Restrict curator use of given addons.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveCuratorAddons(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removecuratoraddons(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes curator camera area.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveCuratorCameraArea(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removecuratorcameraarea(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unregister objects which can be edited by a curator.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveCuratorEditableObjects(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removecuratoreditableobjects(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes editing area for given curator.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveCuratorEditingArea(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removecuratoreditingarea(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove a log record.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveDiaryRecord(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removediaryrecord(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes a page and all its subjects from the Diary.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveDiarySubject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removediarysubject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes an icon for an editor object.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveDrawIcon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removedrawicon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove all drawn links for the given editor object for the given editor,object type. Pass an empty string as param type to remove all draw,links for an object.   Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveDrawLinks(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removedrawlinks(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes a given Event Handler that was added with addEventHandler.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes vehicles/units from the garbage collector, so they do not get deleted automatically; added earlier with addToRemainsCollector.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveFromRemainsCollector(GameValue rightInstance)
        {
            return new GameValue(removefromremainscollector(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes goggles from unit (diver goggles for example). This command does not remove NVGoggles. Use unassignItem and removeItem or just unlinkItem for latter.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveGoggles(GameValue rightInstance)
        {
            return new GameValue(removegoggles(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove icon with given ID from group.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveGroupIcon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removegroupicon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes given weapon item, including magazine, from the handgunWeapon
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveHandgunItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removehandgunitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes headgear from a unit. If unit has no headgear command quietly fails.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveHeadgear(GameValue rightInstance)
        {
            return new GameValue(removeheadgear(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes item from the inventory.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes item from soldier's backpack.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveItemFromBackpack(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeitemfrombackpack(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes item from soldier's uniform. Can be used with magazines and weapons too.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveItemFromUniform(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeitemfromuniform(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes item from soldier's vest.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveItemFromVest(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeitemfromvest(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items with given class name from the inventory.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveItems(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeitems(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove magazine from the unit.⚠You may create invalid combinations with this function. When doing so, application behaviour is undefined.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMagazine(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removemagazine(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes the magazine from the unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMagazineGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removemagazineglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all magazines of given type from the unit. If magazine class does not exist, nothing happens, not even .rpt message, unlike with addMagazine command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMagazines(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removemagazines(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all magazines of the given type from given vehicle. Use turret path [-1] for driver's turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMagazinesTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removemagazinesturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes the magazine from the turret. Use turret path [-1] for driver's turret. Note: you may create invalid combinations by using this function. When doing so, application behaviour is undefined.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMagazineTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removemagazineturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes a previously added menu item.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMenuItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removemenuitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes mission event handler added by addMissionEventHandler.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMissionEventHandler(GameValue rightInstance)
        {
            return new GameValue(removemissioneventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes MP event handler added by addMPEventHandler.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMPEventHandler(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removempeventhandler(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes specified music track event handler. See Arma 3: Event Handlers - Music Event Handlers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveMusicEventHandler(GameValue rightInstance)
        {
            return new GameValue(removemusiceventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes ownership over a remotely detonatable mine from the unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveOwnedMine(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeownedmine(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes given weapon item, including magazine, from the primaryWeapon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemovePrimaryWeaponItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeprimaryweaponitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes given weapon item, including magazine, from the secondaryWeapon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveSecondaryWeaponItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removesecondaryweaponitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove a simple task from the list of simple tasks. If the Task to be removed is a child to some parent task and at the same time the parent to some child task, the child of this task gets orphaned and is listed in the root of Tasks tree (Tasks menu), retaining tree structure of its children.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveSimpleTask(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removesimpletask(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove a unit from the list of units available for Team Switch.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveSwitchableUnit(GameValue rightInstance)
        {
            return new GameValue(removeswitchableunit(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove given member from given team. Effect is local, unless both member and team are local to PC on which command is executed, then effect is global.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveTeamMember(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeteammember(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes uniform from unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveUniform(GameValue rightInstance)
        {
            return new GameValue(removeuniform(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes a UserAction event handler. For a list of available UserAction event handlers, see: Arma 3: Mission Event Handlers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveUserActionEventHandler(GameValue rightInstance)
        {
            return new GameValue(removeuseractioneventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes vest from unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveVest(GameValue rightInstance)
        {
            return new GameValue(removevest(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove weapon from a unit. The unit must be local to the computer where command is executed. For a global version of this command see removeWeaponGlobal. Note: It is possible to create invalid combinations with this command (ie, attempting to remove a weapon that a unit does not possess). When doing so, application behaviour is undefined.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveWeapon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeweapon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove attachment linked to a weapon from the vehicle cargo space.  ⚠This is unofficial documentation. All Information here is as it exists in the Engine. It might not reflect the reality.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveWeaponAttachmentCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeweaponattachmentcargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove weapon from the vehicle cargo space. ⚠This is unofficial documentation. All Information here is as it exists in the Engine. It might not reflect the reality.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveWeaponCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeweaponcargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Remove a weapon from a unit. An attempt to remove a weapon, which is not in unit's possession, is simply ignored.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveWeaponGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeweaponglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes weapon from the turret. Use turret path [-1] for driver's turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RemoveWeaponTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(removeweaponturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shares the target vehicle via datalink to the Side center for a given time.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ReportRemoteTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(reportremotetarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if version of application is available. If the current version is older than the required one, a warning message is shown and false is returned.  Version of format Major.Minor, e.g. 1.30
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue RequiredVersion(GameValue rightInstance)
        {
            return new GameValue(requiredversion(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Stops any ongoing camera shake effects. Does not prevent new effects from being created. To disallow new effects altogether, enableCamShake should be used.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue ResetCamShake()
        {
            return new GameValue(resetcamshake());
        }

        /// <summary>
        /// Sets  formation direction of a group relative to current direction of the group leader. The group units will change their positions to form new formation if new formation direction is different (approx +/- 15 degrees). Does the same as: _grp setFormDir getDir leader _grp;
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ResetSubgroupDirection(GameValue rightInstance)
        {
            return new GameValue(resetsubgroupdirection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Pre-defined variable for the resistance side.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue Resistance()
        {
            return new GameValue(resistance());
        }

        /// <summary>
        /// Changes the size of the given array. The command does not return new array, it resizes the source array to the desired number of elements. If the new size is bigger than the current size, the new places are filled with nil. The alternative syntax allows to fill resized positions with a given value. Array and HashMap values are copied.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Resize(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(resize(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the resources of a team member. Results are local to the PC on which command was executed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Resources(GameValue rightInstance)
        {
            return new GameValue(resources(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets vehicle as respawnable in MP game. The vehicle will be spawned at the locality and coordinates it was prior to destruction. If respawn type is set to base respawn (type 3) and vehicle respawn marker is provided (respawn_vehicle_XXXSIDEXXX), vehicle will spawn on the marker.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RespawnVehicle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(respawnvehicle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Restarts the mission editor camera (if it was deleted by a script,for example). Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RestartEditorCamera(GameValue rightInstance)
        {
            return new GameValue(restarteditorcamera(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Reveals a target to a group. If toWhom is a unit, unit's group is considered. If toWhom is a vehicle, vehicle commander's group is considered.  The knowledge value will be set to the highest level any unit of the revealing side has about the revealed target. If the revealing side has no knowledge about the revealed target, the value will be set to 1. The knowledge level can only be increased by this command, not decreased. Use forgetTarget first if you need to decrease value.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Reveal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(reveal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets given mine as known to the side. (Knowledge about a mine is always shared across all units in a side.)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RevealMine(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(revealmine(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Reverses given array by reference (modifies the original array, just like resize). The alternative syntax can be used to reverse a ANSI string. If Unicode support is desired, see forceUnicode.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Reverse(GameValue rightInstance)
        {
            return new GameValue(reverse(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if mouse vertical axe is inverted.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ReversedMouseY()
        {
            return new GameValue(reversedmousey());
        }

        /// <summary>
        /// Returns a road segment containing given position, objNull otherwise. Same as isOnRoad only returns the actual road object instead of boolean.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue RoadAt(GameValue rightInstance)
        {
            return new GameValue(roadat(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Find the road segments connected to the given road segment. ⚠Pedestrian roads such as "TRAIL"s are missing connection information by design, therefore basic command will return empty array for those. Use the alternative syntax to return pedestrian roads.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RoadsConnectedTo(GameValue rightInstance)
        {
            return new GameValue(roadsconnectedto(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns unit description set in the editor and visible on role selection screen in multiplayer.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue RoleDescription(GameValue rightInstance)
        {
            return new GameValue(roledescription(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of all entities that are attached to the transport with ropes. This command is the opposite of ropeAttachedTo.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RopeAttachedObjects(GameValue rightInstance)
        {
            return new GameValue(ropeattachedobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the owner of the first rope - the transport to which other entities are attached with ropes. This command is the opposite of ropeAttachedObjects. To return all owners see ropesAttachedTo.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue RopeAttachedTo(GameValue rightInstance)
        {
            return new GameValue(ropeattachedto(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if entity can be attached to a rope end.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue RopeAttachEnabled(GameValue rightInstance)
        {
            return new GameValue(ropeattachenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attaches entity to the rope end with optional offset. For detach operation use ropeDetach.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RopeAttachTo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ropeattachto(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a rope.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue RopeCreate(GameValue rightInstance)
        {
            return new GameValue(ropecreate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Cuts the given rope to the specified length. If some entity was attached to the end of the rope, it will be detached. The rope remains attached to its parent transport and if the length is set to 0 or even negative does not get destroyed. Use ropeDestroy to remove it completely.The rope could only be shortened. If the cut length is greater than current rope length, nothing happens
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RopeCut(GameValue rightInstance)
        {
            return new GameValue(ropecut(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Destroys the given rope. If the rope is attached to a vehicle, it will be detached and then destroyed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RopeDestroy(GameValue rightInstance)
        {
            return new GameValue(ropedestroy(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Detaches attached object from rope (i.e. detaches rope end from attached to it entity). See ropeAttachTo for attach operation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RopeDetach(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(ropedetach(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns start and end positions for the given  rope. If command fails, empty array [] is returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RopeEndPosition(GameValue rightInstance)
        {
            return new GameValue(ropeendposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return rope length in meters (set by ropeCreate, ropeCut, ropeUnwind). Returned rope length will remain the same, even if the rope is stretched.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue RopeLength(GameValue rightInstance)
        {
            return new GameValue(ropelength(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all ropes attached to a ropes owner transport vehicle.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Ropes(GameValue rightInstance)
        {
            return new GameValue(ropes(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the owners of all ropes attached to the cargo - the transports to which other entities are attached with ropes. This command returns Array of Objects instead of a single Object as with ropeAttachedTo.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RopesAttachedTo(GameValue rightInstance)
        {
            return new GameValue(ropesattachedto(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns provided rope's segments. To return the rope parent from a rope segment, use objectParent (Since Arma 3 2.12)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RopeSegments(GameValue rightInstance)
        {
            return new GameValue(ropesegments(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Increases or decreases the rope length by the given amount. Use relative parameter for changing rope length +/- from current length. Rope length can be in range 0.5..100 metres.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue RopeUnwind(GameValue rightInstance)
        {
            return new GameValue(ropeunwind(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns false if rope length changing animation is in progress. Returns true if animation is done.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue RopeUnwound(GameValue rightInstance)
        {
            return new GameValue(ropeunwound(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns force produced by rotors. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RotorsForcesRTD(GameValue rightInstance)
        {
            return new GameValue(rotorsforcesrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns rotors RPM. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue RotorsRpmRTD(GameValue rightInstance)
        {
            return new GameValue(rotorsrpmrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Rounds the provided value to the closest integer.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Round(GameValue rightInstance)
        {
            return new GameValue(round(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Fades in mission screen and re-executes init.sqf and init.sqs scripts. In Eden Editor the code inside the "Init" mission attribute is executed.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue RunInitScript()
        {
            return new GameValue(runinitscript());
        }

        /// <summary>
        /// Returns the height of the screen in screen measurement units. Taken from top left corner of the default viewport (0,0) of the screen and going in the same direction as the Y axis, the value will be positive but resulting Y will end up beyond the bottom border. Therefore in order to calculate Y of the bottom screen border, the length of safeZoneY must be subtracted from safeZoneH, but because it is negative, it must be added instead. _screenBottomBorderY = safeZoneH + safeZoneY. The measurement units depend on the current screen resolution getResolution. See also SafeZone
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SafeZoneH()
        {
            return new GameValue(safezoneh());
        }

        /// <summary>
        /// Returns the width of the screen in screen measurement units. Taken from top left corner of the default viewport (0,0) of the screen and going in the same direction as the X axis, the value will be positive but resulting X will end up beyond the right border. Therefore in order to calculate X of the right screen border, the length of safeZoneX must be subtracted from safeZoneW, but because it is negative, it must be added instead. _screenRightBorderX = safeZoneW + safeZoneX. The measurement units depend on the current screen resolution getResolution. See also SafeZone
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SafeZoneW()
        {
            return new GameValue(safezonew());
        }

        /// <summary>
        /// Returns absolute safeZoneW including all monitors.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SafeZoneWAbs()
        {
            return new GameValue(safezonewabs());
        }

        /// <summary>
        ///  Returns the X of the left border of the screen, which is also a distance in screen measurement units from top left corner of the default viewport (0,0) of the screen to the left border of the screen. Since it is going in opposite way of the X axis, the value is negative. The measurement units depend on the current screen resolution getResolution. See also SafeZone.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SafeZoneX()
        {
            return new GameValue(safezonex());
        }

        /// <summary>
        /// Returns absolute safeZoneX including all monitors. 
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SafeZoneXAbs()
        {
            return new GameValue(safezonexabs());
        }

        /// <summary>
        ///  Returns the Y of the top border of the screen, which is also a distance in screen measurement units from top left corner of the default viewport (0,0) of the screen to the top border of the screen. Since it is going in opposite way of the Y axis, the value is negative. The measurement units depend on the current screen resolution getResolution. See also SafeZone.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SafeZoneY()
        {
            return new GameValue(safezoney());
        }

        /// <summary>
        /// Saves the current state of entities' inventory to the Mission.sqm.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Save3DENInventory(GameValue rightInstance)
        {
            return new GameValue(save3deninventory(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Autosaves the game (used for Retry). The saving is not started immediately, the request for autosave is made instead. To check the status of the request, use isSaving. The game can then be loaded from the last autosave with loadGame. Will not save if the player is  null or dead. Since 1.88 a  "OnSaveGame"  scripted event handler is available.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue SaveGame()
        {
            return new GameValue(savegame());
        }

        /// <summary>
        /// Saves units's identity to Objects.sav file in campaign directory as entry name.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SaveIdentity(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(saveidentity(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Saves joysticks key mappings into the joysticks.cfg file. Engine add these joysticks to the Joystick Scheme mapping dialog in options controls section.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue SaveJoysticks()
        {
            return new GameValue(savejoysticks());
        }

        /// <summary>
        /// missionProfileNamespace provides long term storage solution for mission variables. When this namespace has variables set with setVariable and is saved, the variables are saved into missionName.vars file into current soldier profileName folder. Next time when the same mission is loaded by the client with the same soldier profile, the saved variables can be read normally with getVariable command. This way each mission maker can create persistent data that is both mission and soldier profile specific. This is default behaviour. The file is only created when save operation is invoked with this command. It is also possible to share the same mission profile variables between several missions. To override default behaviour one needs to create an entry missionGroup in  Description.ext, for example missionGroup = "MyMissionCollectionName";. This will create MyMissionCollectionName.vars file instead of default one, which would be loaded into every mission with matching missionGroup entry.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue SaveMissionProfileNamespace()
        {
            return new GameValue(savemissionprofilenamespace());
        }

        /// <summary>
        /// Save the current overlay. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SaveOverlay(GameValue rightInstance)
        {
            return new GameValue(saveoverlay(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Saves all variables stored in profileNamespace to the active Profile. ⚠ This command triggers a file operation. As file operations are slow (even on SSDs), it is not recommended to use this command too frequently (i.e. several times per second). Do not save large amounts of data to the profile; the larger the profile file gets, the slower it loads! The profileNamespace is also saved when the game is closed. Heliport status, used in the Career mode for example, is stored in the file that is modified by this command, so be mindful of this to avoid losing data and progress.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue SaveProfileNamespace()
        {
            return new GameValue(saveprofilenamespace());
        }

        /// <summary>
        /// Saves object's properties to Objects.sav file in campaign directory as entry name.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SaveStatus(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(savestatus(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Save variable value into the campaign space. This variable is available to all following missions in the campaign.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SaveVar(GameValue rightInstance)
        {
            return new GameValue(savevar(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if saving the game is enabled. If saving is disabled by Eden Editor mission attribute, this command will still return true.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue SavingEnabled()
        {
            return new GameValue(savingenabled());
        }

        /// <summary>
        /// Make unit say given sound. The sound is defined in CfgSounds. If the unit is a person, it will also perform the corresponding lipsync effect provided an appropriate .lip file has been created for this sound. A dead or non-existent unit obviously cannot say anything. If the camera is not within given range, title is not shown and the sound will not be heard. See also playSound in order to play a sound wherever the camera/player is. say will mimic either say2D or say3D depending on whether it is executed in a cutscene or in a game scene.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Say(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(say(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Plays given sound in 2D.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Say2D(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(say2d(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Lets an object say given sound in 3D space. This allows broadcasting of positional music or sound from a source, without having to script a fade sound or music command. Compare this with say2D which will always play a sound at the location of the player after he has been in the vicinity of a broadcasting sound. Sound is defined in "CfgSounds" of the Description.ext or main config. an object can only "say" one sound at a time in order to stop a say3D sound: delete the returned sound source with deleteVehicle, or kill the sound source with e.g setDamage. Prior to 2.00, the sound source object was not returned by the command, so the from object had to be deleted instead (see Examples 2 and 3).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue Say3D(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(say3d(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines name of current scope. Name is visible in debugger, and name is also used as reference in some commands like breakOut and breakTo. Scope name should be defined only once per scope. Trying to set a different name on the scope that has already defined scope name will result in error.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ScopeName(GameValue rightInstance)
        {
            return new GameValue(scopename(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the person's score in MP.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Score(GameValue rightInstance)
        {
            return new GameValue(score(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns score for the given side. MP Only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue ScoreSide(GameValue rightInstance)
        {
            return new GameValue(scoreside(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Captures a screenshot and stores it to given filename. PNG is the only available format and the file must have .png extension. The file is saved into Screenshots folder in the Profile directory. The folder is by default limited to 250 MB to prevent abuse. To increase the limit, add the following line at the end of the profile file: maxScreenShotFolderSizeMB = 2000; // 2 GB
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Screenshot(GameValue rightInstance)
        {
            return new GameValue(screenshot(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the position on landscape (PositionAGL) corresponding to the given point on screen (in UI coordinates).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ScreenToWorld(GameValue rightInstance)
        {
            return new GameValue(screentoworld(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if a script is finished running using the Script Handle returned by execVM or spawn.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue ScriptDone(GameValue rightInstance)
        {
            return new GameValue(scriptdone(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assign a user friendly name to the VM script this command is executed from. ⚠Once a name is assigned, it cannot be changed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ScriptName(GameValue rightInstance)
        {
            return new GameValue(scriptname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A non-existing or completed Script Handle. To compare non-existent scripts use isNull or isEqualTo: scriptNull == scriptNull;			// ERROR! == cannot be used with script object isNull scriptNull;					// true scriptNull isEqualTo scriptNull;	// true
        /// </summary>
        /// <returns>GameValue script</returns>
        public static GameValue ScriptNull()
        {
            return new GameValue(scriptnull());
        }

        /// <summary>
        /// Return the current state of given Scud launcher.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue ScudState(GameValue rightInstance)
        {
            return new GameValue(scudstate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of a unit's secondary weapon (launcher). To detect the weapon which is currently being used by the unit use currentWeapon.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue SecondaryWeapon(GameValue rightInstance)
        {
            return new GameValue(secondaryweapon(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all items assigned to the secondaryWeapon except magazines. Use secondaryWeaponMagazine command for the latter. This command is used for infantry weapons only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SecondaryWeaponItems(GameValue rightInstance)
        {
            return new GameValue(secondaryweaponitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Collects all loaded magazines from all secondaryWeapon muzzles and returns them in Array, otherwise it returns []. This command is used for infantry weapons only.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SecondaryWeaponMagazine(GameValue rightInstance)
        {
            return new GameValue(secondaryweaponmagazine(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects an element from an array, config entry from Config or substring from a string or a range from an array.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Select(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(select(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Find the places with the maximum value of expression in the given area. Places can be on water. Results are sorted by value. Search pattern is randomised every command execution.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SelectBestPlaces(GameValue rightInstance)
        {
            return new GameValue(selectbestplaces(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects a subject page in the diary. The subject page is selected but the command does not open the map by default, which could be opened with openMap if necessary.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SelectDiarySubject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selectdiarysubject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a list of currently selected editor objects.  Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SelectedEditorObjects(GameValue rightInstance)
        {
            return new GameValue(selectededitorobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Select an editor object. Does not un-select previously selected objects.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue SelectEditorObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selecteditorobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the list of model selections. When using default syntax, the named selections are returned from the first LOD only (LOD index 0). Alternative syntax allows to select LOD by name or by LOD resolution. ⚠Sometimes internally "ViewGeometry" can be equal to "Geometry", and "FireGeometry" could be equal to "ViewGeometry". In order to pinpoint the actual LOD, use allLODs and LOD resolution as argument for selecting the LOD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SelectionNames(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selectionnames(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns selection position in model space pertaining to the current animation in render time scope. When the default syntax is used, command searches first in Memory LOD, then in Geometry LOD, FireGeometry LOD, LandContact LOD, HitPoints LOD and finally in ViewGeometry LOD and returns the first matching find. The second syntax allows to specify which one of these LODs to search in instead. ⚠Sometimes internally "ViewGeometry" could be equal to "Geometry", and "FireGeometry" could be equal to "ViewGeometry". In order to pinpoint the actual LOD, use allLODs and LOD resolution as argument for selecting the LOD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SelectionPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selectionposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Searches for selection in the object model's LOD level, and returns the Direction and Up vectors in model space.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SelectionVectorDirAndUp(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selectionvectordirandup(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Select the group's leader. Group locality can be checked with local command and group ownership with groupOwner command. ⚠An invalid combination can be provided to this command, e.g unitName not being part of group. In that case: unitName will be leader of group, but will not be able to command them if unitName is deleted or killed, leader of group will be objNull and will not automatically be reassigned.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SelectLeader(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selectleader(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the array element with maximum numerical value. Engine solution to BIS_fnc_greatestNum and BIS_fnc_findExtreme. Therefore it is expected that supplied array consists of Numbers only. Booleans however are also supported and will be evaluated as Numbers: true - 1, false - 0.  nil value treated as 0.  ⚠Other non Number elements (not recommended) will be evaluated as 0 and Bad conversion: scalar message will be logged into .rpt.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue SelectMax(GameValue rightInstance)
        {
            return new GameValue(selectmax(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the array element with minimum numerical value. Engine solution to BIS_fnc_lowestNum and BIS_fnc_findExtreme. Therefore it is expected that supplied array consists of Numbers only.  Booleans however are also supported and will be evaluated as Numbers: true - 1, false - 0. nil value treated as 0.  ⚠Other non Number elements (not recommended) will be evaluated as 0 and Bad conversion: scalar message will be logged into .rpt.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue SelectMin(GameValue rightInstance)
        {
            return new GameValue(selectmin(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switches player to no unit, makes player return objNull.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue SelectNoPlayer()
        {
            return new GameValue(selectnoplayer());
        }

        /// <summary>
        /// Move player into given unit. Some usage advices: Avoid using selectPlayer on editor-placed units in multiplayer, as it may, on occasion, lead to some undefined behaviour. If you need to selectPlayer into another unit, consider creating a unit dynamically.Before Arma 3 it was possible to selectPlayer another player-controlled unit, leading to control issues. ⚠Creating and immediately selecting player into newly created unit could cause all sort of problems due to possible delay in unit initialisation. Give the unit some time to propagate properly on the network before using this command on it.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SelectPlayer(GameValue rightInstance)
        {
            return new GameValue(selectplayer(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a random element from the given array. Engine solution to BIS_fnc_selectRandom
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue SelectRandom(GameValue rightInstance)
        {
            return new GameValue(selectrandom(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a random element from the given array according to assigned weights. Engine solution to BIS_fnc_selectRandomWeighted. A few notes: Negative weights are not supported If an item's weight is 0, the item is ignored The weights don't have to total to 1 If numbers of items and weights do not match, the shortest array is used A single array Syntax is slightly faster than Alt Syntax
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue SelectRandomWeighted(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selectrandomweighted(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects the given weapon.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool_nothing</returns>
        public static GameValue SelectWeapon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selectweapon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects the given weapon on the specified turret. Use turret path [-1] for the driver's turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SelectWeaponTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(selectweaponturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Send the command to the list of clients.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SendAUMessage(GameValue rightInstance)
        {
            return new GameValue(sendaumessage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sends a simple command to the vehicle's driver / gunner (air vehicles ignore it). See also vehicleMoveInfo.⚠Doesn't seem to work if AI driver is alone, needs another unit in the vehicle (could be another AI or player) that is set as setEffectiveCommander. If driver is effectiveCommander it will refuse any drive commands. Due to some sort of a bug when vehicle is ordered turning ("LEFT" or "RIGHT"), it locks the vehicle ability to respond to any other commands properly. Always use "STOPTURNING" to cancel turning before issuing other move commands Gunner commands Driver Move commands Driver Turn commands "FIRE" "CEASE FIRE" "MANUAL FIRE" "CANCEL MANUAL FIRE" "KEY FIRE" "FORWARD" - move forward "FAST" - move forward, fast "SLOW" - move forward, slow "STOP" - stop moving forward or backward "BACK" - move backward "KEY UP" "KEY DOWN" "KEY FAST" "KEY SLOW" "LEFT" - turn left, while moving or not "RIGHT" - turn right, while moving or not 1.78 "STOPTURNING" cancel turning (special case, normally would be called by the engine when LEFT or RIGHT turn key is released by the player)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SendSimpleCommand(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sendsimplecommand(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a new AI task (subtask of parentTask). Type is name of registered task type.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue task</returns>
        public static GameValue SendTask(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sendtask(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Send a result of the task to the task sender.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SendTaskResult(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sendtaskresult(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Send message to given address using UDP protocol. Returns false if the message has not been delivered  ⚠Not implemented (see the talk page for more info).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SendUDPMessage(GameValue rightInstance)
        {
            return new GameValue(sendudpmessage(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for enableSentences.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue SentencesEnabled()
        {
            return new GameValue(sentencesenabled());
        }

        /// <summary>
        /// Executes the given server command. Available commands for execution can be found with serverCommandAvailable Commands that can be executed can be found with serverCommandExecutable ⚠If serverCommand is executed on a client, it must be executed from UI context, such as "onButtonDown" or similar events (see User Interface Event Handlers).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue ServerCommand(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(servercommand(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if given serverCommand is available on current machine, false if not. Arma 3 Multiplayer Server Commands Available to Client Voted Admin Logged Admin Server Host #login, #userlist,  #beclient,  #vote #kick, #debug #lock, #unlock, #maxping, #maxdesync, #maxpacketloss #logout, #restart, #mission, #missions, #reassign, #monitor, #init #shutdown, #restartserver, #exec, #beserver, #monitords, #logentities, #exportjipqueue Specific builds only: #captureframe, #enabletest, #disabletest To check if a server command can be executed in the current environment, use serverCommandExecutable. The table above does not apply to the command's password variant on a dedicated server as everything is available to it.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue ServerCommandAvailable(GameValue rightInstance)
        {
            return new GameValue(servercommandavailable(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the serverCommand can be performed on the machine and in this exact environment, otherwise false. serverCommand can be executed only from User Interface Event Handlers, and this command also checks if that's the case.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue ServerCommandExecutable(GameValue rightInstance)
        {
            return new GameValue(servercommandexecutable(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns name of the hosting server in MP, "" in SP.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue ServerName()
        {
            return new GameValue(servername());
        }

        /// <summary>
        /// Returns server's namespace. This namespace is only available on the server for the server's uptime duration (same as uiNamespace). Server event handlers, which are available in server config, all use this namespace.
        /// </summary>
        /// <returns>GameValue namespace</returns>
        public static GameValue ServerNamespace()
        {
            return new GameValue(servernamespace());
        }

        /// <summary>
        /// Returns the time since last server restart, synced to all clients in MP. The syncing is happening every 5 minutes, but you can force the next sync earlier by executing estimatedTimeLeft command. The time returned is also different to the time returned by time and diag_tickTime commands on server. Returns 0 in SP. Known issues before Arma 3 v1.86:  Both server and clients showed the same value when synced. The only time it was not synced was on the server, right after server restart and only for the first 300 seconds. Client side was synced from the start
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue ServerTime()
        {
            return new GameValue(servertime());
        }

        /// <summary>
        /// Changes the element at the given zero-based index of the array.  If the index is out of bounds, the array will resize to incorporate the index as its last value, padding with nil as necessary (see Example 4).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Set(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(set(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets one of entity attributes. For the list of all attributes with their properties see Setting Attributes. ⚠Attributes are available only within the Eden Editor workspace. You cannot access them in scenario preview or exported scenario!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Set3DENAttribute(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(set3denattribute(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set entity attributes. An attribute is identified by its property (data when it is engine-drive attribute) value in config. For the list of all attributes with their properties, see Setting Attributes. ⚠Attributes are available only within the Eden Editor workspace and cannot be accessed in scenario preview or exported scenario!
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Set3DENAttributes(GameValue rightInstance)
        {
            return new GameValue(set3denattributes(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the grid increment for the given transformation type.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Set3DENGrid(GameValue rightInstance)
        {
            return new GameValue(set3dengrid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggle visibility of Eden Editor icons.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Set3DENIconsVisible(GameValue rightInstance)
        {
            return new GameValue(set3deniconsvisible(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set layer for Eden Entity.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Set3DENLayer(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(set3denlayer(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggle visibility of Eden Editor lines.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Set3DENLinesVisible(GameValue rightInstance)
        {
            return new GameValue(set3denlinesvisible(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the new type of Logic object(s). For other objects use set3DENObjectType.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Set3DENLogicType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(set3denlogictype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set scenario attribute. An attribute is identified by its property (data when it is engine-drive attribute) value in config. For the list of all attributes with their properties, see Setting Attributes. ⚠Attributes are available only within the Eden Editor workspace. They cannot be accessed in scenario preview or exported scenario!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Set3DENMissionAttribute(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(set3denmissionattribute(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set scenario attributes. An attribute is identified by its property (data when it is an engine-driven attribute) value in config. For the list of all attributes with their properties, see Mission Attributes. ⚠Attributes are available only within the Eden Editor workspace. You cannot access them in scenario preview or exported scenario!
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Set3DENMissionAttributes(GameValue rightInstance)
        {
            return new GameValue(set3denmissionattributes(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables trigger area visibility.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Set3DENModelsVisible(GameValue rightInstance)
        {
            return new GameValue(set3denmodelsvisible(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the classname of one or more given Eden Editor objects. For Logic objects use set3DENLogicType.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Set3DENObjectType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(set3denobjecttype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set simulation acceleration coefficient. May also be used to slow time in cutscenes.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetAccTime(GameValue rightInstance)
        {
            return new GameValue(setacctime(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the collective pitch control to a specific position, regardless of input devices (until those are changed). 0: collective fully down ~0.7: approximate stable hover position 1: collective fully up For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetActualCollectiveRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setactualcollectivertd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a wanted throttle position - works only on player's vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetAirplaneThrottle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setairplanethrottle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set owning side of the airport. ID is the number to identify which airport on the island you want to check.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetAirportSide(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setairportside(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets custom ammo count in the currently loaded magazine of the specified weapon or muzzle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetAmmo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setammo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set amount of ammo resources in cargo space of a rearm vehicle. Ammo resource is used to resupply vehicles that take ammo. Soldiers use individual magazines instead. Amount: 1 is full cargo. The actual quantity to work with is determined by the model's class in CfgVehicles
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetAmmoCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setammocargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set count of ammo in magazine on pylon (supports pylon name since Arma 3 v1.94)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetAmmoOnPylon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setammoonpylon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a coefficient for animation speed (0.5 will play animations half the speed, 2 twice the speed). Doesn't affect upper body animations (reloading, etc.)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetAnimSpeedCoef(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setanimspeedcoef(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets custom eye accommodation camera aperture. If HDR is enabled, when setAperture value is used it also forces setApertureNew to the following values: [value, value, value, 1]. Execute setApertureNew after setAperture to override this default mechanic. ⚠The aperture is set to default by the engine at the mission start. If you set it before the mission started it will reset like it never happened. Make sure you set it at the right time (see Example 2).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetAperture(GameValue rightInstance)
        {
            return new GameValue(setaperture(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets custom camera aperture when HDR is enabled ([-1] to do it automatically). Provided values should be set such as minimum <= standard <= maximum. This command has to be executed after mission start: be sure to use e.g sleep 0.1; for it to take effect. If HDR is enabled (it is enabled by default), when setAperture value is used it also forces setApertureNew to the following values: [value, value, value, 1]. Execute setApertureNew after setAperture to override this default mechanic.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetApertureNew(GameValue rightInstance)
        {
            return new GameValue(setaperturenew(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Stores passed number into [USERNAME].ArmaXProfile file, where it assigns it as a value to armoryPoints entry. If entry doesn't exist, it is created.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetArmoryPoints(GameValue rightInstance)
        {
            return new GameValue(setarmorypoints(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a Structured Text created from the given structured text and sets  attributes to the given values. ⚠Even though command accepts plain String too, the argument should be Structured Text in order for the set attributes to have an effect. Additionally the result of the command should be fed to composeText (See Example 1) or formatText.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue text</returns>
        public static GameValue SetAttributes(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setattributes(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets UAV autonomous mode.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetAutonomous(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setautonomous(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets individual unit behaviour on every unit in a group. ⚠This command doesn't set AI Group behaviour, see setCombatBehaviour or setBehaviourStrong for this. See AI Behaviour for details of the effect of this command on AI units. Comparison of Behaviour commands Command Applies To setBehaviour Every unit in the group, but not the group itself setBehaviourStrong Every unit in the group, and the group itself setCombatBehaviour If argument is Object, only that unit, and if argument is Group, the group itself (not its units)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetBehaviour(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setbehaviour(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets individual unit behaviour on every unit in a group and additionally tries to force this behaviour to the unit's group. Alternatively see setCombatBehaviour. See AI Behaviour for details of the effect of this command on AI units. Comparison of Behaviour commands Command Applies To setBehaviour Every unit in the group, but not the group itself setBehaviourStrong Every unit in the group, and the group itself setCombatBehaviour If argument is Object, only that unit, and if argument is Group, the group itself (not its units)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetBehaviourStrong(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setbehaviourstrong(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets for how many seconds injured unit leaves blood trail. The unit damage must be >= 0.1 for this command to have an effect, otherwise, the getBleedingRemaining will return 0 and no blood trail is left behind.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetBleedingRemaining(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setbleedingremaining(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable landing gear wheel brakes for a helicopter. value 0: brakes off value 1: brakes on index 1: left wheels index 2: right wheels index 3: both sides For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD. This command is implemented, but not fully supported.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetBrakesRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setbrakesrtd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set camera interest for given entity. Camera interest is by default 0. Any unit which is speaking has its camera interest raised to 50. Camera interest is used to focus camera to control depth of field in cutscenes. Combination of camera interest, unit position of the screen, unit movement, unit type, and some other properties is used to determine which unit to focus at. Higher camera interest increases the chance of the unit being focused.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCameraInterest(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcamerainterest(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets camera shake default parameters.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCamShakeDefParams(GameValue rightInstance)
        {
            return new GameValue(setcamshakedefparams(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets camera shake parameters. Will not have any effect until shake is started via addCamShake.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCamShakeParams(GameValue rightInstance)
        {
            return new GameValue(setcamshakeparams(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets thermal vision mode for currently used camera. This command only works with camCreate created camera that is currently the main camera for the player (see Example 2).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCamUseTi(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcamuseti(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Mark a unit as captive. If unit is a vehicle, commander is marked. A captive unit: is seen as belonging to the civilian Side will not be fired upon will still shoot at its real side's enemies will make its killer earn/lose score/rating as usual will not get its weapons removed (see removeAllWeapons) will not trigger "detected by" conditions for its original Side. The number used as status can be retrieved by captiveNum to keep track of the captivity status at a finer resolution (e.g. handcuffed, grouped, etc).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCaptive(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcaptive(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the center of mass of an object smoothly during the given time (in seconds). A time of zero (or using the alternative syntax) means an immediate change.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCenterOfMass(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcenterofmass(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switches collision lights of a vehicle on/off.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCollisionLight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcollisionlight(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets an individual unit entity behaviour (main syntax) or a group entity behaviour (alternative syntax). The group in this case is a Group entity and not a simple collection of units. To retrieve unit or group behaviour see combatBehaviour. The behaviour is one of:  "CARELESS" "SAFE" "AWARE" "COMBAT" "STEALTH" See AI Behaviour for details of the effect of this command on AI units. Group behaviour usually is "CARELESS" or "SAFE" Comparison of Behaviour commands Command Applies To setBehaviour Every unit in the group, but not the group itself setBehaviourStrong Every unit in the group, and the group itself setCombatBehaviour If argument is Object, only that unit, and if argument is Group, the group itself (not its units)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCombatBehaviour(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcombatbehaviour(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets AI  group combat mode (engagement rules). For individual unit's combat mode see setUnitCombatMode. Mode may be one of the following:  "BLUE" : Never fire, keep formation "GREEN" : Hold fire, keep formation "WHITE" : Hold fire, engage at will/loose formation "YELLOW" : Fire at will, keep formation "RED" : Fire at will, engage at will/loose formation See Combat Modes for more information on combat modes.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCombatMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcombatmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// This command sets random heading on the player's compass (both in map and in 3D view) with given frequency, which is also randomised.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCompassOscillation(GameValue rightInstance)
        {
            return new GameValue(setcompassoscillation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the distance to keep to the vehicle which is in front. This command has to be applied to all vehicles in a convoy in order to have a separation of, for example, 50 m. Vehicles in a convoy can also have different distances. It's recommended that small values (<10m) should only be used for slowly moving convoys, otherwise AI driven vehicles will leave the road frequently to avoid collisions
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetConvoySeparation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setconvoyseparation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Limits or sets local player-controlled vehicle's speed through cruise control. this command only works on CarX, TankX, ShipX simulation vehicles this command is implemented using a PID controller overwriting the vehicle's thrust/brakes input Speed Limiter Cruise Control the vehicle does not accelerate by itself manually accelerating is required to move forward accelerating beyond set speed limit is restricted by the PID controller applying brakes does not disable Speed Limiter behaviour: if the speed is over 120% the set limit, the vehicle will apply 100% of braking and limit acceleration to 0% if the speed is below 80% the set limit, the acceleration and braking are untouched between 80 and 120%, the PID controller limits the acceleration and applies brakes if required the vehicle accelerates by itself manually accelerating is possible accelerating above set speed limit is possible applying brakes disables Cruise Control behaviour: if the speed is over 120% the set limit, the vehicle will apply 100% of braking if the speed is below 80% the set limit, the vehicle will apply 100% of acceleration between 80 and 120%, the PID controller manages the speed ⚠This command should only be called to change values and not be called every frame, as it resets the PID controller.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCruiseControl(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcruisecontrol(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets maximal (ATL) height to which curator camera can move.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCuratorCameraAreaCeiling(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcuratorcameraareaceiling(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets coef for some action (coef have to be bigger than -1 000 000, anything lower is considered as disabled action).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCuratorCoef(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcuratorcoef(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set whether curator can edit in all editing areas (true) or outside of them (false).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCuratorEditingAreaType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcuratoreditingareatype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets cost of waypoints (used for placing, editing and deleting).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCuratorWaypointCost(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcuratorwaypointcost(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets given channel as current chat channel. Scripted way of selecting desired channel on the UI. The given channel may be disabled (see enableChannel), this is why this command returns boolean, true on success or false on failure.  Channel ID number correspondence Default Channels Custom Channels Global Side Command Group Vehicle Direct CC 1 CC 2 CC 3 CC 4 CC 5 CC 6 CC 7 CC 8 CC 9 CC 10 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 For Custom Radio (see radioChannelCreate)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetCurrentChannel(GameValue rightInstance)
        {
            return new GameValue(setcurrentchannel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the task as a current task of the person.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCurrentTask(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcurrenttask(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the currently active waypoint for a group.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCurrentWaypoint(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcurrentwaypoint(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set custom aim precision coefficient for weapon sway
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCustomAimCoef(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcustomaimcoef(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// There is currently no text in this page
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCustomMissionData(GameValue rightInstance)
        {
            return new GameValue(setcustommissiondata(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets value of the specified custom sound controller to be used in simple expressions in config. Returns true if value was set to the controller, false if command fails, for example if vehicle is not a transport or controller name is not recognised. ⚠Custom sound controller name is case sensitive and of the following format: format ["CustomSoundController", _number]; Where _number is a number from 1 to getCustomSoundControllerCount (currently 32)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetCustomSoundController(GameValue rightInstance)
        {
            return new GameValue(setcustomsoundcontroller(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add virtual custom weight to a helicopter's center of gravity. This can be used to simulate added internal payload for specific scenarios, and affects the flight model. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetCustomWeightRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setcustomweightrtd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Event Handler Triggered Hit HandleDamage Killed MPKilled Sets the damage (or lack thereof) of an object/unit. The alternative syntax allows to skip destruction effects for vehicles and buildings. Since Arma 3 v2.12 it is possible to influence trees, poles and walls fall direction by supplying the killer entity param - the fall direction will then be away from killer's position. In multiplayer, the killer argument is ignored if the command is not executed on the server unless it targets trees, walls or poles - see Syntax 2 and Example 3.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDamage(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdamage(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Damages/hurts or repairs/heals object/unit. Damage 0 means fully functional, damage 1 means completely destroyed / dead. ⚠Do not use this command. Use setDamage instead!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDammage(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdammage(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets mission date and time. Players joining after mission start will get the current server date including the year.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDate(GameValue rightInstance)
        {
            return new GameValue(setdate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets debriefing title, text, subtitle, picture and background for a mission ending. The end type could be the engine-defined ("CONTINUE", "KILLED", "LOSER", "END1", "END2", "END3", "END4", "END5", "END6"), config-defined (see CfgDebriefing) or, with an alternative syntax of this command, any String. Given texts will be used to replace the corresponding texts on the debriefing screen.  ⚠In order to benefit from alternative syntax functionality, there will have to be at least 3 arguments passed to the command. 2 arguments will trigger the old behaviour.  
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDebriefingText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdebriefingtext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the position and direction for the camera used after camera is set on no object (log out view when leaving MP game for example)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDefaultCamera(GameValue rightInstance)
        {
            return new GameValue(setdefaultcamera(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the destination for path planning of the pilot. Possible values for planningMode are: "DoNotPlan" - used when not moving "DoNotPlanFormation" - used in formation when simple path testing is used "LEADER PLANNED" - used for formation leader (full path finding used) "LEADER DIRECT" - used for DirectGo (like getin, supply) "FORMATION PLANNED" - used in formation when full path finding is used "VEHICLE PLANNED" - used for vehicle driver Works best when used on agents. Using "LEADER PLANNED" will trigger "PathCalculated"  Event Handler
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDestination(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdestination(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the detail texture map blend pars. Allows for smooth transition between detailed and undetailed terrain texture at distance. If noDetail > fullDetail, the texture detail will incur smooth transition in the area between the thresholds. If noDetail <= fullDetail, there will be obvious visible edge between texture detail changes at fullDetail distance.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDetailMapBlendPars(GameValue rightInstance)
        {
            return new GameValue(setdetailmapblendpars(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set text of a log record.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDiaryRecordText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdiaryrecordtext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a picture to be displayed on the right of the Diary subject. The picture can also be set during custom Diary subject  creation, but this command also allows to change icon for the fixed subjects, like "Tasks", "Diary", "Units", "Players" and "Statistics".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDiarySubjectPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdiarysubjectpicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets object heading. Angles are measured in degrees clockwise from north; the regular range goes from 0 to 360 (0° = N, 90° = E, 180° = S, 270° = W). Negative angles represent counter-clockwise angles. ⚠This command resets the object's velocity and vectorUp! In some earlier titles (Operation Flashpoint?), this command was LELocal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the orientation of a location. The location's area and map icon (if its type uses an icon) will be rotated to this orientation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDirection(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdirection(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the icon to be shown in 2D editor for the specified editor object. If maintain size is false,icon will not scale depending on the scale,of the map. If maintain size is a number,the icon will maintain size,if map scale is below that number. is3D,show line and priority are,optional. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDrawIcon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdrawicon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the path to follow for AI driver. Note that unitReady will return true even if AI is still driving through the points. Using any other move command (e.g _vehicle move getPosATL _vehicle) or doStop will stop the effect of this command. ⚠This command does not work on air vehicles and boats. Only land vehicles are compatible. (cars, tanks, APCs, etc.) For the command to work properly, the unit must either be an agent, or in the case of normal AI, have been stopped using doStop.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDriveOnPath(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdriveonpath(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set interval of emitting particles from particle source. In Arma 3 hardcoded limit of how many particles can exist at the same time is 18000. Correspondence between CfgCloudlets class param name and command param: particleSource setDropInterval interval;
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDropInterval(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdropinterval(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets activation distance of Arma 3: Dynamic Simulation for given category.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDynamicSimulationDistance(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdynamicsimulationdistance(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets activation distance multiplier of Arma 3: Dynamic Simulation for the given class
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetDynamicSimulationDistanceCoef(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setdynamicsimulationdistancecoef(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets map mode to MAP,3D or PREVIEW.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetEditorMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(seteditormode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// This command defines the level of access a user has to editor objects. "objects" is an array of either Editor Objects (eg ["_unit_0"]) or actual Game Objects (eg [player]). If the array is empty then the command will automatically parse all editor objects. "editorType" is the editor type to effect (eg "unit", "vehicle", "center") or "" for all types. "condition" is an executable string that must evaluate to true or false. If true, the scope of the evaluated editor object will be modified. "_x" can be used in the string as reference to the ingame representation of the currently processed array member. "scope" is one of "HIDE", "VIEW", "SELECT", "LINKTO", "LINKFROM", "ALLNODRAG", "ALLNOTREE", "ALLNOCOPY", "ALLNOSELECT" or "ALL". "subordinatesAlso" is a boolean value. If true then subordinates in the editor will be assigned the same scope as the parent. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetEditorObjectScope(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(seteditorobjectscope(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// The statement is executed when the trigger or waypoint is activated and the effects are launched depending on the result. If the result is a boolean and true, the effect is launched. If the result is an object, the effect is launched if the result is the player or the player vehicle. If the result is an array, the effect is launched if the result contains the player or the player vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetEffectCondition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(seteffectcondition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets effectiveCommander of the given vehicle. Effective commander is the person who commands the vehicle, i.e. gives commands to the driver. Every time a person gets in or out of a vehicle, effective commander eligibility is recalculated by the engine based on the current crew. Use this command to force desired effective commander.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetEffectiveCommander(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(seteffectivecommander(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the RPM of given engines. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetEngineRpmRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setenginerpmrtd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set person's face. For a list of available faces, check CfgIdentities. Operation Flashpoint faces Armed Assault faces Arma 2 faces Arma 3 faces Take On Helicopters faces
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFace(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setface(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// There is currently no text in this page
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFaceanimation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfaceanimation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the person's fatigue, from 0 to 1.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFatigue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfatigue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable/disable object as a feature/landmark. Possible feature types: 0 - Feature disabled 1 - Object is always visible within object view distance 2 - Object is always visible within terrain view distance The limit is 500 map/static objects and 200 dynamic objects including config features and auto features (flying helicopters, airplanes). When limit is reached, function returns false.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetFeatureType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfeaturetype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets flag position on the flag pole. To animate flag use BIS_fnc_animateFlag.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFlagAnimationPhase(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setflaganimationphase(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets flag owner. When owner is set to objNull or any object other than a unit of class man or logic, flag is returned to the flagpole. A flag owned by a logic has no visual representation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFlagOwner(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setflagowner(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets flag Side. A flag may be taken by any unit that is enemy to the side that owns the flag. Just like with setFlagTexture, if the command executed where unit is local effect of the command will be global and JIP compatible.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFlagSide(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setflagside(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets flag texture.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFlagTexture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setflagtexture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Smoothly change the fog over given time (in seconds). See also fogParams. This command is MP synchronised, if executed on server, the changes will propagate globally. If executed on client effect is temporary as it will soon change to the server setting.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFog(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfog(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// This article is a Stub. You can help BI Community Wiki by expanding it. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetForceGeneratorRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setforcegeneratorrtd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set group formation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFormation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setformation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the current task of the formation member. This command is not available in Arma 2.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFormationTask(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setformationtask(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets group formation heading. Accepted heading range is 0 to 360. Formation is facing this direction unless enemy is seen. When group is moving, this value is overridden by movement direction. If the new direction is noticeably different from the old direction (approx +/- 15 degrees), units will change positions changing formationDirection.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFormDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setformdir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets how friendly a side is with another. The friendliness is set for one side, not for the other.  See also Side Relations. Since Arma 3 this command can be used mid-mission. Before that it was intended to be used on mission start only, as changing value during mission could cause unexpected errors in AI behaviour (especially for groups already knowing about "switched to enemy" groups).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFriend(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfriend(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set if given team member was inserted directly from editor.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFromEditor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfromeditor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set variable to given value in the variable space of given FSM. The FSM handle is the number returned by the execFSM command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFSMVariable(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfsmvariable(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets fuel level.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFuel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfuel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets fuel amount in cargo space of refuel vehicles. Note that the carrying capacity of each side's refuel trucks differ.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetFuelCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setfuelcargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets group icon properties.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetGroupIcon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setgroupicon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set group icons parameters.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetGroupIconParams(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setgroupiconparams(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets if group icons raise onGroupIconClick, onGroupIconOverEnter and onGroupIconOverLeave events.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetGroupIconsSelectable(GameValue rightInstance)
        {
            return new GameValue(setgroupiconsselectable(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets if group icons added with addGroupIcon are visible on map and in the HUD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetGroupIconsVisible(GameValue rightInstance)
        {
            return new GameValue(setgroupiconsvisible(rightInstance._internalGameValue));
        }

        /// <summary>
        /// There is currently no text in this page
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetGroupid(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setgroupid(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// A global equivalent of  setGroupId.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetGroupIdGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setgroupidglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the ownership of a group (and all its units) to a given client. The group leader must not be a player. This command only works when called from the server. Returns true if locality was changed. For agents use setOwner command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetGroupOwner(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setgroupowner(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the gusts value smoothly during the given time (in seconds). A time of zero means there will be an immediate change. Value is 0 to 1.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetGusts(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setgusts(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the data for hiding. objectWhereHide can be taken using findCover. hidePosition can be taken using getHideFrom. Command is not functional in Arma 2. ⚠This command is not implemented!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetHideBehind(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sethidebehind(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Event Handler Triggered Hit HandleDamage Killed MPKilled Set damage on a part of an object. Some part names are in Czech; see the translation table.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetHit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sethit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the current level of damage for a specific Hit Point. All hit points can be obtained with getAllHitPointsDamage command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetHitIndex(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sethitindex(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Event Handler Triggered Hit HandleDamage Killed MPKilled Set the current level of damage for a specific Hit Point (specified by its config class). This command has no effect when allowDamage is set to false. See also BIS_fnc_setHitPointDamage for setting hit with dependency.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetHitPointDamage(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sethitpointdamage(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets coef used to shift horizon position based on camera height (use 0 to disable shifting).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetHorizonParallaxCoef(GameValue rightInstance)
        {
            return new GameValue(sethorizonparallaxcoef(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set min/max movement borders displayed in HUD gauges. Use -1 to skip some value.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetHUDMovementLevels(GameValue rightInstance)
        {
            return new GameValue(sethudmovementlevels(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets surface humidity. Affects how footsteps sound (dry / wet). humidity is increasing when raining and decreasing when not raining. Exception is if the rain is set with 'snow' flag, then humidity is not updated.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetHumidity(GameValue rightInstance)
        {
            return new GameValue(sethumidity(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets identity of a person. The identities could be defined in a custom config in Description.ext or in the main config. For a list of available main config values see CfgIdentities.   This command is an aggregate of the following commands: setName, setFace, setSpeaker, setNameSound, setPitch, only the values are loaded from the given config. It also includes value for glasses for which currently there is no direct command, instead there is an inventory command addGoggles.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetIdentity(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setidentity(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the importance value of location.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetImportance(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setimportance(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Opens given component or first component of given component type on specified info panel.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetInfoPanel(GameValue rightInstance)
        {
            return new GameValue(setinfopanel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// ⚠To set a Group leader, see selectLeader. Set the leader of the given Team. Effect is local, unless both leader unit and team are local to PC on which command is executed, then effect is global.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLeader(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setleader(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set ambient color of light. This includes surfaces that face away from the light, unlike setLightColor.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightAmbient(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightambient(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets attenuation of light. Standard method of attenuation (1 / (constant + linear*dist + quadratic*dist*dist)). start param represents distance where the attenuation starts to take effects (dist = distance - start).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightAttenuation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightattenuation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set brightness of light. This command is outdated. Use setLightIntensity instead.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightBrightness(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightbrightness(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set diffuse color of light. Illuminates surfaces that are facing the light.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the lightpoint (directional light #lightreflector)'s cone params.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightConePars(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightconepars(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets if light can be used during the day.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightDayLight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightdaylight(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets max distance where the flare is visible.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightFlareMaxDistance(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightflaremaxdistance(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets relative size of the flare for the light.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightFlareSize(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightflaresize(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets intensity of light.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightIntensity(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightintensity(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets lightpoint in infrared range.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightIR(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the lightnings value smoothly during the given time (in seconds). A time of zero means there will be an immediate change. NOTE: This command will have no effect (even though the value of lightnings changes) unless Manual Override option is selected in the editor in the Intel, which is normally off.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightnings(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightnings(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets if light has flare.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightUseFlare(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightuseflare(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the lightpoint (directional light #lightreflector)'s volume shape.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLightVolumeShape(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setlightvolumeshape(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets parameters for helicopter rotor wash. It affects the visual effect of a rotor's downwash, such as blown particles, vegetation wind effect and area size.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetLocalWindParams(GameValue rightInstance)
        {
            return new GameValue(setlocalwindparams(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets ammo count to given amount for given turret. ⚠Broken when vehicle has multiple magazines of the same type.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMagazineTurretAmmo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmagazineturretammo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the marker alpha. The marker is modified on all computers in a network session. When alpha equals 1, the marker is visible, but if alpha equals 0, then the marker is invisible. Alpha can be numbers and fractions. Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerAlpha(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkeralpha(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the marker alpha.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerAlphaLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkeralphalocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects the fill texture for the marker ("RECTANGLE" or "ELLIPSE"). Brush is the name of the subclass in CfgMarkerBrushes. brush can be: "Solid" "SolidFull" (A3 only) "Horizontal" "Vertical" "Grid" "FDiagonal" "BDiagonal" "DiagGrid" "Cross" "Border"  (Not present in A1) "SolidBorder"  (Not present in A1) Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerBrush(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkerbrush(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects the fill texture for the marker ("RECTANGLE" or "ELLIPSE"). Brush is the name of the subclass in CfgMarkerBrushes. brush can be: "Solid" "SolidFull" (A3 only) "Horizontal" "Vertical" "Grid" "FDiagonal" "BDiagonal" "DiagGrid" "Cross" "Border" (A2/A3 only) "SolidBorder" (OA/A3 only)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerBrushLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkerbrushlocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets marker color. Marker color names and their corresponding RGBA values for Arma 3 could be found here: Arma 3: CfgMarkerColors Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkercolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets marker color for the given marker locally. Marker color names and their corresponding RGBA values for Arma 3 could be found in here: Arma 3: CfgMarkerColors
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerColorLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkercolorlocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the orientation of the marker. Angle is in degrees. Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkerdir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the orientation of the marker.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerDirLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkerdirlocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a polyline marker's path. Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerPolyline(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkerpolyline(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a polyline marker's path. Works only on the computer that executes this command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerPolylineLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkerpolylinelocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves the marker. If position is given in 3D format, z coordinate is stored with the marker and will be used when marker is passed to commands like createVehicle, createUnit, createAgent, createMine, setVehiclePosition for example. When Object is used for position, its getPosWorld is used. Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkerpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves the marker. If position is given in 3D format, z coordinate is stored with the marker and will be used when marker is passed to commands like createVehicle, createUnit, createAgent, createMine, setVehiclePosition for example. When Object is used for position, its getPosWorld is used.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerPosLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkerposlocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the shadow property of given marker.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerShadow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkershadow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the shadow property of given marker.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerShadowLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkershadowlocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects shape (actual type) of the marker.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerShape(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkershape(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Selects shape (actual type) of the local marker.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerShapeLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkershapelocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the marker's size. Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerSize(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkersize(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set marker size.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerSizeLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkersizelocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text label of an existing marker. Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkertext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text label of an existing marker.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerTextLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkertextlocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets marker type. Marker type is a class name from CfgMarkers. Multiplayer optimisation: Global marker commands always broadcast the entire marker state over the network. As such, the number of network messages exchanged when creating or editing a marker can be reduced by performing all but the last operation using local marker commands, then using a global marker command for the last change (and subsequent global broadcast of all changes applied to the marker).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkertype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets marker type locally. Marker type is a class name in CfgMarkers.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMarkerTypeLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmarkertypelocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the mass of a PhysX object. When using the alternative syntax the mass change is gradual during the given time. A time of zero means immediate change.⚠When main syntax is used on local vehicle, the change is global. When alternative syntax is used with time transition on local vehicle, the gradual mass change doesn't happen on remote clients, only final mass is applied after the given time. If you need gradual change on remote clients too,  remote execute setMass globally.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMass(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmass(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets maximum load limit for a uniform/vest/backpack containers, vehicle cargo, supply boxes and weapon holders. In MP this command should be executed on the server and will persist on given container for JIP. Cannot be set on a unit, as unit max load value is static config type
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMaxLoad(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmaxload(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets person's facial expression. To set it back to default, use "". Prior to Arma 3 v2.01.146630 Mimics must be written in all lower case letters.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMimic(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmimic(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a guided missile target. Does not work for all types of missiles. If the target is dead, it is ignored. The target has to be inside the missile's configured targeting cone for the command to work.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetMissileTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmissiletarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a guided munition target position. The munition must have manualControl config entry to use this command. The target position has to be inside the missile's configured targeting cone for the command to work.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMissileTargetPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmissiletargetpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves mouse pointer to specified position on the screen. x and y could be any number, but will be clipped so mouse never leaves the screen area.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMousePosition(GameValue rightInstance)
        {
            return new GameValue(setmouseposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines a music track played on activation. If another track is playing already, this will stop it and start the new track. Track is a subclass name of CfgMusic. In addition, "$STOP$" (stops the current music track) or use playMusic "". When used in a trigger, the track starts on activation but does not automatically stop on deactivation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMusicEffect(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setmusiceffect(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets given music track event handler. Will overwrite other music event handlers. 🕖The following information is obsolete. Reason: Use addMusicEventHandler instead as it can stack music event handlers.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetMusicEventHandler(GameValue rightInstance)
        {
            return new GameValue(setmusiceventhandler(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the name of a location or a person (person only in single player).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetName(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setname(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the nameSound of a person. By default, when giving orders, the units are addressed by their number. When nameSound is set, it will be used instead to address the unit. For example: "Two, hold fire!", one can have: "Miller, hold fire!". See CfgIdentities - NameSounds for common values. Note that any word from configfile >> "RadioProtocolENG" >> "Words" is accepted (e.g "veh_infantry_Sniper_s").
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetNameSound(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setnamesound(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set object arguments in mission editor. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue SetObjectArguments(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setobjectarguments(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets material of object selection. The selection number is defined through the hiddenselection[] = {} array in the vehicle's config (starting with 0).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetObjectMaterial(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setobjectmaterial(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the material of the given selection on all computers in a network session.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetObjectMaterialGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setobjectmaterialglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the proxy object associated with the given editor object. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue SetObjectProxy(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setobjectproxy(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Scales an attached object or a Simple Object's model - see Example 3 for various configurations' examples.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetObjectScale(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setobjectscale(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Applies given texture to object's selection. See also Procedural Textures and Retexturing with setObjectTexture. Not all objects can be textured this way. To find out, run getObjectTextures command on an object. Empty array [] usually indicates it cannot be textured. All textures must have a resolution of 2a × 2b (e.g. 16×16, 16×32, 64×256, 512×512, ...). The largest texture size supported by the RV engine is 4096×4096. Supported formats: .pac, .paa, .jpg, .jpeg, .ogg, .ogv
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetObjectTexture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setobjecttexture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the texture of the given selection on all computers in a network session. Not all objects can be textured this way. To find out, run getObjectTextures command on an object. Empty array [] usually indicates it cannot be textured. All textures must have a resolution of 2a × 2b (e.g. 16×16, 16×32, 64×256, 512×512, ...). The largest texture size supported by the RV engine is 4096×4096. Supported formats: .pac, .paa, .jpg, .jpeg, .ogg, .ogv
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetObjectTextureGlobal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setobjecttextureglobal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the rendering distance of objects and shadows.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetObjectViewDistance(GameValue rightInstance)
        {
            return new GameValue(setobjectviewdistance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the optic mode of the current weapon to the given class name or the index.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetOpticsMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setopticsmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set overcast to given value smoothly during given time (in seconds). Zero time means immediate change. An overcast setting of zero means clear (sunny) weather, and one means storms and rain are very likely. Higher overcast values also result in higher wind speeds.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetOvercast(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setovercast(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// From server machine, change the ownership of an object to a given client. Using command in an unintended way will log a message to .rpt file. To transfer ownership of all AI units in a group properly, use setGroupOwner instead.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetOwner(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setowner(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets oxygen remaining. It has no effect when soldier is not diving. Oxygen remaining is a number between 0 and 1.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetOxygenRemaining(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setoxygenremaining(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Updates particle source, creates particles in circle with given radius. Velocity is transformed and added to total velocity.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetParticleCircle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setparticlecircle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets particle source parameters using existing particle config from CfgCloudlets class. Use setParticleParams subsequently if you need to overwrite some values. ⚠If CfgCloudlets class contains  simple expressions, they will not be evaluated by this command, which might make the whole class unusable in script.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetParticleClass(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setparticleclass(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set fire parameters to particle effect. Note: You need to create emitter at first. Basic parameters of particle effect must be defined too. You can use script commands setParticleClass or setParticleParams to do so (see example). Correspondence between CfgCloudlets class param names and command array of params: particleSource setParticleFire [ coreIntensity, 	coreDistance, 	damageTime ];
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetParticleFire(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setparticlefire(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set parameters to particle source. Array is in format ParticleArray.  Since Arma 3 version 1.11.114706 you can use this command to overwrite many values set by setParticleClass, particularity those defined in ParticleArray. Correspondence between CfgCloudlets class param names and command array of params: particleSource setParticleParams [ /* 		String or Array - If string then the name of the particleShape. And following default values are used: 			particleFSNtieth = 1 			particleFSIndex = 0 			particleFSFrameCount = 1 			particleFSLoop = 1 	*/ [ particleShape,			/* String */ particleFSNtieth,		/* Number */ particleFSIndex,		/* Number */ particleFSFrameCount,	/* Number */ particleFSLoop /* Optional - Number. Default: 1 */ ], 	animationName,				/* String */ particleType,				/* String - Enum: Billboard, SpaceObject */ timerPeriod,				/* Number */ lifeTime,					/* Number */ pos3D,						/* 3D Array of numbers as relative position to particleSource or (if object at index 18 is set) object. 									Or (if object at index 18 is set) String as memoryPoint of object. */ moveVelocity,				/* 3D Array of numbers. */ rotationVelocity,			/* Number */ weight,						/* Number */ volume,						/* Number */ rubbing,					/* Number */ sizeOverLifetime,			/* Array of Numbers */ color,						/* Array of Array of RGBA Numbers */ animationSpeed,				/* Array of Number */ randomDirectionPeriod,		/* Number */ randomDirectionIntensity,	/* Number */ onTimerScript,				/* String */ beforeDestroyScript,		/* String */ obj,						/* Object */ angle,						/* Optional Number - Default: 0 */ onSurface,					/* Optional Boolean */ bounceOnSurface,			/* Optional Number */ emissiveColor,				/* Optional Array of Array of RGBA Numbers */ vectorDirOrVectorDirAndUp /* Optional vector dir or [vectorDir, vectorUp] 		Since Arma 3 v1.92 it is possible to set the initial direction of the SpaceObject 		Since Arma 3 v2.12 it is possible to use a [vectorDir, vectorUp] array */ ];
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetParticleParams(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setparticleparams(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets randomization of particle source parameters. Correspondence between CfgCloudlets class param names and command array of params: particleSource setParticleRandom [ lifeTimeVar, 	positionVar, 	moveVelocityVar, 	rotationVelocityVar, 	sizeVar, 	colorVar, 	randomDirectionPeriodVar, 	randomDirectionIntensityVar, 	angleVar, 	bounceOnSurfaceVar ];
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetParticleRandom(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setparticlerandom(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the direction of object airplane or helicopter pilotCamera (vector in model space).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPilotCameraDirection(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpilotcameradirection(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets rotation (relative to the centered camera position) of the object airplane or helicopter pilotCamera .
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPilotCameraRotation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpilotcamerarotation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets an area or target to be tracked by the object airplane or helicopter pilotCamera.  To track an object the vehicle has to have appropriate sensors (scanners) that can detect the given target type. Using objNull will unlock the camera
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetPilotCameraTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpilotcameratarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switches headlights of a vehicle on/off. Note that the vehicle has to be local, for global variant use Arma 3 Actions "LightOn"/"LightOff"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPilotLight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpilotlight(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets Render Target's visual effect (Picture-in-Picture). Mode Description Parameters 0 Normal [0] 1 Night Vision [1] 2 Thermal Imaging [2] 3 Color Correction [3, enabled, brightness, contrast, offset, blend [r,g,b,a], lerp [r,g,b,a], rgb [r,g,b,a]] 7 Alt. Thermal Imaging 1 (Inverted) [7] 8 Alt. Thermal Imaging 2 (Green) [8] 9..70 2.10 Alt. Thermal Imaging 3..64 [n]
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPiPEffect(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpipeffect(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the PiP (Picture-in-Picture) view distance. This has no impact if PiP is disabled (see isPiPEnabled).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPiPViewDistance(GameValue rightInstance)
        {
            return new GameValue(setpipviewdistance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the pitch of a persons voice.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPitch(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpitch(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Change the license plates on any vehicle which has plates configured. Max 15 characters are allowed!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPlateNumber(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setplatenumber(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create a multiplayer role for the unit. The roles created this way are used for Join In Progress and Team Switch.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPlayable(GameValue rightInstance)
        {
            return new GameValue(setplayable(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the time interval (in seconds) that the player must wait before respawn. It resets to mission default on mission start. In Single Player or when respawn type is GROUP or SIDE in Multiplayer, setting player respawn time has no effect, and playerRespawnTime will always return -1.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPlayerRespawnTime(GameValue rightInstance)
        {
            return new GameValue(setplayerrespawntime(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets provided player's Voice over Network (VoN) volume.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPlayerVoNVolume(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setplayervonvolume(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets object position to format PositionAGLS (over surface). The Z value is used to calculate the nearest surface below the provided position. If the surface is close, it uses the Z position of the surface. Otherwise, Z value becomes the offset from that surface. ⚠It is recommended to avoid this command when placing objects above other objects, due to the unpredictable behavior described above.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the object position above sea level. Given position must be in PositionASL format.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPosASL(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setposasl(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the object position. The pos array uses the PositionASL format. The version of the command does not offset based on object center.  ⚠This command was deactivated and has no effect. Use setPosWorld instead.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPosASL2(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setposasl2(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the object position above sea surface. The pos array uses the PositionASLW format.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPosASLW(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setposaslw(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the position of an object relative to the terrain.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPosATL(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setposatl(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the position of a location.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets position of an object based on the model's centre position (see getPosWorld).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPosWorld(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setposworld(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds/overrides loadout to a vehicle pylon. TransportPylonsComponent in vehicle config and pylonWeapon in the magazine config are required to run.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetPylonLoadout(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpylonloadout(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Overrides default pylons priorities.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetPylonsPriority(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setpylonspriority(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets radio trigger menu title text (0 -> 0 -> map radio). Use "NULL" to disable radio slot. Use "" to restore default title
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetRadioMsg(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setradiomsg(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets rain density smoothly over the given transition time. A transition time of zero means an immediate change. A rain density of zero is no rain, one is maximum rain. Rain is not possible when overcast is less than 0.7. Since Arma 3 this command is multiplayer synchronised: if executed on the server, the changes will propagate globally. if executed on a client, the effect is local, temporary and will soon change to the server setting. Minimum overcast needed for rain in Arma 3 is 0.5. ⚠Alternative syntaxes (Syntax 2 and Syntax 3): set rain particle params. Rain particles params are client-side params and are ignored on dedicated server. Use helper function BIS_fnc_setRain if sync is needed in Multiplayer have a local LELocal effect
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetRain(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setrain(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the rainbow value smoothly during the given time (in seconds). A time of zero means there will be an immediate change.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetRainbow(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setrainbow(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables/Disables random lip. When enabled, the unit continuously moves its lips as if it is talking.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetRandomLip(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setrandomlip(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets rank of given unit. Before Arma 3 v1.68 and in previous titles, this command was GAGlobal LELocal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetRank(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setrank(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the shape of a location to be either rectangular or elliptical. Locations default shape is elliptical.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetRectangular(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setrectangular(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set amount of repair resources in cargo space of repair vehicle. Amount 1 is full cargo.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetRepairCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setrepaircargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggles a helicopter's rotor brake. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetRotorBrakeRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setrotorbrakertd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the shadows rendering distance.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetShadowDistance(GameValue rightInstance)
        {
            return new GameValue(setshadowdistance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets vehicle and instigator pair for the given projectile.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetShotParents(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setshotparents(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a location's side. The default side is Unknown. ⚠To change a unit's side, see Notes.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSide(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setside(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets task's visibility.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSimpleTaskAlwaysVisible(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsimpletaskalwaysvisible(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set custom data for the task. Tooltip will be drawn in task list on the right side. Description will be drawn in task description panel on the bottom.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSimpleTaskCustomData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsimpletaskcustomdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attach descriptions to the simple task.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSimpleTaskDescription(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsimpletaskdescription(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attach a destination to the simple task.Overrides setSimpleTaskTarget
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSimpleTaskDestination(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsimpletaskdestination(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attach a target to the simple task.Overrides setSimpleTaskDestination.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSimpleTaskTarget(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsimpletasktarget(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attach type to the simple task. See Default Task Types.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSimpleTaskType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsimpletasktype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets number of simul weather layers, affects quality of simul weather clouds.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSimulWeatherLayers(GameValue rightInstance)
        {
            return new GameValue(setsimulweatherlayers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the size (radius)  of a location. The width  is 2 * x, the height is 2 * y.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSize(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsize(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the skill level of given unit. The value of a sub-skill is interpolated into a range defined in CfgAISkill.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSkill(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setskill(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a sling loading from a helicopter to an entity if possible. To unload cargo, pass objNull as second param. FROM object has to be a helicoper, alive with  rope attachment enabled, TO object has to be an entity, alive with  rope attachment enabled.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetSlingLoad(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setslingload(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines the different sound effects for a trigger or a waypoint. To stop any sound, deactivate the trigger (might take up to 0.5 seconds to stop) or delete the trigger/waypoint (immediate).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSoundEffect(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsoundeffect(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the speaker of a person.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSpeaker(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setspeaker(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add speech to location.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSpeech(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setspeech(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets group speed mode. If unit is passed as param, unit's group is used. Mode may be one of:  "UNCHANGED" (unchanged) "LIMITED" (half speed) "NORMAL" (full speed, maintain formation) "FULL" (do not wait for any other units in formation)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSpeedMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setspeedmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set units' stamina (seconds until depletion)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetStamina(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setstamina(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the scheme used for the Stamina system.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetStaminaScheme(GameValue rightInstance)
        {
            return new GameValue(setstaminascheme(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a value to a given stat.  A list of possible StatNames can be found here: Arma 3: Stat Names Its important to note that most Stats are restricted to scripts and missions in certain paths. For example "ExpWarlockDown" is restricted to scripts in any subdirectory of "a3\Missions_F_Exp\Campaign\Missions\"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetStatValue(GameValue rightInstance)
        {
            return new GameValue(setstatvalue(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the given suppression value for the given unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSuppression(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setsuppression(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set system of units. This will only impact gauges from advanced flight model. ⚠This command is buggy: any value other than 0 (metric) will display both units at the same time.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetSystemOfUnits(GameValue rightInstance)
        {
            return new GameValue(setsystemofunits(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets how the target is known to the other centers. They behave like the target was seen age seconds ago. Possible age values are: "ACTUAL", "5 MIN", "10 MIN", "15 MIN", "30 MIN", "60 MIN", "120 MIN" or "UNKNOWN".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTargetAge(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settargetage(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the task marker position in model space.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTaskMarkerOffset(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settaskmarkeroffset(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set a result of the task.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTaskResult(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settaskresult(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the state of a given task.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTaskState(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settaskstate(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the desired  terrain resolution in meters.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTerrainGrid(GameValue rightInstance)
        {
            return new GameValue(setterraingrid(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the current terrain's altitude on provided location(s). ⚠ Heightmap changes: are internally converted (rounded) to heightmap coordinates are stored in the JIP queue are not removed from the JIP queue if the values are set back to terrain's default value are updated in the JIP queue for updated positions if the same group of positions are edited (order does not matter, but amount does);editing positions by terrain sections is good for multiplayer optimisation (see Example 2) are not updated and sent twice (old one then new one) if position edits are not exactly the same (see point above and Example 2). Edited terrain heights are not saved inside savegames, they need to be restored manually on savegame load. Known issues: Terrain sections can become invisible if the change is too extreme Walking on the edge of extreme height changes can catapult the player away
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTerrainHeight(GameValue rightInstance)
        {
            return new GameValue(setterrainheight(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text associated with a location. This text will be displayed on the game map at the location's position.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets a time multiplier for in-game time. The command range is capped at 0.1 - 120 to avoid performance problems.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTimeMultiplier(GameValue rightInstance)
        {
            return new GameValue(settimemultiplier(rightInstance._internalGameValue));
        }

        /// <summary>
        /// There is currently no text in this page
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTiParameter(GameValue rightInstance)
        {
            return new GameValue(settiparameter(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines the title effect to show on activation via [Type, Effect, Text] where 'Type'  The title effect does not disappear on deactivation, this should be done manually if required.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTitleEffect(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settitleeffect(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Simulation Towable Can Tow CarX TankX AirplaneX BoatX Allows a vehicle to be towed by another. This loosens the towed vehicle's brakes and turns its steering wheels toward the towing vehicle. Supposed to be used together with a rope connecting both vehicles.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTowParent(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settowparent(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the density of ambient cars in a rectangle (in cars per kilometer). This command does nothing in Arma 3.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTrafficDensity(GameValue rightInstance)
        {
            return new GameValue(settrafficdensity(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set maximum ambient traffic draw distance (in 2D). This command does nothing in Arma 3.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTrafficDistance(GameValue rightInstance)
        {
            return new GameValue(settrafficdistance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the average gap between ambient cars in a rectangle (in meters). This command does nothing in Arma 3.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTrafficGap(GameValue rightInstance)
        {
            return new GameValue(settrafficgap(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set ambient traffic speed in a rectangle (in kilometers per hour). This command does nothing in Arma 3.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTrafficSpeed(GameValue rightInstance)
        {
            return new GameValue(settrafficspeed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines the trigger activation type.  See ArmA:Mission Editor - Triggers for a thorough overview of triggers and its fields for activation, effects, etc.   Since Arma 3 v1.67, "ANYPLAYER" activation can be used to detect any player.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTriggerActivation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settriggeractivation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        ///  Trigger axis a, b and c (half of their x, y and z dimensions) Defines the area monitored by the given trigger. The area could be either rectangular or elliptical. Just like with a and b dimensions, c dimension will alter area in opposite directions from the trigger position along z axis. Therefore if the trigger position is on the surface, half of the trigger area will be above the surface and half below. To place the whole area above the surface, adjust trigger position (move it up c meters). If c is not specified or <= 0, the trigger's height is considered infinite like 2D triggers.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTriggerArea(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settriggerarea(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the interval in seconds for trigger condition check. Triggers are configured to check condition approx. every 0.5 second by default. This command allows either to slow down or to speed up default check interval per trigger. Setting interval to 0 will make the trigger check its condition every frame. However, when trigger is attached to some object, the trigger will inherit the simulation frequency of the object it is  attached to. This command cannot change the interval of the attached trigger. The trigger can also be "frozen" with enableSimulation command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTriggerInterval(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settriggerinterval(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines trigger condition, activation and deactivation statements. Trigger condition has to return Boolean. true will activate the trigger, false will deactivate it (only if activation is set to repeat). thisList returns the same result as list command, which includes all entities in the trigger area that are capable of activating the trigger. Dead entities are excluded as well as crew in vehicles, vehicles themselves are included.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTriggerStatements(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settriggerstatements(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text label attached to the trigger object. This is used for example as a radio slot label for radio activated triggers.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTriggerText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settriggertext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines the time between condition satisfaction and trigger activation (randomly from min to max, with an average value mid). If the last argument is true, the condition must be fullfilled all the time.  For a normal trigger, min, mid and max are used to generate random duration according to Gaussian Distribution[1]. For a "Seized" type of trigger, the duration value is generated using side ruling power
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTriggerTimeout(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settriggertimeout(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the type of action processed by the trigger after activation (no action, a waypoints switch or an end of mission): "NONE" "EAST G" - Guarded by OPFOR - (It is better to use createGuardedPoint instead) "WEST G" - Guarded by BLUFOR - (It is better to use createGuardedPoint instead) "GUER G" - Guarded by Independent - (It is better to use createGuardedPoint instead) "SWITCH" - Switch waypoints/break loop (see Triggers) "END1" - End #1 "END2" - End #2 "END3" - End #3 "END4" - End #4 "END5" - End #5 "END6" - End #6 "LOOSE" - (Meant to say LOSE but is misspelt in the game engine). "WIN" - (Not in editor. Valid enum name but when set, defaults to "END1")
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTriggerType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settriggertype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the rotation and elevation limits for the given turret. The limits can only be set within the limits defined in config and cannot exceed them. To reset to config defaults pass the turret argument only (Example 2).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTurretLimits(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setturretlimits(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set the current optics mode of the optics in the turret occupied by the specified unit. Alt syntax allows a vehicle and turret path to be specified instead of a unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetTurretOpticsMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setturretopticsmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes a location to the specified class. Location classes are defined in CfgLocationTypes.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(settype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// In Arma 2 and since Arma 3 v1.64, this command sets unit into incapacitated state. lifeState results: Arma 2: "UNCONSCIOUS" Arma 3: "INCAPACITATED" The unit goes in ragdoll mode and animation played while incapacitated depends on the injuries received.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnconscious(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunconscious(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets skill of given unit. Unlike setSkill, setUnitAbility can set values > 1. Even though the skill command will correctly return set value, the actual unit ability will be capped to max available.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitAbility(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunitability(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets unit's combat mode (engagement rules). For AI group combat mode see setCombatMode. Mode may be one of the following:  "BLUE" : Never fire, keep formation "GREEN" : Hold fire, keep formation "WHITE" : Hold fire, engage at will/loose formation "YELLOW" : Fire at will, keep formation "RED" : Fire at will, engage at will/loose formation See Combat Modes for more information on combat modes.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitCombatMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunitcombatmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets minimum freefall height AGL per unit, at which the unit assumes HALO pose. Engine default is 100m. Use -1 to reset the height to default.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitFreefallHeight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunitfreefallheight(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a loadout from given inventory structure and applies it to a unit. When String for class name is supplied, the command will search CfgVehicles for the given class in order to extract the loadout from config. If Config is given, it will search given config (including  mission config) for the loadout information. In either case, the config should contain the following entries, which is standard for any unit class, for example: class MyLoadout { 	uniformClass = "U_B_CombatUniform_mcam"; 	backpack = "B_AssaultPack_mcamo"; 	linkedItems[] = {"V_PlateCarrier1_rgr","H_HelmetB","ItemCompass","ItemWatch","ItemRadio","NVGoggles"}; 	weapons[] = {"arifle_MX_ACO_pointer_F","hgun_P07_F"}; 	items[] = {"FirstAidKit","FirstAidKit","FirstAidKit"}; 	magazines[] = {"30Rnd_65x39_caseless_mag","16Rnd_9x21_Mag","SmokeShell","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade","HandGrenade"}; };
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitLoadout(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunitloadout(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set unit position rules. This command will not change the stance of the human player, even though it will change the output of unitPos command. To change player stance use playAction or playActionNow: player playAction "PlayerProne"; // DOWN player playAction "PlayerStand"; // UP player playAction "PlayerCrouch"; // MIDDLE
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunitpos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set unit position rules. This command is the lowest level of priority for setting unit position and to be used in scripted	 FSM's. Priorities are: Unit pos commanded (from the commanding menu, higher priority). Unit pos scripted (from setUnitPos scripting command, medium priority). Unit pos FSM / setUnitPosWeak (used in the formation FSM, lowest priority).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitPosWeak(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunitposweak(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets rank of given unit. Possible rank values, and the associated rating that is set (not added, the value replaces previous rating) with it: Ranks PRIVATE CORPORAL SERGEANT LIEUTENANT CAPTAIN MAJOR COLONEL Ratings ArmA Arma 2 Arma 2:OA TKOH 0 500 1500 2500 3500 5000 7500 Arma 3 (ca 2015) 0 50 150 250 350 500 750 Arma 3 0 0 0 0 0 0 0 Before Arma 3 v1.68 and in previous titles, this command was GAGlobal LELocal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitRank(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunitrank(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Proportionaly increase/decrease unit's recoil. Drives muzzle up with every shot when supplied positive number and down when negative. 0 cancels recoil.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitRecoilCoefficient(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunitrecoilcoefficient(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables or disables a trait or alters a trait of the given unit. Custom trait can only be a bool. Default traits are: Number audibleCoef - A lower value means the unit is harder to hear Number camouflageCoef - A lower value means the unit is harder to spot Number loadCoef - Equipment weight multiplier affecting fatigue and stamina Boolean engineer - Ability to partially repair vehicles with toolkit, equivalent to engineer = 1; in CfgVehicles Boolean explosiveSpecialist - Ability to defuse mines with toolkit, equivalent to canDeactivateMines = 1; in CfgVehicles Boolean medic - Ability to treat self and others with medikit, equivalent to attendant = 1; in CfgVehicles Boolean UAVHacker - Ability to hack drones, equivalent to uavHacker = 1; in CfgVehicles
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnitTrait(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunittrait(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets whether or not cargo or turret units should get out of vehicle when in combat. If true, vehicle will stop and units will dismount. Vehicle must be local. The command resets last time unit had reacted to an enemy as well as forcing orderGetIn false if canUnloadInCombat is permitted by config
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUnloadInCombat(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setunloadincombat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        ///  Changes user added action (see addAction) menu item text. 
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUserActionText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setuseractiontext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Stored user text value in MFD, limit is 50, user0...user49
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUserMFDText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setusermfdtext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// When MFD is using user controllers, this command can set values on them. For example, MFD config for Blackfoot has an entry // ... class Draw { 	alpha = "user3"; 	color[] = {"user0","user1","user2"}; // ... which could control color of the MFD. See Example 2-3-4 on how to set different colors of the Blackfoot MFD
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetUserMFDValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setusermfdvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set variable to given value in the variable space of given element. Can be used to broadcast variables over the network. To remove a variable, set it to nil (see Example 5) - note that this does not work on Object and scripted Location namespaces (the variable will be set to nil but will remain listed by allVariables). ⚠missionNamespace, uiNamespace, parsingNamespace and profileNamespace variables cannot be named as commands - e.g missionNamespace setVariable ["west", 123]; conflicts with the west command and will result in a Reserved variable in expression error, west being a scripting command (other namespaces do not have such limitation). See also all available script commands.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVariable(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvariable(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set object's direction vector. Up vector will remain unchanged.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVectorDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvectordir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        ///  Sets orientation of an object. The command takes 2 vector arrays, one for vectorDir and one for vectorUp. Default object orientation will always have vectorDir pointing forward (North) along Y axis and vectorUp pointing up along Z axis - [[0,1,0],[0,0,1]], as shown on the diagram below (see also BIS_fnc_transformVectorDirAndUp). When attaching object to an object the axes are relative to the object that gets the attachment. If it is player object for example, then X goes from left to right, Y goes from back to front, and Z goes from down up. The setDir command is incompatible with setVectorDirAndUp and should not be used together on the same object. Using setVectorDirAndUp alone should be sufficient for any orientation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVectorDirAndUp(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvectordirandup(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set object's up vector. Direction of the object remain unchanged. Default object's vectorUp is [0,0,1].
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVectorUp(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvectorup(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets how much ammunition (compared to a full state defined by the vehicle type) the vehicle has. Note that the ammo will be added only to local turrets. To check locality of turret use turretLocal. The value ranges from 0 to 1.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleAmmo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehicleammo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets how much ammunition (compared to the configuration of magazines defined in the vehicle's class) the vehicle has. Note that the ammo will only be added to local turrets. To check the locality of turret use turretLocal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleAmmoDef(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehicleammodef(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the armor (or health for men) state of the vehicle (a value from 0 to 1).  Works like setDamage, but the other way around: 1 is full health - see Example 2.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleArmor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehiclearmor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Load cargo vehicle inside vehicle if possible, returns bool based on whether the vehicle was able to be loaded.  Can also be used to unload a specific loaded vehicle or all loaded vehicles.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetVehicleCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehiclecargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets ID to vehicle. By this ID vehicle is referenced by triggers and waypoints. ⚠This command is not to be used.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleId(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehicleid(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets vehicle lock. Possible values: "UNLOCKED" "DEFAULT" "LOCKED" "LOCKEDPLAYER"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleLock(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehiclelock(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Moves the object to a given position (same as createVehicle placement algorithm). Uses either the position that's defined by the position param, or one of the marker positions from the markers array. The object is placed inside a circle with position as its center and placement as its radius. The type of placement could also be controlled with special. If position is in water and the vehicle can float, it is placed on water surface, otherwise it is placed on the ground, even if the ground is under water. If roof surfaces support walking, units will be placed on roofs if such position is given.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetVehiclePosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehicleposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the AI rule of Radar usage (Emission Control). Automatic means Radar switched on only when in Combat. The command doesn't affect player-controlled vehicles.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleRadar(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehicleradar(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets that the vehicle will be able to receive targets acquired by someone else via datalink from the Side center.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleReceiveRemoteTargets(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehiclereceiveremotetargets(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets that the vehicle will share its own position via datalink to the Side center.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleReportOwnPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehiclereportownposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets that the vehicle will share targets that were acquired by its own sensors via datalink to the Side center.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleReportRemoteTargets(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehiclereportremotetargets(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the "heat" state of different vehicle parts for Thermal Imaging detection. This allows simulation of heated up parts of a vehicle without it actually having to utilize them - on a 0..1 range - 0 being cold, 1 being hot. This command does not work on infantry weapons.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleTiPars(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehicletipars(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets string representation of an object to a custom string. When a vehicle is created and named in the editor, the name becomes both the variable containing the vehicle object and the string representation of the vehicle object. In scripts an extra step is needed to achieve the same effect - see Example 1. This does not work with Simple Objects.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVehicleVarName(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvehiclevarname(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets velocity vector of an object in m/s. ⚠Since Arma 3 v2.06 each velocity component is limited to the range +-5000 m/s.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVelocity(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvelocity(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the velocity (speed vector) of the given vehicle relative to its model. ⚠Since Arma 3 v2.06 each velocity component is limited to the range +-5000 m/s.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVelocityModelSpace(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvelocitymodelspace(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        ///   Interpolates and applies PositionASL, velocity, vectorDir and vectorUp to the given object based on the interval value. When interval is 0 the "fromXXX" values are used for the beginning of the interpolation. When interval is 1, the "toXXX" values are used for the end of interpolation. When interval value is in between, interpolated values are used (see diagram below). The interpolation is linear and along straight line between "from" and "to" positions. If curve is needed, then it should be constructed from multiple straight sections or by dynamically changing value of position params during the interpolation cycle, similar to Quadratic Curve animation (see Example 3). The velocity param does not do much in SP, but in MP, provided the velocity component is set correctly, it helps the engine to figure out what the next position of the moving object should be on other clients. The actual approximate interpolation formula for this command is: _vecCurrent = _vecFrom vectorAdd (_vecTo vectorDiff _vecFrom vectorMultiply _interval); For continuous movement this command should be executed each frame while changing the interval value. For example to apply interpolation for 10 seconds one could use the following command to translate 10 seconds into 0..1 interval: t1 = time; t2 = time + 10; Later inside some on frame event... _interval = linearConversion [t1, t2, time, 0, 1];
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVelocityTransformation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvelocitytransformation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set rendering distance. Setting view distance to >= 0 resets the value to the client's options (set in Options → Video → General → Visibility → Overall). In previous versions, client's max view distance was limited by the server's view distance. ⚠View distance also defines the maximum distance between a unit and any other unit they can know about. Higher view distance will involve more AI simulation cycles for every unit, which causes low performance. See Arma 3: Performance Optimisation. Game min. scripted min. UI default max. UI max. scripted Arma 3 200 500 1600 12000 40000 Arma 2: Operation Arrowhead 200 500 2500 10000 15000 Arma 2 200 500 3000 10000 15000 Armed Assault 200 500 1200 10000 15000 Operation Flashpoint 500 500 900 5000 5000
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetViewDistance(GameValue rightInstance)
        {
            return new GameValue(setviewdistance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets whether or not the object is visible even if the tree is collapsed. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetVisibleIfTreeCollapsed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setvisibleiftreecollapsed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Tell the helicopter engine RPMs to reach the given value within a period of time. The simulation will try to reach the RPMs, but it does not guarantee it will reach the precise value! engine index 0: engine #1 engine index 1: engine #2 engine index 2: engine #3 engine index -1: all engines For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWantedRPMRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwantedrpmrtd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the waves value smoothly during the given time (in seconds). A time of zero means there will be an immediate change. NOTE: This command will have no effect (even though the value of waves changes) unless Manual Override option is selected in the editor in the Intel, which is normally off.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaves(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaves(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switches the unit behaviour when the waypoint becomes active. Possible values are: "UNCHANGED" "CARELESS" "SAFE" "AWARE" "COMBAT" "STEALTH" See the AIBehaviour page for details of the effect of this command on AI units.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointBehaviour(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointbehaviour(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes a group's combat mode when the waypoint becomes active.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointCombatMode(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointcombatmode(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// The completion radius allows units to call the waypoint completed once they are inside of the given circle. If the given radius is less than unit’s or vehicle’s configured 'precision' then the latter is used. For example tank precision is 10m, if the given radius is 5m, the final radius will be 10m. For units in player’s group there is an additional multiplier x5 to the configured precision. Units that are fleeing and are not in player's Group will ignore the completion radius and would not be able to complete by proximity until they stop fleeing.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointCompletionRadius(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointcompletionradius(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the description shown in the HUD while the waypoint is active.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointDescription(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointdescription(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces the behavior of waypoint, disables AUTOCOMBAT.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointForceBehaviour(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointforcebehaviour(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switches the group formation when the waypoint becomes active. Possible values are:  "NO CHANGE" "COLUMN" "STAG COLUMN" "WEDGE" "ECH LEFT" "ECH RIGHT" "VEE" "LINE" "FILE" "DIAMOND"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointFormation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointformation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// For waypoints attached to a house, this defines the target buildingPos index.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointHousePosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointhouseposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assigns loiter altitude to the provided waypoint.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointLoiterAltitude(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointloiteraltitude(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assignes loiter radius to waypoint
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointLoiterRadius(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointloiterradius(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the waypoint loiter type.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointLoiterType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointloitertype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the waypoint name.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointName(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointname(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attempts to move given waypoint to a random position inside a circle with the given center and radius.  The waypoint will be placed similar to "NONE" attribute in setVehiclePosition, even if the radius is 0, which means it could still be off center. In order to force waypoint to the exact position, similar to "CAN_COLLIDE" attribute, use a negative radius (see Example 2).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attaches a script to a scripted waypoint. In early versions of Arma, command consisted of a script name and additional script arguments and the script had to use SQS Syntax. The script receives the following arguments in _this variable: [group, position, target] + [the optional passed arguments]. The optional arguments are appended to the end of the arguments array. In Arma 3, command argument can be a reference to .sqf script (it will have to explicitly end with .sqf) or a reference to .sqs script.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointScript(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointscript(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switches the group speed mode when the waypoint becomes active. Possible values are: "UNCHANGED" "LIMITED" "NORMAL" "FULL"
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointSpeed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointspeed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// The waypoint is done only when the condition is fulfilled. When the waypoint is done, the statement expression is executed. Within the Condition & Statement code string: this refers to the group leader thisList refers to the group's units ⚠The Condition code is evaluated on the group owner's machine. When condition returns true, for some strange reason, the condition is evaluated one more time. The OnActivation code is executed globally, a.k.a on every client! See Waypoints.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointStatements(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointstatements(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines the time between condition satisfaction and waypoint finish (randomly from min to max, with an average value mid).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointTimeout(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointtimeout(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the waypoint type of given waypoint.  More details at Waypoints.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointType(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointtype(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the visibility of the given waypoint in 3D HUD view (for map visibility see showWaypoint).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWaypointVisible(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwaypointvisible(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets reloading phase on the given weapon's current ammo round. ⚠This command does not change a weapon's (e.g soldier's rifle) magazine reloading time but changes the ammo reloading state before the next round is shot.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetWeaponReloadingTime(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setweaponreloadingtime(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets zeroing of given weapon and muzzle for given unit or vehicle.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SetWeaponZeroing(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setweaponzeroing(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set current or permanent wind vector. ⚠The effect is global only if it is executed on the server. Wind set locally will sync back to server value in a while.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWind(GameValue rightInstance)
        {
            return new GameValue(setwind(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the wind direction smoothly.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWindDir(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwinddir(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set max. wind overall wind changes in time. A time of zero means there will be an immediate change. A wind level of zero is minimal changes and a wind level of one means that wind can change rapidly.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWindForce(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwindforce(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Changes the wind strength smoothly during the given time (in seconds). A time of zero means there will be an immediate change.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWindStr(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwindstr(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Set effectivity of wings. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWingForceScaleRTD(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwingforcescalertd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets waypoint position  This command is identical to setWaypointPosition [pos, -1] (see command description for more info)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SetWPPos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(setwppos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggle the drawing of 3D icons. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Show3DIcons(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(show3dicons(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows/hides the whole chat window.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowChat(GameValue rightInstance)
        {
            return new GameValue(showchat(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces drawing of cinema borders when using custom camera camCreate. This is normally used in cutscenes to indicate player has no control.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowCinemaBorder(GameValue rightInstance)
        {
            return new GameValue(showcinemaborder(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Create the commanding menu described by the given config class or menu name. When the name is empty, the current menu is hidden. If commanding menu has "expression" set up, the expression will receive the following arguments when user activated the menu item: Local variable  _target: Object - Target under the cursor. This works in both 3D and 2D (when cursor is over the unit icon on the map). Local variable _pos: Array - Cursor position. Local variable _is3D: Boolean - false if cursor is over the map, otherwise true.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowCommandingMenu(GameValue rightInstance)
        {
            return new GameValue(showcommandingmenu(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows or hides the compass on the map screen, if enabled for the mission and you possess the item. (default true)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowCompass(GameValue rightInstance)
        {
            return new GameValue(showcompass(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Hides or shows compass in curator interface.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowCuratorCompass(GameValue rightInstance)
        {
            return new GameValue(showcuratorcompass(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows or hides the GPS receiver on the map screen, if enabled for the mission and you possess the item. (default false). This command does nothing in Arma 3. Use the command openGPS that is available since v2.04.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowGps(GameValue rightInstance)
        {
            return new GameValue(showgps(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable / disable showing of HUD. Defines visibility of weapon crosshair and any informational tags that appear when pointing the weapon at an object as well as availability of the default action menu. Unfortunately, it also hides icons drawn with drawIcon3D. Since Arma 3 v1.50 there is a Description.ext's showHUD[] array param that is identical in format to the extended showHUD command. When present, it will disable showHUD command entirely, allowing mission makers to permanently alter visibility of some HUD elements. Since Arma 3 v2.04 it is possible to force drawing of drawIcon3D icons when HUD is hidden. The icons will also show when custom camera is created and the view is switched to it via switchCamera or cameraEffect provided cameraEffectEnableHUD is enabled. For more information see drawIcon3D.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowHUD(GameValue rightInstance)
        {
            return new GameValue(showhud(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Show/hide map legend.  Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowLegend(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(showlegend(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable Map (default true)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowMap(GameValue rightInstance)
        {
            return new GameValue(showmap(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the player has the artillery computer currently open.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownArtilleryComputer()
        {
            return new GameValue(shownartillerycomputer());
        }

        /// <summary>
        /// Returns true if chat window is enabled. Chat window can be disabled with showChat command.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownChat()
        {
            return new GameValue(shownchat());
        }

        /// <summary>
        /// Checks if client has Compass enabled in description.ext (showCompass param) or force enabled with showCompass command.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownCompass()
        {
            return new GameValue(showncompass());
        }

        /// <summary>
        /// Returns true if compass is shown.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownCuratorCompass()
        {
            return new GameValue(showncuratorcompass());
        }

        /// <summary>
        /// Show the add editor object dialog,type is editor object type,class is,class definition to automatically select,side filters by a certain,side,pos is position to create the object.   Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue ShowNewEditorObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(showneweditorobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// There is currently no text in this page
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownGps()
        {
            return new GameValue(showngps());
        }

        /// <summary>
        /// Returns array of Booleans corresponding to the visibility of various HUD elements (see extended showHUD).
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue ShownHUD()
        {
            return new GameValue(shownhud());
        }

        /// <summary>
        /// Checks if client has Map enabled in description.ext (showMap param) or force enabled with showMap command.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownMap()
        {
            return new GameValue(shownmap());
        }

        /// <summary>
        /// Checks if client has Notepad enabled.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownPad()
        {
            return new GameValue(shownpad());
        }

        /// <summary>
        /// Check if player has Radio enabled. This command exists in Arma 3 but doesn't do much
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownRadio()
        {
            return new GameValue(shownradio());
        }

        /// <summary>
        /// Returns the state of the score table set with showScoretable command.  ⚠Since Arma 3 v1.64, the previous functionality of this command (score table visibility check) is moved to visibleScoretable command. Please update your scripts and sorry for any inconvinience.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue ShownScoretable()
        {
            return new GameValue(shownscoretable());
        }

        /// <summary>
        /// A getter for showSubtitles.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownSubtitles()
        {
            return new GameValue(shownsubtitles());
        }

        /// <summary>
        /// Returns true if video feed transmitted from UAV is shown. A getter for showUAVFeed.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownUAVFeed()
        {
            return new GameValue(shownuavfeed());
        }

        /// <summary>
        /// Check if player has ID card enabled. Obsolete command.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownWarrant()
        {
            return new GameValue(shownwarrant());
        }

        /// <summary>
        /// Checks if client has Watch enabled in description.ext (showWatch param) or force enabled with showWatch command.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue ShownWatch()
        {
            return new GameValue(shownwatch());
        }

        /// <summary>
        /// Shows or hides the notebook on the map screen, if enabled for the mission. (default true). It is no longer relevant to Arma 2.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowPad(GameValue rightInstance)
        {
            return new GameValue(showpad(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows or hides the radio on the map screen, if enabled for the mission and you possess the item. (default true). This command does nothing in Arma 3.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowRadio(GameValue rightInstance)
        {
            return new GameValue(showradio(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Forces the score table to be shown, hidden or reset to default functionality. Forcing score table will make it show even in SP. When score table is forced opened it cannot be  closed manually, when it is force closed, it cannot be opened manually.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowScoretable(GameValue rightInstance)
        {
            return new GameValue(showscoretable(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enables / disables showing of subtitles in a chat. Only scripted/engine chatter is affected, player manual chat is unaffected. Returns the previous state.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue ShowSubtitles(GameValue rightInstance)
        {
            return new GameValue(showsubtitles(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows/hides video feed transmitted from UAV in its custom info panel.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowUAVFeed(GameValue rightInstance)
        {
            return new GameValue(showuavfeed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable ID card. ⚠Obsolete command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowWarrant(GameValue rightInstance)
        {
            return new GameValue(showwarrant(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows or hides the watch on the map screen, if enabled for the mission and you possess the item. (default true)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowWatch(GameValue rightInstance)
        {
            return new GameValue(showwatch(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Defines how waypoints are shown to the player in map view. For 3D HUD visibility see setWaypointVisible.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowWaypoint(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(showwaypoint(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows/Hides task HUD markers and waypoints that will fade out in time. Dependable on difficulty settings.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue ShowWaypoints(GameValue rightInstance)
        {
            return new GameValue(showwaypoints(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the side of a unit, vehicle, object or location. side of a renegade soldier is sideEnemy side of an empty vehicle is civilian side of a crewed vehicle is, if present, commander's > gunner's > driver's or > cargo's side, in this order side of a captive or dead unit is civilian. Use side group _unit to get the underlying side (see Example 2) you can use playerSide to know the real player's side Converting a side to string will not always return the side command text: e.g str resistance; // returns "GUER". See Side page to see the return value of all side commands.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue side</returns>
        public static GameValue Side(GameValue rightInstance)
        {
            return new GameValue(side(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns side of ambient life, for example ambient life placed in Eden Editor.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue SideAmbientLife()
        {
            return new GameValue(sideambientlife());
        }

        /// <summary>
        /// Types text to the side radio channel by the specified unit.  ⚠The unit must have an assigned radio item (such as "ItemRadio") to see or transmit the messages. A radio item must have the property simulation = "ItemRadio";  in its CfgWeapons config.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SideChat(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sidechat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns empty side, for example static buildings in Eden Editor.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue SideEmpty()
        {
            return new GameValue(sideempty());
        }

        /// <summary>
        /// The enemy side which is used for renegades. Units of this side are hostile to everyone. To join sideEnemy, you can attack members of your own side or use addRating. When below a rating of -2000 units switch automatically to this side.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue SideEnemy()
        {
            return new GameValue(sideenemy());
        }

        /// <summary>
        /// The Friendly side - friendly to all, see Side Relations.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue SideFriendly()
        {
            return new GameValue(sidefriendly());
        }

        /// <summary>
        /// The Logic side. Side of Game Logics and Modules.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue SideLogic()
        {
            return new GameValue(sidelogic());
        }

        /// <summary>
        /// Sends the audio message to the side radio channel. The message is defined in CfgRadio in the description.ext file or config radio protocol. The transmission will play only on the PC where command was executed. If you need the transmission to play on all computers, you have to execute it globally (see remoteExec). ⚠The unit must have an assigned radio item (such as "ItemRadio") to see or transmit the messages. A radio item must have the property simulation = "ItemRadio"; in its CfgWeapons config. When transmitting unit gets killed, transmission will be interrupted. However when receiving unit gets killed, the transmission continues to play.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SideRadio(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sideradio(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// The unknown side. Used when the side of a unit is unknown, e.g. for spotted targets with insufficient information.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue SideUnknown()
        {
            return new GameValue(sideunknown());
        }

        /// <summary>
        /// Return all simple tasks assigned to given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SimpleTasks(GameValue rightInstance)
        {
            return new GameValue(simpletasks(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if the entity has enabled simulation.  ⚠The entity could be local or remote but the result returned by this command will be for the entity simulation set up locally on the client that executed the command. See enableSimulation for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SimulationEnabled(GameValue rightInstance)
        {
            return new GameValue(simulationenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns density of clouds at given position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue SimulCloudDensity(GameValue rightInstance)
        {
            return new GameValue(simulclouddensity(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns clouds occlusion between two given points.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue SimulCloudOcclusion(GameValue rightInstance)
        {
            return new GameValue(simulcloudocclusion(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns if given position is in clouds.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SimulInClouds(GameValue rightInstance)
        {
            return new GameValue(simulinclouds(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Synchronizes Simul Weather with Arma weather, generates all keyframes.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue SimulWeatherSync()
        {
            return new GameValue(simulweathersync());
        }

        /// <summary>
        /// Sine of x.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Sin(GameValue rightInstance)
        {
            return new GameValue(sin(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a location's size.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Size(GameValue rightInstance)
        {
            return new GameValue(size(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the diameter of bounding sphere of the object of given classname in meters. If you need to estimate the size of the object more precisely, use boundingBox or boundingBoxReal. ⚠At least one object of the given classname has to be present in the current mission otherwise zero will be returned.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue SizeOf(GameValue rightInstance)
        {
            return new GameValue(sizeOf(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current skill of a unit, in range between 0 to 1, 1 being the highest level of skill.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Skill(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(skill(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns final, recalculated sub skill value of given unit. (with regard to AI Level coefficient (Difficulty settings)).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue SkillFinal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(skillfinal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Jumps the specified number of hours forward or backward.The time of day and tides are adjusted, but no changes are made to any units. If present, the lower level of clouds instantly jump to the position they would be in if time had passed normally.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SkipTime(GameValue rightInstance)
        {
            return new GameValue(skiptime(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Suspends code execution for given time in seconds. The sleep precision is given by a framerate, the delay given is the minimal delay expected. Must be called inside of a context which is interruptible, i.e. a script executed by execVM or spawn. this command will suspend the code for at least the given amount of time, and can be way more if the script scheduler is busy. this command will suspend the script as the game gets paused in single player (and will resume with it). To avoid this, use uiSleep.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Sleep(GameValue rightInstance)
        {
            return new GameValue(sleep(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current thumb position of CT_SLIDER or CT_XSLIDER with given idc of topmost user dialog.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue SliderPosition(GameValue rightInstance)
        {
            return new GameValue(sliderposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns limits of CT_SLIDER or CT_XSLIDER.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SliderRange(GameValue rightInstance)
        {
            return new GameValue(sliderrange(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets current thumb position of CT_SLIDER or CT_XSLIDER.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SliderSetPosition(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(slidersetposition(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets limits of CT_SLIDER or CT_XSLIDER.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SliderSetRange(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(slidersetrange(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets slider line step and page step delta amount as well as optional step amount of CT_SLIDER or CT_XSLIDER with given idc of topmost user dialog.  Click to arrow - move by line Click to scale outside thumb - move by page. CT_XSLIDER does not use `page` param, it acts as scrollbar when clicked on the bar. It also can only be horizontal.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SliderSetSpeed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(slidersetspeed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns slider step value for line and page movement of CT_SLIDER or CT_XSLIDER.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SliderSpeed(GameValue rightInstance)
        {
            return new GameValue(sliderspeed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if Sling Load Assistant is open.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue SlingLoadAssistantShown()
        {
            return new GameValue(slingloadassistantshown());
        }

        /// <summary>
        /// Get array with all magazines of the given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SoldierMagazines(GameValue rightInstance)
        {
            return new GameValue(soldiermagazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if unit has some ammo.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SomeAmmo(GameValue rightInstance)
        {
            return new GameValue(someammo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attempts to sort given array either in ascending (true) or descending (false) order. ⚠This will modify the original array!
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Sort(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(sort(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current sound volume (set by fadeSound).
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SoundVolume()
        {
            return new GameValue(soundvolume());
        }

        /// <summary>
        /// Adds given set of compiled instructions to the scheduler. Exactly when the code will be executed is unknown, it depends on how busy is the engine and how filled up is the scheduler. Therefore spawn does not wait for the supplied code to finish, instead, spawn returns a Script handle to the scheduler task. scriptDone command can be used to check the code completion. Additional arguments are passed to the code in local variable _this. Since 1.56 the script handle also exists inside the code in _thisScript variable. To see what spawned scripts are currently in the scheduler, use diag_activeSQFScripts command. ⚠When multiple Code is spawned in an order, there is no guarantee that the spawned Code will execute in the same order (see Example 2). If the order is important, use BIS_fnc_spawnOrdered.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue script</returns>
        public static GameValue Spawn(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(spawn(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the speaker class name of a unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Speaker(GameValue rightInstance)
        {
            return new GameValue(speaker(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current speech volume (set by fadeSpeech)
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SpeechVolume()
        {
            return new GameValue(speechvolume());
        }

        /// <summary>
        /// Object speed (in km/h). Returns relative speed of given object along Y axis. An equivalent to: 3.6 * (velocityModelSpace _obj select 1)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue Speed(GameValue rightInstance)
        {
            return new GameValue(speed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns speed mode of the group, which can be any of the following:  "LIMITED" "NORMAL" "FULL"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue SpeedMode(GameValue rightInstance)
        {
            return new GameValue(speedmode(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Splits the provided ANSI string into an array of tokens according to given delimiters. For Unicode support, see forceUnicode.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SplitString(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(splitstring(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns square root of x.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Sqrt(GameValue rightInstance)
        {
            return new GameValue(sqrt(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns data about squad of given unit loaded from squad.xml as well as about unit itself. All items in returned array are String. Since Arma 2.05.147777 return array is extended to contain unique squad ID as well as Arma 3 units ID
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SquadParams(GameValue rightInstance)
        {
            return new GameValue(squadparams(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the stance of the given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Stance(GameValue rightInstance)
        {
            return new GameValue(stance(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows loading screen with the given text, using the given resource. While loading screen is shown, simulation and scene drawing is disabled, user control is disabled, mouse cursor is hidden, scripts run at full speed (50ms per frame instead of 3ms per frame for Scheduled Scripts). By default, startLoadingScreen will use "RscDisplayNotFreeze" resource. A custom resource can be defined in Description.ext, and a full black background will be used by default - the following controls are supported by the engine: idc = 101 - text (type = 0) or picture (type = 48). The text will be set to the value provided by the command argument. idc = 103 - progress (type = 8) or animated texture (type = 45). This control indicates global hardcoded mission loading progress and is useless after the mission is loaded. idc = 104 - progress (type = 8). This control's progress is initially set to 0 and can be manipulated with progressLoadingScreen command. Resource can be defined in Description.ext; it must NOT be defined as RscTitles! See config example // basic defines - pre "import" keyword in v2.02 class RscText { 	type = 0; 	idc = -1; 	x = 0; 	y = 0; 	h = 0.037; 	w = 0.3; 	style = 0x100; 	font = Zeppelin32; 	SizeEx = 0.03921; 	colorText[] = { 1, 1, 1, 1 }; 	colorBackground[] = { 0, 0, 0, 0 }; 	linespacing = 1; }; class RscPicture { 	access = 0; 	type = 0; 	idc = -1; 	style = 48; 	colorBackground[] = { 0, 0, 0, 0 }; 	colorText[] = { 1, 1, 1, 1 }; 	font = "TahomaB"; 	sizeEx = 0; 	lineSpacing = 0; 	text = ""; }; class RscLoadingText : RscText { 	style = 2; 	x = 0.323532; 	y = 0.666672; 	w = 0.352944; 	h = 0.039216; 	sizeEx = 0.03921; 	colorText[] = { 0.543, 0.5742, 0.4102, 1.0 }; }; class RscProgress { 	x = 0.344; 	y = 0.619; 	w = 0.313726; 	h = 0.0261438; 	texture = "\ca\ui\data\loadscreen_progressbar_ca.paa"; 	colorFrame[] = { 0, 0, 0, 0 }; 	colorBar[] = { 1, 1, 1, 1 }; }; class RscProgressNotFreeze { 	idc = -1; 	type = 45; 	style = 0; 	x = 0.022059; 	y = 0.911772; 	w = 0.029412; 	h = 0.039216; 	texture = "#(argb,8,8,3)color(0,0,0,0)"; }; // end of basic defines class WIKI_loadingScreen {  	idd = -1; 	duration = 10e10; 	fadein = 0; 	fadeout = 0; 	name = "loading screen"; 	class controlsBackground 	{ 		class blueBackground : RscText // covers the black screen 		{ 			x = safezoneXAbs; 			y = safezoneY; 			w = safezoneWAbs; 			h = safezoneH; 			text = ""; 			colorText[] = { 0, 0, 0, 0 }; 			colorBackground[] = { 0, 0, 1, 1 }; 		}; 		class nicePic : RscPicture 		{ 			style = 48 + 0x800; // ST_PICTURE + ST_KEEP_ASPECT_RATIO 			x = safezoneX + safezoneW/2 - 0.25; 			y = safezoneY + safezoneH/2 - 0.2; 			w = 0.5; 			h = 0.4; 			text = "imgicePic.paa"; 		}; 	}; 	class controls 	{ 		class Title1 : RscLoadingText 		{ 			text = "$STR_LOADING"; // "Loading" text in the middle of the screen 		}; 		class CA_Progress : RscProgress // progress bar, has to have idc 104 		{ 			idc = 104; 			type = 8; // CT_PROGRESS 			style = 0; // ST_SINGLE 			texture = "\ca\ui\data\loadscreen_progressbar_ca.paa"; 		}; 		class CA_Progress2 : RscProgressNotFreeze // progress bar that will go reverse 		{ 			idc = 103; 		}; 		class Name2: RscText // the text on the top-left 		{ 			idc = 101; 			x = 0.05; 			y = 0.029412; 			w = 0.9; 			h = 0.04902; 			text = ""; 			sizeEx = 0.05; 			colorText[] = { 0.543, 0.5742, 0.4102, 1.0 }; 		}; 	}; }; ⚠ The loading screen does not end by itself and absolutely needs a call to endLoadingScreen command Game simulation is disabled during Loading Screen operation (at least in single player): do not use the sleep command between startLoadingScreen and endLoadingScreen as it may freeze the game - use uiSleep instead waitUntil can be used to wait for variable initialisation or script loading Use BIS_fnc_startLoadingScreen to prevent potential usage conflicts.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue StartLoadingScreen(GameValue rightInstance)
        {
            return new GameValue(startloadingscreen(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Optional step value. A countdown can be made with a negative value. If not set, the default step is 1.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue for</returns>
        public static GameValue Step(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(step(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Stop an AI unit from turning or moving, preventing it to follow a watched object or engage an enemy properly - although if properly aligned, the unit -will- shoot the enemy. It may still change the stance if deemed appropriate (e.g. under fire). Use disableAI to disable specific AI capabilities.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Stop(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(stop(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Instant engines stop.  For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue StopEngineRTD(GameValue rightInstance)
        {
            return new GameValue(stopenginertd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if unit is stopped by stop command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Stopped(GameValue rightInstance)
        {
            return new GameValue(stopped(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts any value into a string, depending on its type. If an Object has a vehicleVarName, it is returned (see Example 4).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Str(GameValue rightInstance)
        {
            return new GameValue(str(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Time sunOrMoon 12:00 1 (...) 1 18:39 0.911201 18:42 0.576303 18:45 0.240862 18:48 0 (...) 0 06:00 0.0695308 06:03 0.739519 06:09 1 (...) 1 Returns the moon to sun transition state in range 0..1. The return value is either 0 or 1 most of the time, the in-between values only returned during a few minutes in the morning and in the evening, depending on the date, and could be similar to shown here: Sunrise in Arma 3 VR Sunset in Arma 3 VR
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SunOrMoon()
        {
            return new GameValue(sunormoon());
        }

        /// <summary>
        /// Creates a list of supported operators and type. Each field of array has the format: "x:name" Where x can be: 't' - type 'n' - nullar operator 'u' - unary operator 'b' - binary operator. 'name' is the operator or type name (in case operator, type of input operands is included).  mask parameter can be an empty string, or one of field. In this case, function returns empty array, if operator is not included in the list. Limited wildcard support is available. Type x may be replaced with *, meaning all types. For the mask partial match may be used, like abc*, meaning any operators starting with 'abc' are reported, for example:  "" - list all types and commands "t:*" - list all types "*:<command>*" - list all entries for script <command> 2.00 "i:<command>" - extended information about script <command>, Array of Array of Strings in format:[type, lowerCaseName, camelCaseName, description, example, result, resultType, leftArgType, rightArgType, 2.02 syntax] "i:*" is not a wildcard but returns information about the multiplication operator instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SupportInfo(GameValue rightInstance)
        {
            return new GameValue(supportinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Force suppressive fire from the unit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SuppressFor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(suppressfor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether there is water at given position. In Arma 3, it also detects pond objects, but only if they are loaded in memory (normally only true if the objects are within the object view distance)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue SurfaceIsWater(GameValue rightInstance)
        {
            return new GameValue(surfaceiswater(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns terrain's surface normal on given position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SurfaceNormal(GameValue rightInstance)
        {
            return new GameValue(surfacenormal(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Same as surfaceType, but returns texture path to ground texture as string. The texture returned is of the ground, even if there is a road at that position. To get road texture use getRoadInfo command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue SurfaceTexture(GameValue rightInstance)
        {
            return new GameValue(surfacetexture(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns what surface type is at the given position. For surface texture see surfaceTexture command. The command returns surface type of the ground, even underneath objects such as buildings and roads Show surface types (Armed Assault) #GRASSSOUTH #GRASSGENERAL #SANDGENERAL Show surface types (Arma 2) #UTGRASS - for natural surfaces #UTCONCRETE - for urban surfaces Show surface types (Arma 3) BuildingRubble BuildingRubble_exp cardboard cardboard_exp carpet carpet_exp carpet_inside carpet_in_exp concrete concrete_exp concrete_hall concrete_hall_exp concrete_inside concrete_in_exp concrete_out Default dirtrunway floor floor_exp floor_inside floor_in_exp GdtAsphalt GdtBeach GdtCliff GdtConcrete GdtDead GdtDesert GdtDirt GdtField GdtForest GdtForestMalden GdtForestPine GdtGrassDry GdtGrassGreen GdtGrassLong GdtGrassShort GdtGrassTall GdtGrassWild GdtKLCobblestone GdtKLDirt GdtKlField GdtKLForestCon GdtKLForestDec GdtKLGrass1 GdtKLGrass2 GdtKlSoil GdtKlStubble GdtKlTarmac GdtKlWeatheredTarmac GdtMarsh GdtMud GdtRedDirt GdtRock GdtRubble GdtSeabed GdtSeabedExp GdtSoil GdtStony GdtStonyThistle GdtStratisBeach GdtStratisConcrete GdtStratisDirt GdtStratisDryGrass GdtStratisForestPine GdtStratisGreenGrass GdtStratisRocky GdtStratisSeabed GdtStratisSeabedCluttered GdtStratisThistles GdtThorn GdtVolcano GdtVolcanoBeach GdtVRsurface01 GdtWeed GdtWildField grid grid_exp lino lino_exp lino_in_exp mat_in_exp metalPlate metalPlatePressed_exp metalPlate_exp metalPlate_in_exp mud mud_exp parquet planks planks_exp planks_inside planks_in_exp road road_exp roof_tiles_exp rubble rubble_exp sand sand_exp softwood_in_exp steel steel_exp stones stones_exp straw_exp SurfIntConcrete SurfIntMetal SurfIntTiles SurfIntWood surfint_concrete surfint_metal surfint_tiles surfint_wood SurfMetal SurfRoadConcrete SurfRoadConcrete_exp SurfRoadDirt SurfRoadDirt_Enoch SurfRoadDirt_exp SurfRoadTarmac SurfRoadTarmac1_Enoch SurfRoadTarmac2_Enoch SurfRoadTarmac3_Enoch SurfRoadTarmac_exp SurfRoofTiles SurfRoofTin SurfTrailDirt_Enoch SurfTrailDirt_exp SurfWater SurfWood surf_metal surf_roadconcrete surf_roaddirt surf_roadtarmac surf_rooftiles surf_rooftin surf_wood TEST_SurfNormal tiling trash trash_exp Water wavyMetal wavyMetal_exp woodenFloor
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue SurfaceType(GameValue rightInstance)
        {
            return new GameValue(surfacetype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the target depth level for swimming soldier. Depth should be a negative number.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SwimInDepth(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(swimindepth(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if the given parameter matches any case. If so, the code block of that case will be executed. After that the switch ends so no further cases will be checked. If a case has no code block the code of the next case will automatically be executed, making it possible to formulate a logical "or" for cases which would otherwise contain the exact same code (see Example 2). The default block will be executed only if no case matches, no matter its position inside the code block. It is not a case, and will never be entered by fallthrough. String comparison is case-sensitive. Use toUpper, toLower, toLowerANSI or toUpperANSI to force all strings to the same case. if no default block is provided and no case is matched, the switch block returns the default value true, otherwise it returns what the valid case block returns.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue switch</returns>

        /// <summary>
        /// Returns a list of playable units available for switching to Command is relative to the client on which it is executed and will only show playable units for the same side as player's group + player himself In singleplayer where playable units from all sides will be accessible via this command Dead and player-controlled units are automatically removed from the resulting array In order to get all playable units regardless of their side, see the playableUnits command
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue SwitchableUnits()
        {
            return new GameValue(switchableunits());
        }

        /// <summary>
        /// When used on a person, the given action is started immediately (there is no transition). Use switchmove "" to switch back to the default movement if there is no transition back, otherwise the person may be stuck.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SwitchAction(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(switchaction(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switch camera to given vehicle / camera. Mode is one of: "INTERNAL": 1st person "GUNNER": optics / sights "EXTERNAL": 3rd person "GROUP": group "CARGO": same as "INTERNAL" If you switch to a unit in a vehicle, this command uses the correct turret. Control over the unit is not given to the player. Use selectPlayer or a combination of switchCamera and remoteControl to achieve this.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SwitchCamera(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(switchcamera(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// When used on a person,the given move is started immediately (without transition).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SwitchGesture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(switchgesture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Controls whether a lamp is lit or not. This command was originally designed to only work with CfgNonAIVehicles class "StreetLamp" only. Since Arma 3 v1.92 this command was extended to work with street lights and some prop lights, like portable construction light.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SwitchLight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(switchlight(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Immediately applies given animation to the unit. For a smooth transition from the current animation, use playMove. see Moves for respective games animations. This command first resets the unit's animation states (including aiming state, gesture state, etc.) then puts the unit in the first frame of the animation (therefore showing no transition). If an invalid animation is provided, the unit's animations will be reset but no new animation will be played (see Example 3). It is a good practice to always use playMoveNow after switchMove to make sure the animation plays correctly: _unit switchMove "myMove"; _unit playMoveNow "myMove";
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SwitchMove(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(switchmove(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the list of objects synchronized with the given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SynchronizedObjects(GameValue rightInstance)
        {
            return new GameValue(synchronizedobjects(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the list of triggers synchronized with a given waypoint.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SynchronizedTriggers(GameValue rightInstance)
        {
            return new GameValue(synchronizedtriggers(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the list of waypoints synchronized with a given trigger or waypoint.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue SynchronizedWaypoints(GameValue rightInstance)
        {
            return new GameValue(synchronizedwaypoints(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Add given objects to the unit's list of synchronized objects.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SynchronizeObjectsAdd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(synchronizeobjectsadd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes given objects from the unit's list of synchronized objects.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SynchronizeObjectsRemove(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(synchronizeobjectsremove(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Synchronizes the trigger with zero or more waypoints.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SynchronizeTrigger(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(synchronizetrigger(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Synchronizes the trigger or the waypoint with an array of waypoints.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SynchronizeWaypoint(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(synchronizewaypoint(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Types text to the system radio channel. The text will be visible only on the PC where command was executed. If you need the message to show on all computers, you have to execute it globally (see remoteExec).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue SystemChat(GameValue rightInstance)
        {
            return new GameValue(systemchat(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the currently selected system of units. 0: Metric 1: Mixed (ground vehicles use Metric / air vehicles use Imperial) 2: Imperial
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue SystemOfUnits()
        {
            return new GameValue(systemofunits());
        }

        /// <summary>
        /// Returns system time.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue SystemTime()
        {
            return new GameValue(systemtime());
        }

        /// <summary>
        /// Returns systemTime according to Universal Time Coordinated time scale.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue SystemTimeUTC()
        {
            return new GameValue(systemtimeutc());
        }

        /// <summary>
        /// Returns unit's knowledge about target.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TargetKnowledge(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(targetknowledge(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Retrieves list of given unit targets matching specified filter. If the filter is not specified, all targets are returned. If a unit is provided, the unit itself will be excluded from results. If a group is provided, its units will be excluded (even if renegades).
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Targets(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(targets(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Aggregate candidates.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TargetsAggregate(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(targetsaggregate(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns sorted array of targets, known to the enquirer (including own troops), where the accuracy coefficient reflects how close the result matches the query. This command could be CPU intensive.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TargetsQuery(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(targetsquery(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the task is flagged to be always visible or false if not.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue TaskAlwaysVisible(GameValue rightInstance)
        {
            return new GameValue(taskalwaysvisible(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the child tasks of the specified task.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TaskChildren(GameValue rightInstance)
        {
            return new GameValue(taskchildren(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return if task is completed. (state Succeeded, Failed or Canceled)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue TaskCompleted(GameValue rightInstance)
        {
            return new GameValue(taskcompleted(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns custom data attached to the local task or an empty array if there are no custom data attached.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TaskCustomData(GameValue rightInstance)
        {
            return new GameValue(taskcustomdata(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the sub-parts of the task description. The returned Array is in format [Task description, Task title, Task waypoint description].
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TaskDescription(GameValue rightInstance)
        {
            return new GameValue(taskdescription(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the position of the task (as specified by destination parameter in config).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TaskDestination(GameValue rightInstance)
        {
            return new GameValue(taskdestination(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows info about new, changed or failed task. The text can contain several lines.  is used to set a line return. It is recommended to use BIS_fnc_showNotification in order to maintain Arma 3's visual style.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TaskHint(GameValue rightInstance)
        {
            return new GameValue(taskhint(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns model space position for the task marker
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TaskMarkerOffset(GameValue rightInstance)
        {
            return new GameValue(taskmarkeroffset(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the name of the given task.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TaskName(GameValue rightInstance)
        {
            return new GameValue(taskname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A non-existing Task. To compare non-existent tasks use isNull or isEqualTo: taskNull == taskNull;			// false isNull taskNull;				// true taskNull isEqualTo taskNull;	// true
        /// </summary>
        /// <returns>GameValue task</returns>
        public static GameValue TaskNull()
        {
            return new GameValue(tasknull());
        }

        /// <summary>
        /// Returns the parent task of the specified task.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue task</returns>
        public static GameValue TaskParent(GameValue rightInstance)
        {
            return new GameValue(taskparent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Send a result of the task to the task sender.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TaskResult(GameValue rightInstance)
        {
            return new GameValue(taskresult(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current state of a task.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TaskState(GameValue rightInstance)
        {
            return new GameValue(taskstate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the type of the given task. A new task returns "Default" for the type.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TaskType(GameValue rightInstance)
        {
            return new GameValue(tasktype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return an agent for given person.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue team_member</returns>
        public static GameValue TeamMember(GameValue rightInstance)
        {
            return new GameValue(teammember(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A non-existent Team Member. To compare non-existent team members use isNull or isEqualTo: teamMemberNull == teamMemberNull;			// false isNull teamMemberNull;						// true teamMemberNull isEqualTo teamMemberNull;	// true
        /// </summary>
        /// <returns>GameValue team_member</returns>
        public static GameValue TeamMemberNull()
        {
            return new GameValue(teammembernull());
        }

        /// <summary>
        /// Return a name of given team.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TeamName(GameValue rightInstance)
        {
            return new GameValue(teamname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return a list of teams in the current mission.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Teams()
        {
            return new GameValue(teams());
        }

        /// <summary>
        /// Invoke the Team Switch dialog (force it even when conditions are not met). There has to be at least one playable unit for team switch to work, and for this command to work in MP, respawn type in description.ext should be 5 (SIDE).When player switches and leaves behind AI unit, you need to enable "TeamSwitch" AI on it _unit enableAI "TeamSwitch" so that the unit continues with waypoints.
        /// </summary>
        /// <returns>GameValue nothing</returns>
        public static GameValue TeamSwitch()
        {
            return new GameValue(teamswitch());
        }

        /// <summary>
        /// Check if Team Switch is currently enabled. Team Switch is enabled by default.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue TeamSwitchEnabled()
        {
            return new GameValue(teamswitchenabled());
        }

        /// <summary>
        /// Returns a type of given team.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TeamType(GameValue rightInstance)
        {
            return new GameValue(teamtype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Terminates (aborts) spawned or execVMed script. ⚠The given script will not terminate immediately upon terminate command execution, it will do so the next time the script is processed by the scheduler
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue Terminate(GameValue rightInstance)
        {
            return new GameValue(terminate(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks for intersection of terrain between two AGL positions. Returns true if intersects with terrain. For ASL variant see terrainIntersectASL.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue TerrainIntersect(GameValue rightInstance)
        {
            return new GameValue(terrainintersect(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks for intersection of terrain between two ASL positions. Returns true if intersects with terrain. For AGL variant, see terrainIntersect.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue TerrainIntersectASL(GameValue rightInstance)
        {
            return new GameValue(terrainintersectasl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks for intersection of terrain between two ASL positions. Same as terrainIntersectASL but returns the intersection ASL position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TerrainIntersectAtASL(GameValue rightInstance)
        {
            return new GameValue(terrainintersectatasl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Creates a structured text containing the given plain text if argument is String. Use setAttributes to set additional  attributes on the text. If the argument is location, returns location's text value (see Alt Syntax).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Text(GameValue rightInstance)
        {
            return new GameValue(text(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Dump argument value to debugging output.  ⚠This command is non-functional in the retail version
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TextLog(GameValue rightInstance)
        {
            return new GameValue(textlog(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Debugging output.  ⚠This command is non-functional in the retail version
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TextLogFormat(GameValue rightInstance)
        {
            return new GameValue(textlogformat(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Identical to tan
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar_nan</returns>
        public static GameValue Tg(GameValue rightInstance)
        {
            return new GameValue(tg(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the value set with setTimeMultiplier.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue TimeMultiplier()
        {
            return new GameValue(timemultiplier());
        }

        /// <summary>
        /// Displays text on screen. 🕖The following information is obsolete. Reason: cutText should be used instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TitleCut(GameValue rightInstance)
        {
            return new GameValue(titlecut(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Terminate the title effect and set duration of the fade out phase to the given time. Same as cutFadeOut but for the title layer.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TitleFadeOut(GameValue rightInstance)
        {
            return new GameValue(titlefadeout(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Shows object defined in global config in CfgTitles
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TitleObj(GameValue rightInstance)
        {
            return new GameValue(titleobj(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Displays a resource defined in RscTitles. Also see cutRsc, with these two commands you can show two different resources at once. Multiple layers and map overlays are possible with cutRsc which provides more options and handles layers better.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TitleRsc(GameValue rightInstance)
        {
            return new GameValue(titlersc(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Displays text across the screen. If used along with cutText two different texts (in different type styles) can be shown at once. The text can be displayed on multiple lines by using "" new line characters (see Example 3).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TitleText(GameValue rightInstance)
        {
            return new GameValue(titletext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Continue sequence of for construct. It sets the end value of the index variable.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue for</returns>
        public static GameValue To(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(to(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts the supplied String into an Array of Numbers. The numbers in the created array are the decimal Unicode representations of characters. Since v2.04 this command can also handle HashMaps. See alternative syntax.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue ToArray(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(toarray(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts a number into a string, keeping the specified number of decimals. If the desired number of decimals is higher than the actual number, nulls are added to create the desired decimal length. This command is almost identical in behaviour to JavaScript toFixed() The alternative syntax acts as keyword and switches engine's Number to String global conversion into desired format, from the moment it is applied until the end of script. To reset output back to default at any time, use toFixed -1 - see Example 5. Converted number is never presented in scientific notation unlike with other number to string commands. Also Arma's default string conversion limits numbers to 6 significant figures, whereas with this command it is possible to preserve some extra precision - see Example 6.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ToFixed(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tofixed(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts the supplied Unicode string to all lowercase characters. If the string doesn't have characters with codes > 255, use toLowerANSI.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ToLower(GameValue rightInstance)
        {
            return new GameValue(tolower(rightInstance._internalGameValue));
        }

        /// <summary>
        ///  ISO-8859-1 Converts the supplied string to all lower case characters fast (could be 3× faster than toLower). ANSI in this case refers to ISO-8859-1 code page. The command is primary designed to convert characters with  codes 0...127 however it will also convert other characters in 128...255 range as long as they are present in ISO-8859-1 codepage. For Unicode alternative see toLower.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ToLowerANSI(GameValue rightInstance)
        {
            return new GameValue(toloweransi(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts the supplied Array of Numbers into a String through Unicode characters representation conversion, or provided Code to compilable String.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ToString(GameValue rightInstance)
        {
            return new GameValue(tostring(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts the supplied Unicode string to all uppercase characters. If the string doesn't have characters with codes > 255, use toUpperANSI.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ToUpper(GameValue rightInstance)
        {
            return new GameValue(toupper(rightInstance._internalGameValue));
        }

        /// <summary>
        ///  ISO-8859-1Converts the supplied string to all upper case characters fast (could be 3x faster than toUpper). ANSI in this case refers to ISO-8859-1 code page. The command is primary designed to convert characters with  codes 0...127 however will also convert other characters in 128...255 range as long as they are present in ISO-8859-1 codepage. For Unicode alternative see toUpper.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue ToUpperANSI(GameValue rightInstance)
        {
            return new GameValue(toupperansi(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the trigger has been activated.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue TriggerActivated(GameValue rightInstance)
        {
            return new GameValue(triggeractivated(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns trigger activation in the form [by, type, repeating].  ⚠The trigger could be local or remote but the result returned by this command will be for the trigger activation set up locally on the client that executed the command. See createTrigger for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TriggerActivation(GameValue rightInstance)
        {
            return new GameValue(triggeractivation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Triggers a munition such as shells, bullets, missiles, rockets, mines and bombs (shotSubmunition/shotShell/shotBullet/shotMissile/shotRocket) as if it did hit. If ammo uses submunition, then creation of submunition will be triggered.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TriggerAmmo(GameValue rightInstance)
        {
            return new GameValue(triggerammo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns currently monitored trigger area. Since Arma 3 v1.60, the command returns 3rd dimension for the monitored area. If height is not set, the value for it would be -1. ⚠The trigger could be local or remote but the result returned by this command will be for the trigger area set up locally on the client that executed the command. See createTrigger for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TriggerArea(GameValue rightInstance)
        {
            return new GameValue(triggerarea(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns vehicle attached to the trigger (for example using triggerAttachVehicle). ⚠The trigger could be local or remote but the result returned by this command will be for the vehicle attached locally on the client that executed the command. See createTrigger for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue TriggerAttachedVehicle(GameValue rightInstance)
        {
            return new GameValue(triggerattachedvehicle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Assigns a static object to the trigger. The activation source is changed to "STATIC".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TriggerAttachObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(triggerattachobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Specifies the entity which will activate the selected trigger. If [] is given, the trigger is decoupled from the assigned vehicle (example 2). If the activation source is "VEHICLE", "GROUP", "LEADER" or "MEMBER", it is changed to "NONE". If [vehicle] is given, the trigger is coupled to the vehicle or its group. When the source is "GROUP", "LEADER" or "MEMBER", it is coupled to the group, otherwise it is coupled to the vehicle and the source is changed to "VEHICLE".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TriggerAttachVehicle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(triggerattachvehicle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Controls the ability of given unit to activate entities with disabled Arma 3: Dynamic Simulation. If false dynamically disabled entities will not be activated by this unit's presence. This command has the same effect as the Eden Editor attribute Wake-Up Dynamic Simulation.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TriggerDynamicSimulation(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(triggerdynamicsimulation(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns trigger condition check frequency in seconds.  ⚠The trigger could be local or remote but the result returned by this command will be for the trigger interval set up locally on the client that executed the command. See createTrigger for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue TriggerInterval(GameValue rightInstance)
        {
            return new GameValue(triggerinterval(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns trigger statements.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TriggerStatements(GameValue rightInstance)
        {
            return new GameValue(triggerstatements(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns trigger text.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TriggerText(GameValue rightInstance)
        {
            return new GameValue(triggertext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns trigger timeout in the form [min, mid, max, interruptable]. ⚠The trigger could be local or remote but the result returned by this command will be for the trigger timeout set up locally on the client that executed the command. See createTrigger for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TriggerTimeout(GameValue rightInstance)
        {
            return new GameValue(triggertimeout(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current timeout of the given trigger or -1 if countdown is not in progress.  ⚠The trigger could be local or remote but the result returned by this command will be for the current trigger timeout local to the client that executed the command. See createTrigger for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue TriggerTimeoutCurrent(GameValue rightInstance)
        {
            return new GameValue(triggertimeoutcurrent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the trigger type.  ⚠The trigger could be local or remote but the result returned by this command will be for the trigger type set up locally on the client that executed the command. See createTrigger for more info.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TriggerType(GameValue rightInstance)
        {
            return new GameValue(triggertype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Trims a string.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Trim(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(trim(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if a turret is local.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue TurretLocal(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(turretlocal(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns id of the turret's owner. Returns 0 on non-server and SP.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue TurretOwner(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(turretowner(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the unit in the vehicle turret. To find turret path of known unit, see unitTurret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue TurretUnit(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(turretunit(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds an item with given text to Tree View control. The position on Tree View where to add the item and the actual path to this item once added are different. If item is added to existing item, then parent item path is used. If no parent exists, empty array [] is used. See Tree View Path for more information.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue TvAdd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvadd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes all items from Tree View with given idc.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvClear(GameValue rightInstance)
        {
            return new GameValue(tvclear(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Collapses tree item pointed to by the path. IDC means id of parent Tree View.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvCollapse(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvcollapse(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Collapses all tree items for the given Tree View.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvCollapseAll(GameValue rightInstance)
        {
            return new GameValue(tvcollapseall(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns children count on given path. IDC means id of parent Tree View.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue TvCount(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvcount(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns path to currently selected item. IDC means id of parent Tree View.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TvCurSel(GameValue rightInstance)
        {
            return new GameValue(tvcursel(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns string data from item on given path. IDC means id of parent CT_TREE.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TvData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Removes an item with given Tree View Path from Tree View. ⚠The paths of other items on the same branch after delete operation are updated accordingly; therefore, when deleting multiple entries, start with the one with the highest index and proceed in reverse order.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvDelete(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvdelete(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Expands tree item pointed to by the path. IDC means id of parent Tree View.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvExpand(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvexpand(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Expands all tree items for the given Tree View.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvExpandAll(GameValue rightInstance)
        {
            return new GameValue(tvexpandall(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if given treeview item is selected.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue TvIsSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvisselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns name of picture from item pointed to by path. IDC means id of parent Tree View.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TvPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvpicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the right picture of a CT_TREE on given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TvPictureRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvpictureright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of paths to selected items.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue TvSelection(GameValue rightInstance)
        {
            return new GameValue(tvselection(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets text color on given Tree View Item
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets cursor to given item on given path. IDC means id of parent Tree View. To deselect all items use [-1] for the path param (available since Arma 3 v1.56)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetCurSel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetcursel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets string data to item on given path. IDC means id of parent Tree View.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetData(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetdata(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets picture to item selected by path. IDC means id of parent Tree View. Name is picture name. The picture is searched in the mission directory.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetPicture(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetpicture(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the colour of the picture (set via tvSetPicture) under the specified tree view path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetPictureColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetpicturecolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of left picture of a tree item defined by path when that item is disabled.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetPictureColorDisabled(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetpicturecolordisabled(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of the left picture of a tree item defined by path when item is selected
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetPictureColorSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetpicturecolorselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets right picture on the tree view item defined by path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetPictureRight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetpictureright(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets color of the right picture on the tree view item defined by path
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetPictureRightColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetpicturerightcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of the right picture of a tree item defined by path when item is disabled
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetPictureRightColorDisabled(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetpicturerightcolordisabled(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the color of the right picture of a tree item defined by path when item is selected
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetPictureRightColorSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetpicturerightcolorselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the select color of given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetSelectColor(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetselectcolor(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the selection state of given treeview item in multi-select control.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetSelected(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetselected(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets string text to item on given path. IDC means id of parent Tree View.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsettext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the tooltip text associated with the specified tree view path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetTooltip(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsettooltip(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets scalar data to item on given path. IDC means id of parent Tree View. If the given value is not integer, it will be converted to integer
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSetValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsetvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts all children of given path. Text of Tree View entries is used for sorting.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSort(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsort(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts all children, including trees deriving from given path. Text of Tree View entries is used for sorting.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSortAll(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsortall(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts all children of given path. Value of Tree View entries is used for sorting. tvSetValue can be used to set the value for a given path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSortByValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsortbyvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sorts all children, including trees deriving from given path.  Value of Tree View entries is used for sorting.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue TvSortByValueAll(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvsortbyvalueall(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns shown text in the item on given path. IDC means id of parent Tree View.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TvText(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvtext(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the tooltip text associated with the specified tree view path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TvTooltip(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvtooltip(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns numeric (Integer) value set for given tree view path.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue TvValue(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(tvvalue(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a string of a Location's class name or Task's name (same as taskName).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Type(GameValue rightInstance)
        {
            return new GameValue(type(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the Data Type of an expression.  The type is returned as on of the following all-uppercase strings: "ARRAY" "BOOL" "CODE" "CONFIG" "CONTROL" "DISPLAY" "GROUP" "OBJECT" "SCALAR" "SCRIPT" "SIDE" "STRING" "TEXT" 1.08 "LOCATION" 1.00 "TEAM_MEMBER" 1.00 "NAMESPACE" 1.00 "DIARY_RECORD" 1.00 "TASK" 2.02 "HASHMAP" They represent the available Data Types in Arma. For type comparison, use isEqualType command instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TypeName(GameValue rightInstance)
        {
            return new GameValue(typename(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the class name of a given object.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue TypeOf(GameValue rightInstance)
        {
            return new GameValue(typeOf(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with current operator of UAV and his vehicle role in UAV. If nobody is controlling the UAV, the command tries to find any person with connected terminal to this UAV, in which case the vehicle role is an empty string. If command cannot find anyone, output is [objNull, ""]. Since Arma 3 v1.96 this command returns both driver and gunner units if the UAV is controlled by 2 players. Here is the list of all expected outputs: [player1, "DRIVER"] - player1 is controlling the UAV and is the pilot [player2, "GUNNER"] - player2 is controlling the UAV and is the gunner [player1, "DRIVER", player2, "GUNNER"] - player1 is controlling the UAV and is the pilot, player2 is controlling UAV and is the gunner [player3, ""] - no one is controlling the UAV, player3 is connected to the UAV via terminal, but not controlling it yet [objNull, ""] - nobody is controlling or connected to the UAV This command works only for vehicles, to get a unit remote controlling a unit, see Example 3 on the remoteControl page.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue UAVControl(GameValue rightInstance)
        {
            return new GameValue(uavcontrol(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the global namespace attached to user interface.
        /// </summary>
        /// <returns>GameValue namespace</returns>
        public static GameValue UiNamespace()
        {
            return new GameValue(uinamespace());
        }

        /// <summary>
        /// Suspend execution of script for given UI time. uiSleep is a sleep method to delay script execution where script time/simulation time is stopped. uiSleep is basically using the system time (uiTime more specifically) and not simulation time. So in the cases where sleep would get stuck indefinitely, uiSleep can still be used to effectively delay script execution for example in pause or in a mission briefing or an editor or when simulation is paused in general.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UiSleep(GameValue rightInstance)
        {
            return new GameValue(uisleep(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unassign curator (will destroy both sides of connection).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UnassignCurator(GameValue rightInstance)
        {
            return new GameValue(unassigncurator(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unassigns existing item and tries to put it into inventory. If there is no space in inventory the item simply disappears. See also unlinkItem.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UnassignItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(unassignitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unassigns the unit (in the case of a vehicle its commander unit) from his team. This is equal to unit assignTeam "MAIN".
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UnassignTeam(GameValue rightInstance)
        {
            return new GameValue(unassignteam(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unassigns individual unit from a vehicle, usually previously assigned with assignAsXXX command, i.e removes assignedVehicleRole of the unit. If the unit is currently in that vehicle, the group leader will issue an order to disembark. See AI Group Vehicle Management for more information.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UnassignVehicle(GameValue rightInstance)
        {
            return new GameValue(unassignvehicle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether the object is fully underwater. This command works well with Arma 3 mini-submarines, which was most likely the primary design goal.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue Underwater(GameValue rightInstance)
        {
            return new GameValue(underwater(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns name of uniform.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Uniform(GameValue rightInstance)
        {
            return new GameValue(uniform(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a cargo container of a unit's uniform.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue UniformContainer(GameValue rightInstance)
        {
            return new GameValue(uniformcontainer(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with all items (of any kind, even weapons) from uniform.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue UniformItems(GameValue rightInstance)
        {
            return new GameValue(uniformitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with all magazines from uniform of the given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue UniformMagazines(GameValue rightInstance)
        {
            return new GameValue(uniformmagazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns hashmap of all items in units inventory as [classname, count] pairs. weaponItems, uniformItems, vestItems, backpackItems arguments use the following Number values: 0: do not return value 1: returns container only (weapon or container) 2: returns container and its content weapons/containers that are stored inside containers (e.g weapon in backpack) always return all contents if contents for the parent container are enabled.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue hashmap</returns>
        public static GameValue UniqueUnitItems(GameValue rightInstance)
        {
            return new GameValue(uniqueunititems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns list with addons the unit belongs to.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue UnitAddons(GameValue rightInstance)
        {
            return new GameValue(unitaddons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the position on the unit other units can aim at. Same as aimPos only returns position in PositionAGL format and has render scope alternative unitAimPositionVisual.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue UnitAimPosition(GameValue rightInstance)
        {
            return new GameValue(unitaimposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the position on the unit other units can aim at in render scope. See also aimPos, unitAimPosition.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue UnitAimPositionVisual(GameValue rightInstance)
        {
            return new GameValue(unitaimpositionvisual(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns unit's backpack
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue UnitBackpack(GameValue rightInstance)
        {
            return new GameValue(unitbackpack(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets individual unit's combat mode. For more information see setUnitCombatMode.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue UnitCombatMode(GameValue rightInstance)
        {
            return new GameValue(unitcombatmode(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns whether or not the given transport object is a drone (UAV, UGV), regardless of if it has a crew or if it is empty, corresponding to the isUAV transport parameter. 2.14 The command can be used to check if the provided unit is a UAV unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue UnitIsUAV(GameValue rightInstance)
        {
            return new GameValue(unitisuav(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the unit position rules. The return value is always "Auto" unless the unit has gotten a setUnitPos command. In that case the value is the last stance the unit was ordered to. Available modes are listed at setUnitPos.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue UnitPos(GameValue rightInstance)
        {
            return new GameValue(unitpos(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if the unit is ready. Unit is busy when it is given some command like move, until the command is finished.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue UnitReady(GameValue rightInstance)
        {
            return new GameValue(unitready(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns recoil coefficient of a soldier.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue UnitRecoilCoefficient(GameValue rightInstance)
        {
            return new GameValue(unitrecoilcoefficient(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array with all the units in the group or unit's group, or all units belonging to a certain side.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue any</returns>
        public static GameValue Units(GameValue rightInstance)
        {
            return new GameValue(units(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns units in group/array below given Above Terrain Level (ATL) altitude. an object's ATL altitude can be found with _altitude = (getPosATL _obj) select 2;.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue UnitsBelowHeight(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(unitsbelowheight(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the turret path the given vehicle's gunner is in. To get the turret's unit see turretUnit.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue UnitTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(unitturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unassign and delete existing item from its assigned slot. If item does not exist or is not in the assigned slot, command simply fails. See also unassignItem.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UnlinkItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(unlinkitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unlocks the given achievement. The achievements are listed in CfgAchievements, however none of the currently listed achievements is used in Arma 3, hence the command always returns false. ⚠This command is obsolete and was used in the experimental (unreleased) Arma 2 Xbox 360 version as stated here. To unlock a Steam Achievement for Arma 3, see setStatValue.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue UnlockAchievement(GameValue rightInstance)
        {
            return new GameValue(unlockachievement(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unregisters a task type from given agent. The task type is the name given in CfgTasks classes in name property. Also available from registeredTasks array.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue UnregisterTask(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(unregistertask(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Updates the icon to be shown in 2D editor for the specified editor,object. If maintain size is false,icon will not scale depending on the,scale of the map. If maintain size is a number,the icon will maintain,size if map scale is below that number. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UpdateDrawIcon(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(updatedrawicon(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sets the text and command for the menu item. index is index as returned from addMenuItem command. command is optional. Some Old Editor Command
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UpdateMenuItem(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(updatemenuitem(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Update the editor object tree. Some Old Editor Command
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UpdateObjectTree(GameValue rightInstance)
        {
            return new GameValue(updateobjecttree(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Toggle secondary obstruction test on road paths.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UseAIOperMapObstructionTest(GameValue rightInstance)
        {
            return new GameValue(useaiopermapobstructiontest(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Enable the new AI driving, used to test the old and new AI driving.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UseAISteeringComponent(GameValue rightInstance)
        {
            return new GameValue(useaisteeringcomponent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Switch between elapsed game time and audio time being used as animation timer. Used for audio/animation synchronization.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue UseAudioTimeForMoves(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(useaudiotimeformoves(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if user input is disabled
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue UserInputDisabled()
        {
            return new GameValue(userinputdisabled());
        }

        /// <summary>
        /// Returns all values stored in the given HashMap. The order of the returned Array corresponds to the order of the Array returned by the keys command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Values(GameValue rightInstance)
        {
            return new GameValue(values(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Adds two 3D vectors. Replaces BIS_fnc_vectorAdd.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorAdd(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectoradd(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Cosine of angle between two 3D vectors.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue VectorCos(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectorcos(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Cross product of two 3D vectors.  In layman's terms, if you have a polygon (surface) defined by 3 points, you can find a normal to it (just like terrain surfaceNormal). To invert direction of the normal, swap arguments around.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorCrossProduct(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectorcrossproduct(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Subtracts one 3D vector from another. (vector1 - vector2)
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorDiff(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectordiff(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns object direction vector in world space ([x,y,z]). ⚠The vector is not necessarily normalized. The magnitude of the vector will be the same as the object scale. A unit facing North would return [0,1,0] A unit facing East would return [1,0,0] A unit facing South would return [0,-1,0] A unit facing West would return [-1,0,0]
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorDir(GameValue rightInstance)
        {
            return new GameValue(vectordir(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return object's normalized direction vector in world space ([x,y,z]) in render time scope.  A unit facing North would return [0,1,0] A unit facing East would return [1,0,0] A unit facing South would return [0,-1,0] A unit facing West would return [-1,0,0]
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorDirVisual(GameValue rightInstance)
        {
            return new GameValue(vectordirvisual(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns Euclidean distance between two points.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue VectorDistance(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectordistance(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Squared distance between two 3D vectors.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue VectorDistanceSqr(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectordistancesqr(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Dot product of two 3D vectors.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue VectorDotProduct(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectordotproduct(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Unit vector, equal to direction from vector1 to vector2. In other words this command produces  normalised vector between given 2 points. To get a non-normalised vector, use vectorDiff.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorFromTo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectorfromto(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Interpolates vector between the given vectorFrom and vectorTo value according to the given range value.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorLinearConversion(GameValue rightInstance)
        {
            return new GameValue(vectorlinearconversion(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Magnitude of a 3D vector.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue VectorMagnitude(GameValue rightInstance)
        {
            return new GameValue(vectormagnitude(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Squared magnitude of a 3D vector.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue VectorMagnitudeSqr(GameValue rightInstance)
        {
            return new GameValue(vectormagnitudesqr(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts vector direction from model to world space. ⚠For scaled objects, the resulting vector's magnitude will also be multiplied by the object scale.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorModelToWorld(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectormodeltoworld(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts vector from model to world space in render time scope. ⚠For scaled objects, the resulting vector's magnitude will also be multiplied by the object scale.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorModelToWorldVisual(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectormodeltoworldvisual(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Multiplies 3D vector by a scalar.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorMultiply(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectormultiply(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns normalized vector (unit vector, vectorMagnitude == 1) of given vector. If given vector is 0 result is a 0 vector as well.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorNormalized(GameValue rightInstance)
        {
            return new GameValue(vectornormalized(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns up vector of the given object in format Vector3D. ⚠The vector is not necessarily normalized. The magnitude of the vector will be the same as the object scale.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorUp(GameValue rightInstance)
        {
            return new GameValue(vectorup(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return object's up vector in world Position coordinates ( [x, y, z] ) in render time scope.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorUpVisual(GameValue rightInstance)
        {
            return new GameValue(vectorupvisual(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts vector direction from world to model space. ⚠For scaled objects, the resulting vector's magnitude will be divided by the object scale.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorWorldToModel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectorworldtomodel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts vector direction from world to model space in render time scope. ⚠For scaled objects, the resulting vector's magnitude will be divided by the object scale.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VectorWorldToModelVisual(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vectorworldtomodelvisual(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Vehicle in which given unit is mounted. If none, unit is returned. Alternatively, use objectParent ⚠While vehicle may return the vehicle the unit is in for alive units, for dead units which are groupless, this command returns the unit itself - use objectParent instead.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue Vehicle(GameValue rightInstance)
        {
            return new GameValue(vehicle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if the vehicle has enabled transporting other vehicles or not.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue VehicleCargoEnabled(GameValue rightInstance)
        {
            return new GameValue(vehiclecargoenabled(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Types text to the vehicle radio channel. The text will be visible only on the PC where command was executed. If you need the message to show on all computers, you have to execute it globally, see remoteExec. Object parameter must be a vehicle, not a player If you are in a crew seat (i.e. driver, gunner or commander), then it will include that role in the chat name output (Eg: Driver (you_name): "Message")
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue VehicleChat(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vehiclechat(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current vehicle move/turn info (a getter for sendSimpleCommand) in format [moveInfo, turnInfo]. Possible values: moveInfo turnInfo "FORMATION" - vehicle is stationary "FORWARD"  - vehicle is moving forward "FAST" - vehicle is fast moving forward "SLOW" - vehicle is slow moving forward "STOP" - vehicle is stationary "BACK" - vehicle is reversing "DirectByComander"sic - keyboard pilot is used, i.e. player is in the vehicle and is the effectiveCommander pressing any driving key (WASD or arrows). "LEFT" - vehicle is turning left (use  "STOPTURNING" to cancel) "RIGHT" - vehicle is turning right (use  "STOPTURNING" to cancel) "NONE" - vehicle is not turning (when script command is used) "ABS" - vehicle is not turning (when keyboard pilot is used)
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VehicleMoveInfo(GameValue rightInstance)
        {
            return new GameValue(vehiclemoveinfo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Sends the audio message to the vehicle radio channel. The message is defined in CfgRadio in the description.ext file or config radio protocol. The transmission will play only on the PC where command was executed. If you need the transmission to play on all computers, you have to execute it globally (see remoteExec). When transmitting unit gets killed, transmission will be interrupted. However when receiving unit gets killed, the transmission continues to play.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue VehicleRadio(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(vehicleradio(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets whether the vehicle can acquire targets via datalink from the Side center.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue VehicleReceiveRemoteTargets(GameValue rightInstance)
        {
            return new GameValue(vehiclereceiveremotetargets(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets whether the vehicle shares its own position via datalink with the Side center.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue VehicleReportOwnPosition(GameValue rightInstance)
        {
            return new GameValue(vehiclereportownposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets whether the vehicle shares acquired targets via datalink with the Side center.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue VehicleReportRemoteTargets(GameValue rightInstance)
        {
            return new GameValue(vehiclereportremotetargets(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of all vehicles available to current client. This command returns both empty and crewed vehicles but not soldiers. It will also return "WeaponHolderSimulated" of dead bodies (weapon on the ground). Vehicles created with createVehicleLocal will only be returned on the client that created them.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Vehicles()
        {
            return new GameValue(vehicles());
        }

        /// <summary>
        /// Returns the variable name that contains a primary editor reference to this object. This is the variable given in the Insert Unit dialog / name field in the editor. It can be changed using setVehicleVarName.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue VehicleVarName(GameValue rightInstance)
        {
            return new GameValue(vehiclevarname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the velocity of the object as vector in m/s.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Velocity(GameValue rightInstance)
        {
            return new GameValue(velocity(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the velocity (speed vector) of the vehicle as an array with format [x, y, z]. Vector is in model space.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VelocityModelSpace(GameValue rightInstance)
        {
            return new GameValue(velocitymodelspace(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Check if file is signed by any key present in game keys folders. On clients, it does not check against the keys accepted by server.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue VerifySignature(GameValue rightInstance)
        {
            return new GameValue(verifysignature(rightInstance._internalGameValue));
        }

        /// <summary>
        /// nameof vest.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue Vest(GameValue rightInstance)
        {
            return new GameValue(vest(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns a cargo container of a unit's vest.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue VestContainer(GameValue rightInstance)
        {
            return new GameValue(vestcontainer(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with all items (of any kind, even weapons) from vest.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VestItems(GameValue rightInstance)
        {
            return new GameValue(vestitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with all magazines from vest of the given unit.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VestMagazines(GameValue rightInstance)
        {
            return new GameValue(vestmagazines(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the rendering distance.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue ViewDistance()
        {
            return new GameValue(viewdistance());
        }

        /// <summary>
        /// Checks if the player has compass opened and visible. Keep in mind that the GPS minimap in Arma 3 also shows the direction.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue VisibleCompass()
        {
            return new GameValue(visiblecompass());
        }

        /// <summary>
        /// Checks if the player has GPS receiver (minimap) opened and visible.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue VisibleGps()
        {
            return new GameValue(visiblegps());
        }

        /// <summary>
        /// Return true if the main map is shown (active). In Arma 3 it also returns true if the respawn screen map is visible.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue VisibleMap()
        {
            return new GameValue(visiblemap());
        }

        /// <summary>
        /// Returns an object's rendered position (z value above surface underneath) in render time scope. Same as getPosVisual. ⚠This command should not be used for actual 3D calculations. See getPos for more details.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VisiblePosition(GameValue rightInstance)
        {
            return new GameValue(visibleposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an object's rendered ASL position (z value above sea level) in render time scope.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue VisiblePositionASL(GameValue rightInstance)
        {
            return new GameValue(visiblepositionasl(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks whether the score table is visible.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue VisibleScoretable()
        {
            return new GameValue(visiblescoretable());
        }

        /// <summary>
        /// Checks if the player has watch opened and visible. Keep in mind that the GPS minimap in Arma 3 also shows the time.
        /// </summary>
        /// <returns>GameValue bool</returns>
        public static GameValue VisibleWatch()
        {
            return new GameValue(visiblewatch());
        }

        /// <summary>
        /// Suspends execution of scheduled script until the given condition satisfied.  This command will loop and call the code inside {} mostly every frame, depends on complexity of the condition and the overall engine load, until the code returns true If the very first execution of the code returns true the command will exit immediately, therefore it will not produce any "Suspending not allowed in this context" error when used inside non-scheduled script. For all other uses it must be executed in environment that allows suspension (canSuspend), such as spawned or execVMed code Avoid doing waitUntil { time > 20 }; and use sleep 20; instead! If you can, add a sleep to the condition to save some cpu cycles waitUntil { sleep 1; !alive player }; Since Arma 3 v1.94, a condition returning anything other than true or false will result in an appropriate type error.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue WaitUntil(GameValue rightInstance)
        {
            return new GameValue(waituntil(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return waves value.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue Waves()
        {
            return new GameValue(waves());
        }

        /// <summary>
        /// Gets the object attached to the waypoint.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue WaypointAttachedObject(GameValue rightInstance)
        {
            return new GameValue(waypointattachedobject(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the vehicle attached to the waypoint. A vehicle can be attached to a waypoint by creating the waypoint on top of the vehicle in the 2D Editor using waypointAttachVehicle
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue object</returns>
        public static GameValue WaypointAttachedVehicle(GameValue rightInstance)
        {
            return new GameValue(waypointattachedvehicle(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attaches a static object via it is numeric ID to the given waypoint. ⚠ The main syntax doesn't work in Arma 3 anymore. The alternative syntax is (at least) available since Arma 2.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue WaypointAttachObject(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(waypointattachobject(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Attaches the Waypoint to the provided vehicle Object. ⚠Use this command to associate a transport with "GETIN" waypoint, other types of waypoints might or might not work. See also setWaypointType to set the waypoint type to "GETIN".
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue nothing</returns>
        public static GameValue WaypointAttachVehicle(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(waypointattachvehicle(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint behavior.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointBehaviour(GameValue rightInstance)
        {
            return new GameValue(waypointbehaviour(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint's combat mode setting.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointCombatMode(GameValue rightInstance)
        {
            return new GameValue(waypointcombatmode(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the radius around the waypoint where the waypoint is completed.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue WaypointCompletionRadius(GameValue rightInstance)
        {
            return new GameValue(waypointcompletionradius(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint description.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointDescription(GameValue rightInstance)
        {
            return new GameValue(waypointdescription(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if the waypoint behavior is forced.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue WaypointForceBehaviour(GameValue rightInstance)
        {
            return new GameValue(waypointforcebehaviour(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint formation. Possible values are:  "NO CHANGE" "COLUMN" "STAG COLUMN" "WEDGE" "ECH LEFT" "ECH RIGHT" "VEE" "LINE" "FILE" "DIAMOND"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointFormation(GameValue rightInstance)
        {
            return new GameValue(waypointformation(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns buildingPos index assigned to the waypoint.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue WaypointHousePosition(GameValue rightInstance)
        {
            return new GameValue(waypointhouseposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint loiter altitude.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue WaypointLoiterAltitude(GameValue rightInstance)
        {
            return new GameValue(waypointloiteraltitude(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint loiter radius. Waypoint uses format Waypoint.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue WaypointLoiterRadius(GameValue rightInstance)
        {
            return new GameValue(waypointloiterradius(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint loiter type. Waypoint uses format Waypoint.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointLoiterType(GameValue rightInstance)
        {
            return new GameValue(waypointloitertype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint name.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointName(GameValue rightInstance)
        {
            return new GameValue(waypointname(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get provided waypoint's position.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WaypointPosition(GameValue rightInstance)
        {
            return new GameValue(waypointposition(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array of waypoints for the specified unit/group.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Waypoints(GameValue rightInstance)
        {
            return new GameValue(waypoints(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint script.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointScript(GameValue rightInstance)
        {
            return new GameValue(waypointscript(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Checks if the UAV has waypoints enabled.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue WaypointsEnabledUAV(GameValue rightInstance)
        {
            return new GameValue(waypointsenableduav(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for showWaypoint command.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointShow(GameValue rightInstance)
        {
            return new GameValue(waypointshow(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint speed. Possible values are: "UNCHANGED" "LIMITED" "NORMAL" "FULL"
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointSpeed(GameValue rightInstance)
        {
            return new GameValue(waypointspeed(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint statements.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WaypointStatements(GameValue rightInstance)
        {
            return new GameValue(waypointstatements(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint timeout values.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WaypointTimeout(GameValue rightInstance)
        {
            return new GameValue(waypointtimeout(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the current timeout for currentWaypoint of a group or -1 if countdown is not in progress.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue WaypointTimeoutCurrent(GameValue rightInstance)
        {
            return new GameValue(waypointtimeoutcurrent(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Gets the waypoint type. See Waypoints - Waypoint Types for more information.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WaypointType(GameValue rightInstance)
        {
            return new GameValue(waypointtype(rightInstance._internalGameValue));
        }

        /// <summary>
        /// A getter for setWaypointVisible command. ⚠Returns 0 (Number) instead of Booleanfor an invalid waypoint.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue WaypointVisible(GameValue rightInstance)
        {
            return new GameValue(waypointvisible(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with all items linked to a given weapon. ⚠This command does not return loaded magazines, see weaponsItems
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponAccessories(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(weaponaccessories(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array with all items assigned to the given weapon in given cargo container. ⚠This is unofficial documentation. All Information here is as it exists in the Engine. It might not reflect the reality.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponAccessoriesCargo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(weaponaccessoriescargo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Get array with weapons from ammo box (or any general weapon holder container).
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponCargo(GameValue rightInstance)
        {
            return new GameValue(weaponcargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the direction that the vehicle weapon is aiming in. For addons the weapon name must be an entry in CfgWeapons. Turret and gun angle in degrees can also be obtained using animationSourcePhase or animationPhase commands.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponDirection(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(weapondirection(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current rate of how much the weapon view is distorted because of quick aiming.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponInertia(GameValue rightInstance)
        {
            return new GameValue(weaponinertia(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns true if given soldier's weapon is lowered. ⚠This command will always return false if player is sprinting, even without a weapon. Alternatively, the weapon raised state could be obtained via animationState command ...slow... vs ...sras...
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue bool</returns>
        public static GameValue WeaponLowered(GameValue rightInstance)
        {
            return new GameValue(weaponlowered(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns current ammo round reloading phase. For a magazine reloading phase see weaponState command.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue scalar</returns>
        public static GameValue WeaponReloadingTime(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(weaponreloadingtime(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns array of names of all unit's weapons.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue Weapons(GameValue rightInstance)
        {
            return new GameValue(weapons(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns entity's weapons information including weapon index and firemode.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponsInfo(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(weaponsinfo(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array with subarrays contains class names and also names of connected items of all the vehicle's weapons.  This command will return weapon magazines as well in format [magazineName, ammoCount], or empty array [] if weapon has no magazine Since Arma 3 v1.22 it is possible to query weapon holders and ammo crates with this command. If the argument is a vehicle, the command will return vehicle's weapons. If the argument is a container, the command will act identical to weaponsItemsCargo. Since Arma 3 v1.96 the returned array always contains secondary muzzle magazine info and consistent with getUnitLoadout format for weapon items. Since Arma 3 v2.02 the returned array can contains binocular weapon items.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponsItems(GameValue rightInstance)
        {
            return new GameValue(weaponsitems(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns an array with subarrays contains class names and also names of connected items of all the vehicle's cargo weapons in weaponsItems format. If weapon has no magazine, an empty array [] is returned instead of magazine info. If the argument is a vehicle with weapons, vehicles cargo is searched, unlike with weaponsItems command, which will return vehicle's weapons instead.  Since Arma 3 v1.96 the returned array always contains secondary muzzle magazine info and consistent with getUnitLoadout format for weapon items.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponsItemsCargo(GameValue rightInstance)
        {
            return new GameValue(weaponsitemscargo(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the given or currently selected weapon state for unit or vehicle. With Syntax 2, if no optional arguments are present, currently selected weapon is queried. Since Arma 3 v1.70 this command has been improved and extended: A vehicle's weapon query doesn't need a weapon operator provided the weapon or muzzle is specified in optional param.(keep in mind that by default a vehicle has no weapons selected) Driver turret can now be accessed as well with turret path [-1]. Muzzle name is supported as well as weapon name. The command searches for weapon first, then if not found, muzzle is searched for.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponState(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(weaponstate(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns all weapons of a given turret. Use turret path [-1] for driver's turret.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeaponsTurret(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(weaponsturret(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.Returns weight of RTD helicopter.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WeightRTD(GameValue rightInstance)
        {
            return new GameValue(weightrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// West (BLUFOR) side.
        /// </summary>
        /// <returns>GameValue side</returns>
        public static GameValue West()
        {
            return new GameValue(west());
        }

        /// <summary>
        /// Returns the unlocalized text value of a side or an object's/group's side. Side east / opfor west / blufor resistance / independent civilian sideUnknown sideEnemy sideFriendly sideLogic sideEmpty sideAmbientLife Result "East" "West" "Resistance" "Civilian" "Unknown" WF stands for Warfare, an Armed Assault/Arma 2 official game mode.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue string</returns>
        public static GameValue WFSideText(GameValue rightInstance)
        {
            return new GameValue(wfsidetext(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Returns the current wind vector (in m/s) as array [x, y, z]. The last value (z, "up-down") always returns 0 – wind being only horizontal.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue Wind()
        {
            return new GameValue(wind());
        }

        /// <summary>
        /// Returns the current wind azimuth.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue WindDir()
        {
            return new GameValue(winddir());
        }

        /// <summary>
        /// Returns wind strength and direction. For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD.
        /// </summary>
        /// <returns>GameValue array</returns>
        public static GameValue WindRTD()
        {
            return new GameValue(windrtd());
        }

        /// <summary>
        /// Returns the current wind strength.
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue WindStr()
        {
            return new GameValue(windstr());
        }

        /// <summary>
        /// For this command to have any effect, the Advanced Flight Model (AFM) has to be enabled. AFM status can be checked with difficultyEnabledRTD. Returns force produced by wings.
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WingsForcesRTD(GameValue rightInstance)
        {
            return new GameValue(wingsforcesrtd(rightInstance._internalGameValue));
        }

        /// <summary>
        /// Return the name of the currently loaded world.
        /// </summary>
        /// <returns>GameValue string</returns>
        public static GameValue WorldName()
        {
            return new GameValue(worldname());
        }

        /// <summary>
        /// Returns the engine calculated size (terrain side length) of the current world (BIS_fnc_mapSize may return the same value, but is just a simple look up in  config).
        /// </summary>
        /// <returns>GameValue scalar</returns>
        public static GameValue WorldSize()
        {
            return new GameValue(worldsize());
        }

        /// <summary>
        /// Converts position from world space to object model space. ⚠For scaled objects, the relative position will be divided by the object scale.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WorldToModel(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(worldtomodel(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts position from world space to object model space in render time scope. ⚠For scaled objects, the relative position will be divided by the object scale.
        /// </summary>
        /// <param name="leftInstance"></param>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WorldToModelVisual(GameValue leftInstance, GameValue rightInstance)
        {
            return new GameValue(worldtomodelvisual(leftInstance._internalGameValue, rightInstance._internalGameValue));
        }

        /// <summary>
        /// Converts position in world space into screen (UI) space. If a specified position is not within the current screen view, an empty array is returned. SafeZones should be considered: the result can be out of the [0,0]..[1,1] range the result can be a filled array even if the position is not displayed on screen if it would appear on a triplescreen setup
        /// </summary>
        /// <param name="rightInstance"></param>
        /// <returns>GameValue array</returns>
        public static GameValue WorldToScreen(GameValue rightInstance)
        {
            return new GameValue(worldtoscreen(rightInstance._internalGameValue));
        }
    }
}